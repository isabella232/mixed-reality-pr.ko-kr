---
title: 호환성이 손상되는 변경
description: MRTK의 주요 변경 내용에 대 한 정책입니다.
author: polar-kev
ms.author: kesemple
ms.date: 01/12/2021
keywords: Unity, HoloLens, HoloLens 2, Mixed Reality, 개발, MRTK
ms.openlocfilehash: 46e3061319140a561d267983d4d170eea937fd28b7d3e833c3382c1e37a70392
ms.sourcegitcommit: a1c086aa83d381129e62f9d8942f0fc889ffcab0
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 08/05/2021
ms.locfileid: "115191537"
---
# <a name="breaking-changes"></a>주요 변경 내용

MRTK의 소비자는 안정적인 릴리스 간 API surface를 사용 하는 것에 의존 하므로 매번 크게 변경 하지 않고도 MRTK를 업데이트할 수 있습니다.

이 페이지에서는 MRTK의 주요 변경 내용에 대 한 현재 정책에 대해 설명 하 고, 주요 변화를 최소화 하 고 코드에 대 한 적절 한 장기 기술 변경을 수행 하는 것과 관련 된 균형을 보다 효율적으로 관리할 수 있는 방법에 대 한 몇 가지 장기적인 목표를 설명 합니다.

## <a name="what-is-a-breaking-change"></a>주요 변경 내용 이란?

변경 내용은 [목록 a](#list-a) 의 조건을 충족 하 고 [목록 B](#list-b) 의 모든 조건을 충족 하는 경우 주요 변경 내용입니다.

### <a name="list-a"></a>목록 표시

- 모든 인터페이스의 멤버 또는 함수 (또는 전체 인터페이스의 제거/이름 바꾸기)의 추가, 제거 또는 업데이트입니다.
- 보호 된 멤버 또는 클래스의 함수를 제거, 업데이트 (형식/정의 변경, 개인 또는 내부 변경). (또는 전체 클래스의 제거/이름 바꾸기).
- 클래스에 의해 발생 하는 이벤트의 순서 변경입니다.
- 모든 개인 SerializedField (해당 FormerlySerializedAs 태그 없음) 또는 public 속성 (특히 프로필에 대 한 변경)의 이름을 바꿉니다.
- 스크립트가 있는 필드의 형식 변경 (특히 프로필에 대 한 변경)
- 모든 클래스나 인터페이스의 네임 스페이스 또는 asmdefs를 업데이트 합니다.
- Prefab의 최상위 개체에서 prefab 제거 또는 스크립트 제거

### <a name="list-b"></a>목록 B

- 해당 자산은 기반 패키지 (즉, 다음 폴더 중 하나에 있는)에 있습니다.

  - MRTK/Core
  - MRTK/공급자/
  - MRTK/서비스/
  - MRTK/SDK/
  - MRTK/Extensions

- 문제의 자산이 실험적 네임 스페이스에 속하지 않습니다.

> [!IMPORTANT]
> 예 패키지 (예: MRTK/예제/폴더의 일부)에 있는 자산은 언제 든 지 변경 될 수 있습니다 .이는 소비자가 ' 참조 구현 '으로 복사 하 고 볼 수 있도록 설계 되었지만 Api 및 자산의 핵심 집합에 포함 되지 않기 때문입니다. 실험적 네임 스페이스의 자산 (또는 일반적으로 실험적 이라고 하는 기능)은 모든 기한 성실 (예: 테스트, UX 반복, 설명서)가 완료 되기 전에 게시 되는 것 이며 빠르게 피드백을 얻기 위해 조기에 게시 됩니다.  그러나 사용자에 게는 테스트 및 설명서가 없으며 모든 상호 작용 및 디자인을 이죠 하지 않았기 때문에 공용에서이를 변경 하 고 변경 될 수 있다고 가정 하는 상태로 게시 합니다 (즉, 수정, 완전히 제거 등).
>
> 자세한 내용은 [실험적 기능](../contributing/experimental-features.md) 을 참조 하세요.

주요 변경 내용에 대 한 노출 영역이 매우 크기 때문에 "주요 변경 내용 없음"을 의미 하는 절대 규칙을 유지 하는 것은 불가능 합니다. 주요 변경 사항을 적용 하 여 sane 방식 으로만 해결할 수 있는 문제가 있을 수 있습니다. 또 다른 방법으로 "주요 변경 내용 없음"은 변경 하지 않아도 되는 유일한 방법입니다.

Microsoft의 고정 정책은 가능한 경우 주요 변경 사항을 방지 하 고 변경으로 인해 중요 한 고객 또는 프레임 워크 장기적인 가치를 계산 하는 경우에만 수행 하는 것입니다.

## <a name="what-to-do-about-breaking-changes"></a>주요 변경 내용에 대해 수행할 작업

주요 변경 없이 작업을 수행할 수 있고 장기적인 구조와 기능의 실행 가능성을 손상 시 키 지 않으면 주요 변경 작업을 수행 하지 않습니다. 다른 방법이 없는 경우 현재 정책은 각 개별 주요 변경 사항을 평가 하 여 변경의 이점을 흡수 소비자에 게 부과 하는 이점을 이해 하는 것입니다. 무엇을 할 만한 가치가 있으며 PR 또는 문제 토론 자체에서 일반적으로 수행 하지 않는 작업에 대해 논의 합니다.

여기에서 수행할 수 있는 작업은 여러 버킷에 속합니다.

### <a name="the-breaking-change-adds-value-but-could-be-written-in-a-way-that-isnt-breaking"></a>주요 변경 내용에는 값이 추가 되지만 중단 되지 않는 방식으로 작성 될 수 있습니다.

예를 들어 [이 PR](https://github.com/microsoft/MixedRealityToolkit-Unity/pull/4882) 은 처음에는 중단 된 방식으로 작성 된 새 기능을 추가 했습니다. 기존 인터페이스를 수정 했지만 해당 기능이 자체 인터페이스로 분할 된 경우 다시 작성 되었습니다. 이는 일반적으로 가능한 최상의 결과입니다. 장기적으로 변경 하는 것을 방지 하는 것이 중요 합니다. 그렇지 않으면 기능의 작동 중단 또는 구조가 손상 될 수 있습니다.

### <a name="the-breaking-change-adds-sufficient-value-to-the-customer-that-its-worth-doing"></a>주요 변경 내용으로 충분 한 가치를 고객에 게 추가 합니다.

주요 변경 내용에 대해 설명 하 고 가능한 한 완화 조치를 제공 합니다. 즉, 마이그레이션을 수행 하는 방법에 대 한 지침을 제공 하거나 고객을 위해 자동으로 마이그레이션하는 도구를 제공 합니다. 각 릴리스에는 약간의 변경 내용이 포함 될 수 있습니다. [이는이 PR](https://github.com/microsoft/MixedRealityToolkit-Unity/pull/4858)에서 수행 된 것 처럼 항상 문서에 문서화 되어야 합니다. 2.x → 2.x +1 + 1 마이그레이션 가이드가 이미 있는 경우 해당 문서에 명령 또는 도구를 추가 합니다. 존재 하지 않는 경우 만듭니다.

### <a name="the-breaking-change-adds-value-but-the-customer-pain-would-be-too-high"></a>주요 변경 내용에는 값이 추가 되지만 고객 불만은 너무 높음

모든 유형의 주요 변경 내용이 동일 하 게 생성 되는 것은 아닙니다. 일부는 microsoft의 경험을 기반으로 하 고 고객 환경을 기반으로 합니다. 예를 들어 인터페이스를 변경 하는 것은 문제가 될 수 있지만, 고객이 과거에 확장/구현할 가능성이 거의 없는 (예: 진단 시각화 시스템) 실제 비용은 거의 없습니다. 그러나 변경 내용이 scriptableobject의 필드 유형 (예: MRTK의 핵심 프로필 중 하나) 인 경우 대규모 고객 불만을 초래할 수 있습니다. 고객은 이미 기본 프로필을 복제 했 고, 병합/업데이트 프로필은 수동으로 수행 하는 것이 매우 어려울 수 있습니다 (즉, 병합 시간 동안 텍스트 편집기를 통해), 기본 프로필을 다시 복사 하 여 모든 항목을 다시 구성 하는 것은 재발을 디버그 하기가 어려울 가능성이 높습니다.

이러한 변경 내용은 고객이 업그레이드에 대 한 이유를 제공 하는 중요 한 변경 내용을 적용할 수 있는 분기가 있을 때까지 선반에 다시 배치 해야 합니다. 이러한 분기가 현재 존재 하지 않습니다. 미래의 반복 계획 회의에서 ' 너무 중단 ' 된 변경 내용/문제 집합을 검토 하 여 중요 한 질량에 도달 하 여 한 번에 하나의 변경 내용 집합을 실행 하는 것이 적절 한지 확인 합니다. 제한 된 엔지니어링 리소스로 인해 성실이 수행 되는 것이 아니라 "모두 허용 됩니다." 분기를 실행 하는 것은 위험 하며,이를 통해 테스트 및 유효성 검사를 분할 해야 합니다. 존재 하는 경우 해당 분기의 명확한 목적과 종료 날짜가 필요 합니다.

## <a name="long-term-management-of-breaking-changes"></a>주요 변경 내용에 대 한 장기적인 관리

장기적으로는 [목록 B](#list-b)에서 조건 집합을 늘려서 주요 변경 내용에 대 한 범위를 줄여야 합니다. [목록 A](#list-a) 의 항목 집합을 앞으로 이동 하면 "공용 API surface"에 있는 것으로 간주 되는 파일 및 자산의 집합에 대해 항상 기술적으로 중단 됩니다. 반복에 대해 약간 더 자유롭게 (즉, 내부 구현 세부 정보를 변경 하 고, 여러 클래스 간에 코드를 쉽게 리팩터링 하 고 공유할 수 있도록 하는 방법) 구현 세부 정보가 아니라 공식 화면에서 코드 부분을 보다 명확 하 게 파악할 수 있습니다.

이미 수행 된 작업 중 하나는 "실험적" 기능의 개념을 소개 하는 것입니다 .이 기능은 실험적 네임 스페이스에 속하고 테스트/설명서는 없으며, 공개적으로 존재 하도록 요청 되었지만 경고 없이 제거 및 업데이트 될 수 있습니다. 이에 따라 이전 피드백을 얻기 위해 새 기능을 빨리 추가할 수 있지만 api 화면에 직접 연결할 수는 없습니다 (API 화면을 완전히 생각 하지 못할 수 있음).

### <a name="other-examples-of-things-that-could-help-in-the-future"></a>나중에 도움이 될 수 있는 기타 사물 예

- [Internal 키워드](/dotnet/csharp/language-reference/keywords/internal)를 사용 합니다.
  이렇게 하면 외부 소비자에 게 공개 하지 않고 코드 중복을 줄이기 위해 자체 어셈블리 내에서 코드를 공유할 수 있습니다.
- "내부" 네임 스페이스 (예: MixedReality. Toolkit를 만듭니다. 내부 유틸리티). 내부 네임 스페이스 내에 포함 된 항목은 언제 든 지 변경 될 수 있으며 제거 될 수 있다는 것을 공개적으로 문서화 합니다. 이는 c + + 헤더 라이브러리를 통해:: internal 네임 스페이스를 사용 하 여 구현 세부 정보를 숨기는 방법과 비슷합니다.
