---
title: 공간 매핑
description: 공간 매핑은 HoloLens 환경의 실제 표면을 자세히 표현합니다.
author: mattzmsft
ms.author: mazeller
ms.date: 03/21/2018
ms.topic: article
keywords: 공간 매핑, HoloLens, 혼합 현실, 표면 재구성, 메시, 혼합 현실 헤드셋, windows mixed reality 헤드셋, 가상 현실 헤드셋, HoloLens, MRTK, Mixed Reality Toolkit, 장면 이해, 세계 메시, 폐색, 물리학, 탐색, 표면 관찰자, 렌더링, 메시 처리
ms.openlocfilehash: 342ba116a5e33073acf2d4dbe563e74bccbf7053ec96d9b3f2f7ba88bd13da90
ms.sourcegitcommit: a1c086aa83d381129e62f9d8942f0fc889ffcab0
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 08/05/2021
ms.locfileid: "115212426"
---
# <a name="spatial-mapping"></a>공간 매핑

공간 매핑은 HoloLens 주변 환경에서 실제 표면을 자세히 표현하여 개발자가 혼합 현실 환경을 만들 수 있도록 합니다. 실제 세계를 가상 세계와 병합하면 애플리케이션이 홀로그램을 실제처럼 보이게 만들 수 있습니다. 또한 애플리케이션은 친숙한 실제 동작 및 상호 작용을 제공하여 사용자 기대치에 더 자연스럽게 맞출 수 있습니다.

<br>

>[!VIDEO https://www.youtube.com/embed/zff2aQ1RaVo]

## <a name="device-supports"></a>디바이스 지원

<table>
    <colgroup>
    <col width="25%" />
    <col width="25%" />
    <col width="25%" />
    <col width="25%" />
    </colgroup>
    <tr>
        <td><strong>기능</strong></td>
        <td><a href="/hololens/hololens1-hardware"><strong>HoloLens(1세대)</strong></a></td>
        <td><a href="https://docs.microsoft.com/hololens/hololens2-hardware"><strong>HoloLens 2</strong></td>
        <td><a href="../discover/immersive-headset-hardware-details.md"><strong>몰입형 헤드셋</strong></a></td>
    </tr>
     <tr>
        <td>공간 매핑</td>
        <td>✔️</td>
        <td>✔️</td>
        <td>❌</td>
    </tr>
</table>


## <a name="why-is-spatial-mapping-important"></a>공간 매핑이 중요한 이유는 무엇인가요?

공간 매핑을 사용하면 개체를 실제 표면에 배치할 수 있습니다. 이렇게 하면 사용자의 세계에 개체를 고정하고 실제 깊이 신호를 활용할 수 있습니다. 다른 홀로그램 및 실제 개체를 기반으로 홀로그램을 폐색하면 이러한 홀로그램이 실제로 공간에 있다는 것을 사용자에게 확신시키는 데 도움이 됩니다. 홀로그램스 공간에서 부동하거나 사용자와 함께 이동하는 것은 실제처럼 느낄 수 없습니다. 가능하면 편안하게 항목을 배치합니다.

홀로그램을 배치하거나 이동할 때 표면을 시각화합니다(프로젝스된 그리드 사용). 이렇게 하면 사용자가 홀로그램을 가장 잘 배치할 수 있는 위치를 알 수 있으며 홀로그램을 배치하려는 지점이 매핑되지 않은지 확인할 수 있습니다. 너무 많은 각도로 끝나는 경우 사용자에 대해 "항목"을 "쌓을" 수 있습니다.

## <a name="conceptual-overview"></a>개념적 개요

![공간을 덮는 메시 표면](images/SurfaceReconstruction.jpg)<br>
*공간을 덮고 있는 공간 매핑 메시의 예*

공간 매핑에 사용되는 두 가지 기본 개체 형식은 '공간 표면 관찰자'와 '공간 표면'입니다.

애플리케이션은 공간 표면 관찰자에게 하나 이상의 경계 볼륨을 제공하여 애플리케이션이 공간 매핑 데이터를 수신하려는 공간 영역을 정의합니다. 이러한 각 볼륨에 대해 공간 매핑은 애플리케이션에 공간 표면 집합을 제공합니다.

이러한 볼륨은 고정되어 있거나(실제 세계에 따라 고정된 위치에 있음) HoloLens 연결될 수 있습니다(환경을 통해 이동할 때 HoloLens 사용하여 이동하지만 회전하지 않음). 각 공간 표면은 세계에서 잠긴 [공간 좌표계](coordinate-systems.md)에 연결된 삼각형 메시로 표현되는 작은 공간 볼륨의 실제 표면을 설명합니다.

HoloLens 환경에 대한 새 데이터를 수집하고 환경 변경이 발생하면 공간 표면이 나타나고, 사라지고, 변경됩니다.

## <a name="spatial-awareness-design-concepts-demo"></a>공간 인식 디자인 개념 데모

공간 인식 디자인 개념이 작동하는 모습을 보려면 **아래의 디자인 홀로그램스 - 공간 인식** 비디오 데모를 확인하세요. 완료되면 계속해서 특정 주제에 대해 자세히 알아봅니다.

> [!VIDEO https://channel9.msdn.com/Shows/Docs-Mixed-Reality/Microsofts-Designing-Holograms-Spatial-Awareness-Chapter/player]

*이 동영상은 "홀로그램 디자인" HoloLens 2 앱에서 가져온 것입니다. [여기](https://aka.ms/dhapp)에서 전체 환경을 다운로드하여 즐겨 보세요.*

## <a name="spatial-mapping-vs-scene-understanding-worldmesh"></a>공간 매핑과 장면 이해 WorldMesh

HoloLens 2 경우 장면 이해 SDK(EnableWorldMesh 설정)를 사용하여 [](../develop/platform-capabilities-and-apis/scene-understanding-SDK.md) 공간 매핑 데이터의 정적 버전을 쿼리할 수 있습니다. 공간 매핑 데이터에 액세스하는 두 가지 방법의 차이점은 다음과 같습니다.
* 공간 매핑 API:
   * 제한된 범위: 사용자 주위에 '거품형'으로 캐시된 제한된 크기의 애플리케이션에서 사용할 수 있는 공간 매핑 데이터입니다.
   * SurfacesChanged 이벤트를 통해 변경된 메시 영역의 짧은 대기 시간 업데이트를 제공합니다.
   * 삼각형 Per 입방 미터 매개 변수로 제어되는 가변 수준의 세부 정보입니다.
* 장면 이해 SDK:
   * 무제한 범위 - 쿼리 반경 내에서 검색된 모든 공간 매핑 데이터를 제공합니다.
   * 공간 매핑 데이터의 정적 스냅샷을 제공합니다. 업데이트된 공간 매핑 데이터를 가져오려면 전체 메시에 대한 새 쿼리를 실행해야 합니다.
   * RequestedMeshLevelOfDetail 설정에 의해 제어되는 일관된 수준의 세부 정보입니다.

## <a name="what-influences-spatial-mapping-quality"></a>공간 매핑 품질에 영향을 미치는 것은 무엇인가요?

[여기에](/hololens/hololens-environment-considerations)자세히 설명된 몇 가지 요소는 이러한 오류의 빈도 및 심각도에 영향을 줄 수 있습니다.  그러나 사용자가 공간 매핑 데이터에 오류가 있는 경우에도 목표를 달성할 수 있도록 애플리케이션을 디자인해야 합니다.

## <a name="common-usage-scenarios"></a>일반 시나리오

![일반적인 공간 매핑 사용 시나리오의 그림: 배치, 폐색, 물리학 및 탐색](images/sm-concepts-1000px.png)

### <a name="placement"></a>배치

공간 매핑은 애플리케이션에 자연스럽고 친숙한 형태의 상호 작용을 사용자에게 표시할 수 있는 기회를 제공합니다. 휴대폰을 데스크에 배치하는 것보다 더 자연스러운 것은 무엇일까요?

홀로그램의 배치(또는 일반적으로 모든 공간 위치 선택)를 화면에 배치하도록 제한하면 3D(공간 지점)에서 2D(표면의 점)로 자연스럽게 매핑할 수 있습니다. 이렇게 하면 사용자가 애플리케이션에 제공해야 하는 정보의 양이 줄어들고 사용자의 상호 작용이 더 빠르고 쉽고 정확하게 됩니다. '거리'는 다른 사람 또는 컴퓨터와 물리적으로 통신하는 데 사용되는 것이 아니기 때문에 이는 사실입니다. 손가락으로 가리키면 거리가 아닌 방향을 지정합니다.

여기서 중요한 주의 사항은 애플리케이션이 방향에서 거리를 유추할 때(예: 사용자의 응시 방향을 따라 광선 캐스트를 수행하여 가장 가까운 공간 표면을 찾음) 사용자가 안정적으로 예측할 수 있는 결과를 생성해야 한다는 것입니다. 그렇지 않으면 사용자가 제어를 잃게 되며 이 경우 빠르게 불편해질 수 있습니다. 이 작업을 수행하는 데 도움이 되는 한 가지 방법은 하나의 광선 캐스트 대신 여러 광선 캐스트를 수행하는 것입니다. 집계 결과는 더 원활하고 예측 가능해야 하며 일시적인 '이상값' 결과의 영향을 덜 받습니다(광선이 작은 구멍으로 통과하거나 사용자가 인식하지 못하는 작은 기하 도형 비트에 도달하여 발생할 수 있음). 집계 또는 다듬기도 시간이 지남에 따라 수행할 수 있습니다. 예를 들어 홀로그램이 사용자와 거리가 다를 수 있는 최대 속도를 제한할 수 있습니다. 최소 및 최대 거리 값을 제한하기만 하면 도움이 될 수 있으므로 이동 중인 홀로그램이 갑자기 멀리 떨어지거나 사용자의 얼굴로 충돌하지 않습니다.

애플리케이션은 표면의 모양과 방향을 사용하여 홀로그램 배치를 안내할 수도 있습니다. 홀로그램 바닥은 벽으로 침투하면 안 되며 약간 균일하지 않더라도 바닥과 플러시되어 있어야 합니다. 이러한 종류의 기능은 광선 캐스트가 아닌 물리학 충돌을 사용하는 데 의존할 수 있지만 비슷한 문제가 적용됩니다. 배치되는 홀로그램에 여러 개의 작은 다각형이 있는 경우(예: 의거형) 다각형의 물리학 표현을 더 넓고 부드러운 것으로 확장하여 스니글링하지 않고 공간 표면 위로 슬라이드할 수 있도록 하는 것이 합리적일 수 있습니다.

극단적인 경우 사용자 입력을 완전히 간소화할 수 있으며 공간 표면을 사용하여 완전히 자동 홀로그램 배치를 수행할 수 있습니다. 예를 들어 애플리케이션은 사용자가 누를 수 있도록 홀로그램 광원 스위치를 벽의 어딘가에 배치할 수 있습니다. 예측 가능성에 대한 동일한 주의 사항은 여기에 이중으로 적용됩니다. 사용자가 홀로그램 배치에 대한 제어를 기대하지만 애플리케이션이 항상 예상하는 곳에 홀로그램을 배치하지 않는 경우(사용자가 도달할 수 없는 곳에 광원 스위치가 나타나는 경우) 이 환경이 어려울 수 있습니다. 사용자가 항상 배치를 수행하도록 요구하는 것보다 사용자가 일정 시간 동안 수정해야 하는 자동 배치를 수행하는 것이 더 나빠질 수 있습니다. 자동 *배치가* 성공적으로 수행되므로 수동 수정은 부담이 될 수 있습니다.

또한 배치를 위해 공간 표면을 사용하는 애플리케이션의 기능은 애플리케이션의 검색 [환경](spatial-mapping.md#the-environment-scanning-experience)에 따라 크게 달라집니다. 표면이 검사되지 않은 경우 배치에 사용할 수 없습니다. 사용자가 새 표면을 검색하거나 새 위치를 선택하는 데 도움이 되도록 사용자에게 이를 명확하게 하는 것은 애플리케이션의 입니다.

사용자에 대한 시각적 피드백은 배치 중에 매우 중요합니다. 사용자는 [접지 효과가](spatial-mapping.md#visualization)인 가장 가까운 표면을 기반으로 홀로그램이 있는 위치를 알고 있어야 합니다. 홀로그램의 이동이 제한된 이유를 이해해야 합니다(예: 다른 주변 표면과의 충돌 때문에). 현재 위치에 홀로그램을 배치할 수 없는 경우 시각적 피드백은 그 이유를 명확히 해야 합니다. 예를 들어, 사용자가 홀로그램 약자를 벽의 중간에 고정시키려고 하면 벽 뒤에 있는 약체 부분이 펄스 색으로 펄스되어야 합니다. 또는 반대로, 애플리케이션이 사용자가 실제 표면을 볼 수 있는 위치에서 공간 표면을 찾을 수 없는 경우 애플리케이션에서 이를 명확히 해야 합니다. 이 영역에서 접지 효과가 없다는 것은 이러한 목적을 달성할 수 있습니다.

### <a name="occlusion"></a>폐색

공간 매핑 표면의 주요 용도 중 하나는 홀로그램을 폐색하는 것입니다. 이 간단한 동작은 홀로그램의 인식된 현실성에 큰 영향을 미치며, 실제로 사용자와 동일한 물리적 공간을 유발하는 내장적인 의미를 만드는 데 도움이 될 수 있습니다.

폐색은 사용자에게 정보를 제공합니다. 홀로그램이 실제 표면에 의해 폐색된 것처럼 보이면 이 기능은 전 세계에서 해당 홀로그램의 공간 위치에 대한 추가 시각적 피드백을 제공합니다. 반대로 폐색은 사용자로부터 정보를 *숨기는* 데 유용하게 사용할 수 있습니다. 벽 뒤에 홀로그램을 폐색하면 직관적인 방식으로 시각적 혼란을 줄일 수 있습니다. 홀로그램을 숨기거나 공개하려면 사용자는 단순히 머리만 이동해야 합니다.

폐색을 사용하여 익숙한 물리적 상호 작용에 따라 자연스러운 사용자 인터페이스에 대한 기대치를 가장 잘 예상할 수도 있습니다. 홀로그램이 표면에 의해 폐색되면 표면이 단색이기 때문이므로 사용자는 홀로그램이 해당 표면과 *충돌하고* 이를 통과하지 않을 것으로 예상해야 합니다.

홀로그램 폐색이 바람직하지 않은 경우도 있습니다. 사용자가 홀로그램과 상호 작용해야 하는 경우 실제 표면 뒤에 있더라도 이를 확인해야 합니다. 이러한 경우 일반적으로 홀로그램이 폐색될 때(예: 밝기를 줄여) 이러한 홀로그램을 다르게 렌더링하는 것이 좋습니다. 이렇게 하면 사용자가 홀로그램을 시각적으로 찾을 수 있지만 여전히 그 뒤에 있다는 것을 알 수 있습니다.

### <a name="physics"></a>Physics

물리학 시뮬레이션의 사용은 공간 매핑을 사용하여 사용자의 물리적 공간에서 홀로그램의 *존재를* 강화할 수 있는 또 다른 방법입니다. 홀로그램 머리공이 내 데스크에서 사실적으로 굴려서 바닥에서 바운드되고, 바닥 아래에서 사라지면, 내가 홀로그램 공에 있지 않다고 생각하기 어려울 수 있습니다.

물리학 시뮬레이션은 애플리케이션에서 자연적이고 친숙한 물리학 기반 상호 작용을 사용할 수 있는 기회도 제공합니다. 바닥의 홀로그램 지형 부분을 이동하면 적절한 관성과 마찰로 바닥에서 슬라이딩하는 것처럼 응답하는 경우 사용자가 더 쉬울 수 있습니다.

실제적인 물리적 동작을 생성하려면 구멍 채우기, 부동 성소 제거 및 거친 표면 다듬기와 같은 일부 [메시 처리를](spatial-mapping.md#mesh-processing) 수행해야 할 수 있습니다.

또한 애플리케이션의 [검사 환경이](spatial-mapping.md#the-environment-scanning-experience) 물리학 시뮬레이션에 미치는 영향을 고려해야 합니다. 첫째, 누락된 표면은 어떤 것과도 충돌하지 않습니다. 공갈공이 배고침을 굴리고 알려진 세계의 끝에서 나오면 어떻게 되나요? 둘째, 시간이 지남에 따라 환경의 변화에 계속 대응할지 여부를 결정해야 합니다. 경우에 따라 최대한 빨리 응답해야 합니다. 사용자가 들어오는 로마 화살표의 tempest에 대한 방어에서 이동 가능한 스트러스로 문과 가구를 사용하는 경우를 말합니다. 그러나 다른 경우에는 새 업데이트를 무시할 수 있습니다. 개가 트랙 중간에 맡기기로 결정하면 홀로그램 스포츠카를 바닥의 트랙 주위로 주행하는 것이 갑자기 그렇게 재미있지 않을 수 있습니다.

### <a name="navigation"></a>탐색

애플리케이션은 공간 매핑 데이터를 사용하여 홀로그램 문자(또는 에이전트)에게 실제 사람과 동일한 방식으로 실제 세계를 탐색할 수 있는 기능을 부여할 수 있습니다. 이렇게 하면 홀로그램 문자를 사용자 및 친구와 동일한 자연적이고 친숙한 동작 집합으로 제한하여 홀로그램 문자의 존재를 강화할 수 있습니다.

탐색 기능은 사용자에게도 유용할 수 있습니다. 지정된 영역에 탐색 맵이 빌드되면 해당 위치에 익숙하지 않은 새 사용자에게 홀로그램 방향을 제공하도록 공유할 수 있습니다. 이 지도는 '트래픽'이 원활하게 흐르도록 하거나 건설 현장과 같은 위험한 위치에서의 사고 방지를 위해 설계할 수 있습니다.

탐색 기능을 구현하는 데 관련된 주요 기술 과제는 탐색 가능한 표면(사람이 테이블을 탐색하지 않습니다!)을 안정적으로 감지하고 환경의 변화에 정상적으로 적응하는 것입니다(인간은 닫힌 문을 거치지 않습니다!). 메시는 가상 문자의 경로 계획 및 탐색에 사용하려면 약간의 [처리가](spatial-mapping.md#mesh-processing) 필요할 수 있습니다. 메시를 다듬고 성도를 제거하면 문자가 고정되는 것을 방지할 수 있습니다. 또한 메시를 대폭 간소화하여 문자의 경로 계획 및 탐색 계산 속도를 단축할 수도 있습니다. 이러한 과제는 비디오 게임 기술 개발에서 많은 관심을 받고 있으며, 이러한 주제에 대한 다양한 연구 자료를 제공합니다.

Unity의 기본 제공 NavMesh 기능은 공간 매핑 표면과 함께 사용할 수 없습니다. 이는 애플리케이션이 시작될 때까지 공간 매핑 표면을 알 수 없지만 NavMesh 데이터 파일은 원본 자산에서 미리 생성해야 하기 때문입니다. 또한 공간 매핑 시스템은 사용자의 현재 위치에서 [멀리 떨어진 표면에 대한 정보를](spatial-mapping.md#the-environment-scanning-experience) 제공하지 않습니다. 따라서 애플리케이션이 큰 영역의 맵을 빌드하는 경우 표면 자체를 '기억'해야 합니다.

### <a name="visualization"></a>시각화

대부분의 경우 공간 표면이 보이지 않는 것이 적합합니다. 시각적 혼란을 최소화하고 실제 세계 자체에 대해 말할 수 있도록 합니다. 그러나 실제 개체가 표시되더라도 공간 매핑 표면을 직접 시각화하는 것이 유용한 경우도 있습니다.

예를 들어 사용자가 홀로그램을 표면에 배치하려고 할 때(예를 들어 홀로그램 캐비닛을 벽 위에 배치) 그림자를 표면에 캐스팅하여 홀로그램을 '접지'하는 것이 유용할 수 있습니다. 이렇게 하면 사용자에게 홀로그램과 표면 간의 정확한 물리적 근접성을 훨씬 더 명확하게 이해할 수 있습니다. 이는 사용자가 커밋하기 전에 시각적으로 변경 '미리 보기'를 하는 보다 일반적인 사례의 예이기도 합니다.

애플리케이션은 표면을 시각화하여 환경에 대한 이해를 사용자와 공유할 수 있습니다. 예를 들어 홀로그램 보드 게임에서는 '테이블'로 식별된 가로 표면을 시각화하여 사용자가 상호 작용할 위치를 알 수 있습니다.

표면 시각화는 보기에서 숨겨진 주변 공간을 사용자에게 표시하는 유용한 방법일 수 있습니다. 이렇게 하면 사용자가 자신의 식당(및 포함된 모든 홀로그램)에 액세스할 수 있는 방법을 제공할 수 있습니다.

공간 매핑에서 제공하는 표면 메시는 특별히 '정리'되지 않을 수 있습니다. 적절하게 시각화하는 것이 중요합니다. 기존 조명 계산은 시각적으로 방해가 되는 방식으로 표면 표준의 오류를 강조 표시할 수 있지만, 표면에 프로젝션된 '클린' 질감은 더 단정한 모양을 제공하는 데 도움이 될 수 있습니다. 표면이 렌더링되기 전에 [메시 처리를](spatial-mapping.md#mesh-processing) 수행하여 메시 속성을 향상시킬 수도 있습니다.

> [!NOTE]
> HoloLens 2 배치, 폐색, 물리학 및 탐색의 구현을 간소화하도록 설계된 구조화되고 높은 수준의 환경 표현을 Mixed Reality 개발자에게 제공하는 새로운 [Scene Understanding 런타임](scene-understanding.md)을 구현합니다.

## <a name="using-the-surface-observer"></a>Surface Observer 사용

공간 매핑의 시작점은 표면 관찰자입니다. 프로그램 흐름은 다음과 같습니다.
* 표면 관찰자 개체 만들기
   * 하나 이상의 공간 볼륨을 제공하여 애플리케이션이 공간 매핑 데이터를 수신하려는 관심 영역을 정의합니다. 공간 볼륨은 구 또는 상자와 같은 공간 영역을 정의하는 모양일 뿐입니다.
   * 전 세계에서 잠긴 공간 좌표계와 함께 공간 볼륨을 사용하여 실제 세계의 고정 영역을 식별합니다.
   * 각 프레임을 본문 잠금 공간 좌표계로 업데이트한 공간 볼륨을 사용하여 사용자와 함께 이동(회전하지는 않지만 회전하지 않는) 공간 영역을 식별합니다.
   * 이러한 공간 볼륨은 나중에 애플리케이션 또는 사용자의 상태가 변경될 때 변경될 수 있습니다.
* 폴링 또는 알림을 사용하여 공간 표면에 대한 정보 검색
   * 언제든지 공간 표면 상태에 대한 표면 관찰자를 '폴링'할 수 있습니다. 대신, 공간 표면이 변경될 때 애플리케이션에 알리는 표면 관찰자의 '표면 변경' 이벤트에 등록할 수 있습니다.
   * 뷰 frustum 또는 본문이 잠긴 볼륨과 같은 동적 공간 볼륨의 경우 애플리케이션은 관심 영역을 설정한 다음 현재 공간 표면 집합을 획득하여 각 프레임의 변경 내용을 폴링해야 합니다.
   * 단일 공간을 포함하는 세계 잠금 큐브와 같은 정적 볼륨의 경우 애플리케이션은 해당 볼륨 내의 공간 표면이 변경될 수 있을 때 알림을 받을 'surfaces changed' 이벤트에 등록할 수 있습니다.
* 프로세스 표면 변경 내용
   * 제공된 공간 표면 집합을 반복합니다.
   * 추가, 변경 또는 제거된 공간 표면을 분류합니다.
   * 추가되거나 변경된 각 공간 표면의 경우 적절한 경우 원하는 세부 수준에서 표면의 현재 상태를 나타내는 업데이트된 메시를 수신하도록 비동기 요청을 제출합니다.
* 비동기 메시 요청을 처리합니다(자세한 내용은 다음 섹션에 설명).

## <a name="mesh-caching"></a>메시 캐싱

공간 표면은 조밀한 삼각형 메시로 표시됩니다. 이러한 메시를 저장, 렌더링 및 처리하면 상당한 계산 및 스토리지 리소스를 사용할 수 있습니다. 따라서 각 애플리케이션은 메시 처리 및 스토리지에 사용되는 리소스를 최소화하기 위해 필요에 맞게 메시 캐싱 체계를 채택해야 합니다. 이 체계는 유지할 메시와 삭제할 메시 및 각 공간 표면의 메시를 업데이트할 시기를 결정해야 합니다.

이에 대해 설명한 많은 고려 사항은 애플리케이션이 메시 캐싱에 어떻게 접근해야 하는지 직접 알려줍니다. 사용자가 환경을 통해 이동하는 방식, 필요한 표면, 다른 표면이 관찰되는 시기 및 환경의 변경 내용을 캡처해야 하는 경우를 고려해야 합니다.

표면 관찰자가 제공하는 'surfaces changed' 이벤트를 해석할 때 기본 메시 캐싱 논리는 다음과 같습니다.
* 애플리케이션에 이전에 보지 못한 공간 표면 ID가 표시되는 경우 이를 새 공간 표면으로 처리해야 합니다.
* 애플리케이션에 알려진 ID가 있지만 새 업데이트 시간이 있는 공간 표면이 표시되는 경우 이를 업데이트된 공간 표면으로 처리해야 합니다.
* 애플리케이션에서 알려진 ID가 있는 공간 표면을 더 이상 볼 수 없는 경우 이를 제거된 공간 표면으로 처리해야 합니다.

다음을 선택하는 것은 각 애플리케이션에 달려 있습니다.
* 새 공간 표면의 경우 메시를 요청해야 합니까?
   * 일반적으로 사용자에게 유용한 새 정보를 제공할 수 있는 새 공간 표면의 경우 메시를 즉시 요청해야 합니다.
   * 그러나 사용자 근처와 앞에 있는 새 공간 표면에는 우선 순위가 지정되어야 하며 해당 메시를 먼저 요청해야 합니다.
   * 새 메시가 필요하지 않은 경우(예: 애플리케이션이 환경의 모델을 영구적으로 또는 일시적으로 '고정'하는 경우) 요청하면 안 됩니다.
* 업데이트된 공간 표면의 경우 메시를 요청해야 합니까?
   * 사용자 근처의 업데이트된 공간 표면과 사용자 앞에 우선 순위가 지정되어야 하며 해당 메시를 먼저 요청해야 합니다.
   * 특히 검색 환경 중에 업데이트된 표면보다 새 표면에 높은 우선 순위를 부여하는 것이 적절할 수 있습니다.
   * 처리 비용을 제한하기 위해 애플리케이션은 공간 표면으로 업데이트를 처리하는 속도를 제한하려고 할 수 있습니다.
   * 예를 들어 표면 범위가 작은 경우처럼 공간 표면의 변경 내용이 사소하다고 유추할 수 있습니다. 이 경우 업데이트가 충분히 중요하지 않을 수 있습니다.
   * 사용자의 현재 관심 영역 외부 공간 표면에 대한 업데이트는 완전히 무시될 수 있지만, 이 경우 표면 관찰자가 사용하는 공간 경계 볼륨을 수정하는 것이 더 효율적일 수 있습니다.
* 제거된 공간 표면의 경우 메시를 삭제해야 합니까?
   * 일반적으로 홀로그램 폐색이 올바르게 유지되도록 제거된 공간 표면의 경우 메시를 즉시 삭제해야 합니다.
   * 그러나 애플리케이션에 공간 표면이 곧 다시 나타날 것이라고 생각해야 하는 이유가 있는 경우(사용자 환경의 디자인에 따라) 메시를 삭제하고 나중에 다시 만드는 것보다 공간 표면을 유지하는 것이 더 효율적일 수 있습니다.
   * 애플리케이션이 사용자 환경의 대규모 모델을 빌드하는 경우 메시를 전혀 삭제하지 않을 수 있습니다. 그러나 공간 표면이 사라지면 메시를 디스크에 스풀링하여 리소스 사용을 제한해야 합니다.
   * 공간 표면을 생성할 때 비교적 드문 일부 이벤트로 인해 유사한 위치의 새 공간 표면으로 공간 표면이 대체될 수 있지만 다른 ID로 대체될 수 있습니다. 따라서 제거된 표면을 삭제하지 않도록 선택하는 애플리케이션은 동일한 위치를 포함하는 여러 개의 겹치는 공간 표면 메시로 이어지지 않도록 주의해야 합니다.
* 다른 공간 표면의 경우 메시를 삭제해야 합니까?
   * 공간 표면이 있는 동안에도 사용자의 경험에 더 이상 유용하지 않은 경우 삭제해야 합니다. 예를 들어 애플리케이션이 출입구 반대쪽의 공간을 대체 가상 공간으로 '대체'하는 경우 해당 공간의 공간 표면은 더 이상 중요하지 않습니다.

다음은 공간 및 임시 하이스터를 사용하는 메시 캐싱 전략의 예입니다.
* 주변을 둘러보고 둘러보는 동안 사용자의 응시를 따르는 frustum 모양의 공간 볼륨을 사용하려는 애플리케이션을 고려해 보세요.
* 사용자가 표면이나 한 단계 더 멀리 떨어져 있기 때문에 이 볼륨에서 공간 표면이 일시적으로 사라질 수 있습니다. 잠시 후 다시 살펴보거나 더 가깝게 이동하기 위해서만 해당합니다. 이 경우 이 표면의 메시를 삭제하고 다시 만드는 것은 많은 중복 처리를 나타냅니다.
* 처리되는 변경 횟수를 줄이기 위해 애플리케이션은 두 개의 공간 표면 관찰자를 사용합니다. 하나는 다른 공간 관찰자 내에 포함되어 있습니다. 더 큰 볼륨은 구형이며 사용자 'lazily'를 따릅니다. 중심이 사용자의 2.0m 이내인지 확인하는 데 필요한 경우에만 이동합니다.
* 새 공간 표면 메시와 업데이트된 공간 표면 메시는 항상 작은 내부 표면 관찰자에서 처리되지만 메시는 더 큰 외부 표면 관찰자에서 사라질 때까지 캐시됩니다. 이를 통해 애플리케이션은 로컬 사용자 이동으로 인해 많은 중복 변경 내용을 처리하지 않도록 할 수 있습니다.
* 추적 손실로 인해 공간 표면이 일시적으로 사라질 수도 있으므로 애플리케이션은 손실 추적 중에 제거된 공간 표면 삭제도 지연합니다.
* 일반적으로 애플리케이션은 업데이트 처리 감소와 메모리 사용 증가 간의 절충을 평가하여 이상적인 캐싱 전략을 결정해야 합니다.

## <a name="rendering"></a>렌더링

공간 매핑 메시가 렌더링에 사용되는 세 가지 기본 방법이 있습니다.
* 표면 시각화의 경우
   * 공간 표면을 직접 시각화하는 것이 유용한 경우가 많습니다. 예를 들어 개체에서 공간 서피스로 ' shadows '를 캐스팅 하면 표면에 holograms 배치 하는 동안 사용자에 게 유용한 시각적 피드백을 제공할 수 있습니다.
   * 공간 메시는 3D 음악가에서 만들 수 있는 메시의 종류와는 다르다는 점입니다. 삼각형 토폴로지는 사람이 만든 토폴로지에서는 ' 정리 ' 되지 않으며 메시는 [다양 한 오류를 발생](spatial-mapping.md#what-influences-spatial-mapping-quality)시킬 수 있습니다.
   * 보기 편 visual 미적을 만들려면 몇 가지 [메시 처리](spatial-mapping.md#mesh-processing)(예: 구멍 또는 부드러운 표면 법선 채우기)를 수행 하는 것이 좋습니다. 메시 토폴로지 및 법선을 직접 시각화 하는 대신 셰이더를 사용 하 여 삽화에서 디자인 한 질감을 망상에 프로젝션 할 수도 있습니다.
* 실제 세계 표면 뒤의 occluding holograms
   * 공간 표면은 깊이 전용 패스에서 렌더링 될 수 있으며이는 [깊이 버퍼](/windows/win32/direct3d9/depth-buffers) 에만 영향을 주며 색 렌더링 대상에는 영향을 주지 않습니다.
   * 이렇게 하면 prime는 깊이 버퍼를 려 공간 표면 뒤에 holograms 렌더링 합니다. Holograms의 정확한 폐색은 실제로 사용자의 실제 공간 내에 존재 하는 의미를 향상 시킵니다.
   * 깊이 전용 렌더링을 사용 하려면 모든 색 렌더링 대상에 대해 blend 상태를 업데이트 하 여 [RenderTargetWriteMask](/windows/win32/api/d3d11_1/ns-d3d11_1-d3d11_render_target_blend_desc1) 을 0으로 설정 합니다.
* 실제 표면에의 한 holograms 폐색의 모양 수정
   * 일반적으로 렌더링 된 기 하 도형은 폐색 때 숨겨집니다. 이렇게 하려면 [깊이 스텐실 상태](/windows/win32/api/d3d11/ns-d3d11-d3d11_depth_stencil_desc) 에서 깊이 함수를 "작거나 같음"으로 설정 합니다. 이렇게 하면 이전에 렌더링 된 모든 기 하 도형 보다 카메라에 **가까이** 있는 경우에만 기 하 도형을 볼 수 있습니다.
   * 그러나 폐색 경우에도 특정 기 하 도형을 표시 하 고 사용자에 게 시각적 피드백을 제공 하는 방법으로 폐색 때 모양을 수정 하는 것이 유용할 수 있습니다. 예를 들어 응용 프로그램에서 사용자에 게 개체의 위치를 표시 하는 동시에 실제 화면 뒤에 있는 것 처럼 명확 하 게 표시할 수 있습니다.
   * 이렇게 하려면 원하는 ' 폐색 ' 모양을 만드는 다른 셰이더를 사용 하 여 기 하 도형을 두 번째로 렌더링 합니다. 기 하 도형을 두 번째로 렌더링 하기 전에 [깊이 스텐실 상태](/windows/win32/api/d3d11/ns-d3d11-d3d11_depth_stencil_desc)를 두 번 변경 해야 합니다. 먼저, 이전에 렌더링 된 모든 기 하 도형 보다 카메라에서 **추가** 된 경우에만 기 하 도형을 볼 수 있도록 깊이 함수를 "크거나 같음"으로 설정 합니다. 두 번째로, 깊이 버퍼가 수정 되지 않도록 DepthWriteMask를 0으로 설정 합니다. 깊이 버퍼는 카메라와 **가장 가까운** 기 하 도형의 깊이를 계속 나타냅니다.

공간 매핑 메시를 렌더링할 때 [성능은](../develop/platform-capabilities-and-apis/understanding-performance-for-mixed-reality.md) 중요 한 문제입니다. 다음은 공간 매핑 메시 렌더링과 관련 된 몇 가지 렌더링 성능 기술입니다.
* 삼각형 밀도 조정
   * 표면 관찰자 로부터 공간 표면 메시를 요청 하는 경우 요구 사항에 충분 한 삼각형 메시의 가장 낮은 밀도를 요청 합니다.
   * 사용자의 표면 거리 및 사용자 환경에 대 한 관련성에 따라 표면의 표면에서 삼각형 밀도를 변경 하는 것이 적합할 수 있습니다.
   * 삼각형 수를 줄이면 픽셀 처리 비용에 영향을 주지 않지만 GPU에서 메모리 사용량 및 꼭 짓 점 처리 비용이 줄어듭니다.
* 고르기 사용
   * 두 번째 고르기는 현재 표시의 외부에 있기 때문에 볼 수 없는 그리기 개체를 건너뜁니다. 그러면 CPU와 GPU 처리 비용이 줄어듭니다.
   * 고르기는 메시 마다 수행 되 고 공간 표면은 클 수 있으므로 공간 표면이 클 수 있습니다. 각 공간 표면 메시를 작은 청크로 나누면 더 효율적인 고르기 (이 경우에는 더 적은 수의 스크린 된 삼각형이 렌더링 됨)가 생성 될 수 있습니다. 그러나 다음과 같은 단점이 있습니다. 메시가 많을 수록 더 많은 그리기 호출을 수행 해야 하므로 CPU 비용이 늘어날 수 있습니다. 극단적인 경우에는 대/소문자 고르기 계산 자체에서 CPU 비용이 측정 될 수도 있습니다.
* 렌더링 순서 조정
   * 공간 표면은이를 둘러싼 사용자의 전체 환경을 나타내므로 공간 표면은 클 수 있습니다. GPU의 픽셀 처리 비용은 특히 표시 되는 기 하 도형 (공간 서피스와 기타 holograms 모두 포함)의 계층이 둘 이상 있는 경우에 매우 높을 수 있습니다. 이 경우 사용자에 게 가장 가까운 계층은 모든 계층을 occluding 하 게 되므로 더 멀리 떨어져 있는 계층을 렌더링 하는 데 걸린 GPU 시간은 낭비 됩니다.
   * GPU에서 이러한 중복 작업을 줄이기 위해 불투명 표면을 앞에서 뒤로 순서로 렌더링 하는 데 도움이 됩니다. ' 불투명 '은 [깊이 스텐실 상태](/windows/win32/api/d3d11/ns-d3d11-d3d11_depth_stencil_desc)에서 DepthWriteMask가 1로 설정 된 표면을 의미 합니다. 가장 가까운 서피스가 렌더링 되 면 GPU의 픽셀 프로세서에서 더 멀리 떨어져 있는 표면을 효율적으로 건너뛰도록 깊이 버퍼를 소수 대로 만듭니다.

## <a name="mesh-processing"></a>메시 처리

응용 프로그램은 요구 사항에 맞게 공간 노출 메시에서 [다양 한 작업](spatial-mapping.md#mesh-processing) 을 수행 하려고 할 수 있습니다. 각 공간 표면 메시와 함께 제공 되는 인덱스 및 꼭 짓 점 데이터는 모든 최신 렌더링 Api에서 삼각형 메시를 렌더링 하는 데 사용 되는 [꼭 짓 점 및 인덱스 버퍼](/windows/win32/direct3d9/rendering-from-vertex-and-index-buffers) 와 동일한 익숙한 레이아웃을 사용 합니다. 그러나 기억해 야 할 한 가지 중요 한 사실은 공간 매핑 삼각형에 **시계 반대 방향 굴곡 순서가** 있다는 것입니다. 각 삼각형은 메시의 인덱스 버퍼에서 3 개의 꼭 짓 점 인덱스로 표시 되 고, 이러한 인덱스는 삼각형이 **front** 에서 표시 되는 경우 **시계 방향** 으로 삼각형의 꼭 짓 점을 식별 합니다. 공간 표면 망상의 전면 (또는 외부)은 실제 세계 표면의 정면 (표시)와 일치 하는 것으로 간주 됩니다.

Surface 관찰자가 제공 하는 coarsest 삼각형 밀도가 아직 불충분 않은 경우 응용 프로그램은 메시 단순화만 수행 해야 합니다 .이 작업은 계산 비용이 많이 들고 런타임에 의해 제공 되는 다양 한 세부 정보 수준을 생성 하는 데 이미 수행 됩니다.

각 표면 관찰자는 연결 되지 않은 여러 공간 표면을 제공할 수 있으므로 일부 응용 프로그램은 이러한 공간 노출 영역 메시를 서로 클리핑 한 다음 함께 zipper 수 있습니다. 일반적으로 주변 공간 표면 메시가 약간 겹치면 일반적으로 클리핑 단계가 필요 합니다.

## <a name="raycasting-and-collision"></a>Raycasting 및 충돌

물리 API (예: [Havok](https://www.havok.com/))가 공간 표면의 raycasting 및 충돌 기능을 제공 하는 응용 프로그램을 제공 하기 위해 응용 프로그램은 공간 노출 영역 메시를 물리학 API에 제공 해야 합니다. 물리학에 사용 되는 메시에는 종종 다음과 같은 속성이 있습니다.
* 적은 수의 삼각형만 포함 합니다. 물리 연산은 렌더링 작업 보다 계산 집약적입니다.
* ' 아주 좁게 ' 됩니다. Solid로 설계 된 표면에는 작은 구멍이 있어서는 안 됩니다. 표시 될 수 있을 정도로 작은 구멍이 있어도 문제가 발생할 수 있습니다.
* 이러한 코드는 볼록 hulls로 변환 됩니다. 볼록 hulls는 약간의 다각형이 있으며 구멍이 없는 것 이며 원시 삼각형 메시 보다 처리 하기에 훨씬 더 많은 계산을 제공 합니다.

공간 표면에 대해 raycasts를 수행 하는 경우 이러한 표면은 종종 복잡 하 고 복잡 한 모양이 약간 복잡 합니다 .이는 책상과 같습니다. 즉, 단일 raycast가 화면 모양에 대 한 충분 한 정보와 근처의 빈 공간 셰이프를 제공 하기에 충분 하지 않은 경우가 많습니다. 일반적으로 작은 영역 내에서 많은 raycasts를 수행 하 고 집계 결과를 사용 하 여 화면에 대 한 보다 안정적인 이해를 유도 하는 것이 좋습니다. 예를 들어, 화면에서 홀로그램 배치를 안내 하는 평균 10 개의 raycasts를 사용 하면 단일 raycasts를 사용 하는 훨씬 더 부드럽고 ' 떨림 ' 결과를 얻을 수 있습니다.

그러나 각 raycast에는 높은 계산 비용이 있을 수 있습니다. 사용 시나리오에 따라 공간 메시 (공간 메시가 업데이트 되는 경우 수행 됨)의 계산 비용을 사용 하 여 [메시 처리](spatial-mapping.md#mesh-processing) 의 계산 비용을 계산 하 여 공간 표면의 구멍을 매끄럽게 및 제거 해야 합니다.

## <a name="the-environment-scanning-experience"></a>환경 검사 환경

공간 매핑을 사용 하는 각 응용 프로그램은 ' 스캔 환경 '을 제공 하는 것을 고려해 야 합니다. 응용 프로그램에서 응용 프로그램이 제대로 작동 하는 데 필요한 표면을 검색 하는 데 사용 하는 프로세스입니다.

![검색 예제](images/sr-mixedworld-140429-8pm-00068-1000px.png)<br>
*검색 예제*

이러한 검색 환경의 특성은 각 응용 프로그램의 요구 사항에 따라 크게 다를 수 있지만 두 가지 주요 원칙에 따라 디자인을 안내 해야 합니다.

첫째, **사용자와의 통신을 명확 하 게 하는 것이 중요** 합니다. 사용자는 항상 응용 프로그램의 요구 사항을 충족 하는지 여부를 알고 있어야 합니다. 충족 되지 않는 경우 사용자에 게 즉시 명확 하 게 표시 되어야 하 고, 적절 한 조치를 취하는 데 신속 하 게 발생 해야 합니다.

둘째, **응용 프로그램은 효율성과 안정성 간의 균형** 을 유지 하려고 합니다. **안정적** 으로 수행할 수 있는 경우 응용 프로그램은 공간 매핑 데이터를 자동으로 분석 하 여 사용자 시간을 저장 해야 합니다. 안정적으로 수행할 수 없는 경우 응용 프로그램은 사용자가 응용 프로그램에 필요한 추가 정보를 신속 하 게 제공할 수 있도록 해야 합니다.

적절 한 검색 환경을 디자인 하는 데 도움이 되도록 응용 프로그램에 적용할 수 있는 다음 가능성을 고려 합니다.

* **검색 환경 없음**
   * 응용 프로그램은 단계별 검사 환경을 사용 하지 않고 완벽 하 게 작동할 수 있습니다. 자연 스러운 사용자 이동 과정에서 관찰 되는 표면에 대해 알아봅니다.
   * 예를 들어 사용자가 holographic 스프레이 그림판을 사용 하 여 표면에 그릴 수 있도록 하는 응용 프로그램에는 현재 사용자에 게 표시 되는 표면에 대 한 정보만 필요 합니다.
   * HoloLens 사용 하 여 이미 많은 시간을 사용한 환경을 이미 사용 하 고 있는 경우에는 환경을 검사할 수 있습니다.
   * 그러나 공간 매핑에 사용 되는 카메라는 사용자 앞에 3.1 m만 표시 될 수 있으므로, 사용자가 이전 보다 더 가까운 거리에서 관찰 한 적이 없으면 공간 매핑에서 더 멀리 떨어져 있는 표면을 인식 하지 못합니다.
   * 사용자가 검색 된 표면을 이해 하는 경우 응용 프로그램은 이러한 효과에 대 한 시각적 피드백을 제공 해야 합니다. 예를 들어 스캔 된 표면에 가상 그림자를 캐스팅 하면 사용자가 해당 화면에 holograms 하는 데 도움이 될 수 있습니다.
   * 이 경우 공간 표면 관찰자의 경계 볼륨은 사용자를 따르기 위해 각 프레임을 본문 잠김 [공간 좌표계](coordinate-systems.md)로 업데이트 해야 합니다.

* **적절 한 위치 찾기**
   * 응용 프로그램은 특정 요구 사항이 있는 위치에서 사용 하도록 디자인 될 수 있습니다.
   * 예를 들어 응용 프로그램은 holographic kung-fu를 안전 하 게 연습 하기 위해 사용자에 게 빈 영역을 요구할 수 있습니다.
   * 응용 프로그램은 사용자에 게 모든 특정 요구 사항을 알리고 명확한 시각적 피드백을 통해 보강 해야 합니다.
   * 이 예제에서 응용 프로그램은 필요한 빈 영역의 범위를 시각화 하 고이 영역 내에서 원치 않는 개체가 있는지 시각적으로 강조 표시 해야 합니다.
   * 이 경우 공간 표면 관찰자의 경계 볼륨은 선택한 위치에서 세계에서 잠긴 [공간 좌표계](coordinate-systems.md) 를 사용 해야 합니다.

* **적절 한 화면 구성 찾기**
   * 응용 프로그램에는 특정 화면 구성 (예: 두 개의 크고 플랫, 반대 벽)이 필요 하 여 holographic 홀을 만들 수 있습니다.
   * 이러한 경우 응용 프로그램은 공간 매핑에서 제공 되는 표면을 분석 하 여 적절 한 표면을 검색 하 고 사용자에 게 전달 해야 합니다.
   * 응용 프로그램의 surface 분석을 신뢰할 수 없는 경우 사용자에 게 대체 (fallback) 옵션이 있어야 합니다. 예를 들어 응용 프로그램이 이르는 길를 플랫 벽으로 잘못 식별 하는 경우 사용자에 게이 오류를 수정 하는 간단한 방법이 필요 합니다.

* **환경의 일부를 검색 합니다.**
   * 응용 프로그램은 사용자의 지시에 따라 환경의 일부만 캡처할 수 있습니다.
   * 예를 들어 응용 프로그램은 대화방의 일부를 검사 하 여 판매 하려는 가구에 대해 holographic 분류 된 광고를 게시할 수 있습니다.
   * 이 경우 응용 프로그램은 검색 하는 동안 사용자가 관찰 한 지역 내에서 공간 매핑 데이터를 캡처해야 합니다.

* **전체 대화방 스캔**
   * 응용 프로그램을 사용 하려면 사용자 뒤의 모든 화면을 포함 하 여 현재 대화방의 모든 화면을 검색 해야 할 수 있습니다.
   * 예를 들어 게임에서 사용자가 Gulliver의 역할을 할 수 있습니다 .이는 모든 방향에서 가장 적은 수의 Lilliputians에 대 한 공 성함입니다.
   * 이러한 경우 응용 프로그램은 현재 방에서 이미 검색 된 표면의 수를 확인 하 고, 사용자의 응시를 통해 상당한 격차를 채우도록 해야 합니다.
   * 이 프로세스의 핵심은 아직 검색 되지 않은 화면을 사용자에 게 명확 하 게 표시 하는 시각적 피드백을 제공 하는 것입니다. 예를 들어, 응용 프로그램은 [거리 기반 안개](/windows/win32/direct3d9/fog-formulas) 를 사용 하 여 공간 매핑 화면에서 다루지 않는 영역을 시각적으로 강조 표시할 수 있습니다.

* **환경에 대 한 초기 스냅숏 만들기**
   * 응용 프로그램은 초기 ' 스냅숏 '을 수행한 후 환경의 모든 변경 내용을 무시 하려고 할 수 있습니다.
   * 이는 환경의 초기 상태와 긴밀 하 게 연결 되는 사용자가 만든 데이터의 중단을 방지 하는 데 적합할 수 있습니다.
   * 이 경우 응용 프로그램은 검색이 완료 된 후 초기 상태에서 공간 매핑 데이터의 복사본을 만들어야 합니다.
   * 환경에서 holograms를 올바르게 폐색 하는 경우 응용 프로그램은 공간 매핑 데이터에 대 한 업데이트를 계속 수신 해야 합니다.
   * 공간 매핑 데이터를 지속적으로 업데이트 하 여 발생 한 모든 변경 내용을 시각화할 수 있으며, 환경의 이전 상태와 현재 상태 간의 차이를 명확 하 게 이해 하기도 합니다.

* **사용자가 시작한 환경의 스냅숏 만들기**
   * 응용 프로그램은 사용자가 지시 하는 경우 환경 변경 내용에만 응답할 수 있습니다.
   * 예를 들어 사용자는 다른 순간에 포즈를 캡처하여 friend의 여러 3D ' 동상 '을 만들 수 있습니다.

* **사용자가 환경을 변경할 수 있도록 허용**
   * 응용 프로그램은 사용자 환경에서 변경 된 내용에 대해 실시간으로 응답 하도록 디자인 될 수 있습니다.
   * 예를 들어 방식을를 그리는 사용자는 다른 쪽에서 발생 하는 holographic play에 대해 ' 장면 변경 '을 트리거할 수 있습니다.

* **공간 매핑 데이터의 오류를 방지 하기 위해 사용자에 게 안내**
   * 응용 프로그램에서 환경을 검색 하는 동안 사용자에 게 지침을 제공 하고자 할 수 있습니다.
   * 이렇게 하면 사용자가 sunlit windows 또는 미러를 사용 하는 등의 방법으로 [공간 매핑 데이터에서](spatial-mapping.md#what-influences-spatial-mapping-quality)특정 유형의 오류를 방지할 수 있습니다.

유의 해야 할 추가 정보 중 하나는 공간 매핑 데이터의 ' 범위 '에 제한이 없다는 것입니다. 공간 매핑이 큰 공간의 영구 데이터베이스를 작성 하는 동안에는 사용자가 제한 된 크기의 ' 거품형 '에서 응용 프로그램에만 데이터를 사용할 수 있도록 합니다. 긴 어느의 시작 부분에서 시작 하 여 시작 부분에서 멀리 떨어진 곳에서 시작 하는 경우 결국 공간 서피스가 다시 시작 부분에서 사라집니다. 사용 가능한 공간 매핑 데이터에서 사라진 후에 응용 프로그램에서 해당 표면을 캐싱하여이를 완화할 수 있습니다.

## <a name="mesh-processing"></a>메시 처리

이를 통해 표면에서 일반적인 오류 유형을 검색 하 고 공간 매핑 데이터를 적절 하 게 필터링, 제거 또는 수정할 수 있습니다.

공간 매핑 데이터는 실제 표면에 최대한 적합 되도록 하기 위한 것 이므로, 모든 처리를 통해 ' 참 '에서 화면을 이동 하는 위험을 적용 합니다.

다음은 유용 하 게 사용할 수 있는 여러 유형의 메시 처리에 대 한 몇 가지 예입니다.

* **구멍 채우기**
   * 어두운 재질의 작은 개체가 스캔 되지 않으면 주변 화면에 구멍이 남습니다.
   * 구멍은 폐색에 영향을 줍니다. holograms은 임의의 불투명 실제 표면에서 ' ~ ' 구멍을 볼 수 있습니다.
   * 결함은 raycasts에 영향을 줍니다. raycasts를 사용 하 여 사용자가 서피스와 상호 작용 하는 데 도움이 되는 경우 이러한 광선을 통해 구멍이 전달 되는 것이 바람직하지 않을 수 있습니다. 한 가지 완화 방법은 적절 한 크기의 영역을 포함 하는 여러 raycasts 번들을 사용 하는 것입니다. 이를 통해 ' 이상 값 ' 결과를 필터링 할 수 있습니다 .이 경우 한 가지 raycast가 작은 구멍을 통과 하더라도 집계 결과는 계속 유효 합니다. 그러나이 방법은 계산 비용으로 제공 됩니다.
   * 구멍은 물리학 충돌에 영향을 줍니다. 물리학 시뮬레이션으로 제어 되는 개체는 바닥의 구멍을 통해 삭제 되 고 손실 될 수 있습니다.
   * 표면 메시에서 이러한 구멍을 알고리즘 방식으로 채울 수 있습니다. 그러나 windows 및 doorways 같은 ' 실제 구멍 '이 채워지지 않도록 알고리즘을 조정 해야 합니다. ' 실제 구멍 '을 ' 허수 구멍 '과 안정적으로 구분 하는 것이 어려울 수 있으므로 ' 크기 ' 및 ' 경계 모양 '과 같은 다른 추론을 사용해 보아야 합니다.

* **Hallucination 제거**
   * 반사, 밝은 조명 및 이동 개체는 약간의 느린 ' hallucinations ' 부동을 중간에 벗어날 수 있습니다.
   * Hallucinations에 영향을 주는 폐색: Hallucinations는 및 occluding 다른 holograms의 앞으로 이동 하는 짙은 모양으로 표시 될 수 있습니다.
   * Hallucinations는 raycasts에 영향을 줍니다. raycasts를 사용 하 여 사용자가 서피스와 상호 작용할 수 있도록 하는 경우 이러한 광선은 그 뒤의 표면 대신 hallucination에 도달할 수 있습니다. 구멍에서와 마찬가지로 한 가지 완화는 단일 raycasts 대신 많은 raycasts를 사용 하는 것 이지만, 다시이 경우 계산 비용이 발생 합니다.
   * Hallucinations는 물리학 충돌에 영향을 줍니다. 물리학 시뮬레이션에 의해 제어 되는 개체는 hallucination에 대해 중지 될 수 있으며, 빈 영역을 통해 이동할 수 없습니다.
   * Surface 메시에서 이러한 hallucinations를 필터링 할 수 있습니다. 그러나 구멍과 마찬가지로 램프와 도어 핸들 등의 실제 작은 개체가 제거 되지 않도록 알고리즘을 조정 해야 합니다.

* **다듬기**
   * 공간 매핑은 실제 요소와 비교 하 여 황삭 또는 ' 잡음 '으로 표시 되는 표면을 반환할 수 있습니다.
   * 다듬기는 물리학 충돌에 영향을 줍니다. 바닥이 거칠게 되 면 실제로 시뮬레이션 된 golf 공이 직선으로이를 통해 원활 하 게 롤오버 되지 않을 수 있습니다.
   * 다듬기는 렌더링에 영향을 줍니다. 표면이 직접 시각화 되는 경우 대략적인 표면 법선은 해당 모양에 영향을 줄 수 있으며 ' 정리 ' 모양을 방해 합니다. 화면을 렌더링 하는 데 사용 되는 셰이더에 적절 한 조명 및 질감을 사용 하 여이를 완화할 수 있습니다.
   * 표면 메시에서 황삭을 매끄럽게 수행할 수 있습니다. 그러나이로 인해 해당 하는 실제 화면에서 화면을 벗어날 수 있습니다. 근접 한 일치를 유지 하는 것은 정확한 홀로그램 폐색을 생성 하 고 사용자가 holographic 서피스와 정확 하 고 예측 가능한 상호 작용을 달성할 수 있도록 하는 데 중요 합니다.
   * 코스메틱 변경만 필요한 경우 꼭 짓 점 위치를 변경 하지 않고 꼭 짓 점 법선을 사용 하는 것이 충분할 수 있습니다.

* **평면 찾기**
   * 응용 프로그램이 공간 매핑에서 제공 된 표면에서 수행 하려는 많은 형태의 분석이 있습니다.
   * 간단한 한 가지 예는 ' 평면 찾기 '입니다. 주로 표면의 평면 영역 경계를 식별 합니다.
   * 평면 지역은 응용 프로그램에서 holographic 콘텐츠를 자동으로 배치할 수 있는 holographic 작업 영역으로 사용할 수 있습니다.
   * 평면 지역은 사용자 인터페이스를 제한할 수 있으므로 사용자가 요구 사항에 가장 적합 한 서피스와 상호 작용 하도록 안내 합니다.
   * 평면 영역을 실제 세계와 같이 사용 하 여 LCD 화면, 테이블 또는 화이트 보드와 같은 기능 개체에 대 한 holographic 수 있습니다.
   * 평면 지역은 재생 영역을 정의 하 여 비디오 게임 수준의 기반을 형성할 수 있습니다.
   * 평면 지역은 실제 사람들이 살펴볼 가능성이 높은 영역을 식별 하 여 가상 에이전트가 실제 세계를 탐색 하는 데 도움이 될 수 있습니다.

## <a name="prototyping-and-debugging"></a>프로토타입 및 디버깅

### <a name="useful-tools"></a>유용한 도구

* [HoloLens 에뮬레이터](../develop/platform-capabilities-and-apis/using-the-hololens-emulator.md) 를 사용 하 여 물리적 HoloLens에 액세스할 필요 없이 공간 매핑을 사용 하 여 응용 프로그램을 개발할 수 있습니다. 이 기능을 사용 하면 응용 프로그램에서 일반적으로 사용 하는 HoloLens 동작, 공간 좌표계 및 공간 매핑 메시를 비롯 한 모든 데이터를 사용 하 여 실제 환경에서 HoloLens 라이브 세션을 시뮬레이션할 수 있습니다. 이는 문제를 디버깅 하 고 코드에 대 한 변경 사항을 평가 하는 데 유용할 수 있는 안정적이 고 반복 가능한 입력을 제공 하는 데 사용할 수 있습니다.
* 시나리오를 재현 하려면 라이브 HoloLens에서 네트워크를 통해 공간 매핑 데이터를 캡처한 다음 디스크에 저장 하 고 나중에 디버깅 세션에서 다시 사용 합니다.
* [Windows 장치 포털 3d 보기](../develop/platform-capabilities-and-apis/using-the-windows-device-portal.md#3d-view) 에서는 공간 매핑 시스템을 통해 현재 사용할 수 있는 모든 공간 표면을 볼 수 있습니다. 이는 응용 프로그램 내부의 공간 표면의 비교를 기반으로 합니다. 예를 들어 공간 서피스가 누락 되었거나 잘못 된 장소에 표시 되는지 쉽게 알 수 있습니다.

### <a name="general-prototyping-guidance"></a>일반 프로토타입 지침

* 공간 매핑 데이터의 [오류](spatial-mapping.md#what-influences-spatial-mapping-quality) 는 사용자의 환경에 크게 영향을 줄 수 있으므로 다양 한 환경에서 응용 프로그램을 테스트 하는 것이 좋습니다.
* 동일한 위치 (예: 책상)에서 항상 테스트를 시작 하는 습관을 제공 하지 마세요. 다양 한 위치, 도형, 크기 및 재질의 여러 표면에서 테스트 해야 합니다.
* 이와 유사 하 게, 가상 또는 기록 된 데이터는 디버깅에 유용할 수 있지만, 동일한 테스트 사례에는 의존 하지 않습니다. 이렇게 하면 더 다양 한 테스트에서 이전에 발견 한 중요 한 문제 찾기가 지연 될 수 있습니다.
* 실제 사용 하는 것과 동일한 방식으로 HoloLens 또는 응용 프로그램을 사용 하지 않을 수 있기 때문에 실제 사용자를 사용 하 여 테스트를 수행 하는 것이 좋습니다. 실제로 사용자의 행동, 기술 자료 및 가정이 어떻게 될 수 있는지를 예상할 수 있습니다.

## <a name="troubleshooting"></a>문제 해결

* 표면 메시를 올바르게 지향 하려면 각 GameObject가 활성 상태 여야 메시를 생성 하기 위해 SurfaceObserver에 전송 해야 합니다. 그렇지 않으면 메시는 공간에 표시 되지만 이상한 각도로 회전 됩니다.
* SurfaceObserver와 통신 하는 스크립트를 실행 하는 GameObject를 원본으로 설정 해야 합니다. 그렇지 않으면 사용자가 만들고 SurfaceObserver에 전송 하 여 메시를 생성 하는 모든 Gameobject 부모 게임 개체의 오프셋과 동일한 오프셋을 갖게 됩니다. 이렇게 하면 메시를 몇 미터 떨어진 상태로 표시 하 여 진행 상황을 디버그 하기가 어려울 수 있습니다.

## <a name="see-also"></a>추가 정보

* [좌표계](coordinate-systems.md)
* [DirectX의 공간 매핑](../develop/native/spatial-mapping-in-directx.md)
* [Unity의 공간 매핑](../develop/unity/spatial-mapping-in-unity.md)
* [장면 이해](scene-understanding.md)
* [실내 스캔 시각화](room-scan-visualization.md)
* [공간 음향 디자인](spatial-sound-design.md)
* [사례 연구 - 현실의 구멍 속 살펴보기](../out-of-scope/case-study-looking-through-holes-in-your-reality.md)