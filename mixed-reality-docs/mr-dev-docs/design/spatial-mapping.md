---
title: 공간 매핑
description: 공간 매핑은 HoloLens 주위 환경의 실제 표면에 대 한 자세한 표현을 제공 합니다.
author: mattzmsft
ms.author: mazeller
ms.date: 03/21/2018
ms.topic: article
keywords: 공간 매핑, HoloLens, 혼합 현실, 표면 재구성, 메시, 혼합 현실 헤드셋, windows mixed reality 헤드셋, 가상 현실 헤드셋, HoloLens, MRTK, 혼합 현실 도구 키트, 장면 이해, 세계 메시, 폐색, 물리, 탐색, 표면 관찰자, 렌더링, 메시 처리
ms.openlocfilehash: 1c41706abc0a393e8530b38be83fed49ed3e20a6
ms.sourcegitcommit: d3a3b4f13b3728cfdd4d43035c806c0791d3f2fe
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 01/20/2021
ms.locfileid: "98583276"
---
# <a name="spatial-mapping"></a><span data-ttu-id="20f2b-104">공간 매핑</span><span class="sxs-lookup"><span data-stu-id="20f2b-104">Spatial mapping</span></span>

<span data-ttu-id="20f2b-105">공간 매핑은 HoloLens를 중심으로 환경의 실제 표면에 대 한 세부 정보를 제공 하 여 개발자가 설득 혼합 현실 환경을 만들 수 있도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-105">Spatial mapping provides a detailed representation of real-world surfaces in the environment around the HoloLens, allowing developers to create a convincing mixed reality experience.</span></span> <span data-ttu-id="20f2b-106">응용 프로그램은 실제 세계를 가상 세계와 병합 하 여 holograms를 실제 상태로 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-106">By merging the real world with the virtual world, an application can make holograms seem real.</span></span> <span data-ttu-id="20f2b-107">친숙 한 실제 동작 및 상호 작용을 제공 하 여 응용 프로그램을 보다 자연스럽 게 사용자 기대에 맞출 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-107">Applications can also more naturally align with user expectations by providing familiar real-world behaviors and interactions.</span></span>

<br>

>[!VIDEO https://www.youtube.com/embed/zff2aQ1RaVo]

## <a name="device-supports"></a><span data-ttu-id="20f2b-108">장치 지원</span><span class="sxs-lookup"><span data-stu-id="20f2b-108">Device supports</span></span>

<table>
    <colgroup>
    <col width="25%" />
    <col width="25%" />
    <col width="25%" />
    <col width="25%" />
    </colgroup>
    <tr>
        <td><span data-ttu-id="20f2b-109"><strong>기능</strong></span><span class="sxs-lookup"><span data-stu-id="20f2b-109"><strong>Feature</strong></span></span></td>
        <td><span data-ttu-id="20f2b-110"><a href="/hololens/hololens1-hardware"><strong>HoloLens(1세대)</strong></a></span><span class="sxs-lookup"><span data-stu-id="20f2b-110"><a href="/hololens/hololens1-hardware"><strong>HoloLens (1st gen)</strong></a></span></span></td>
        <td><span data-ttu-id="20f2b-111"><a href="https://docs.microsoft.com/hololens/hololens2-hardware"><strong>HoloLens 2</strong></span><span class="sxs-lookup"><span data-stu-id="20f2b-111"><a href="https://docs.microsoft.com/hololens/hololens2-hardware"><strong>HoloLens 2</strong></span></span></td>
        <td><span data-ttu-id="20f2b-112"><a href="../discover/immersive-headset-hardware-details.md"><strong>몰입형 헤드셋</strong></a></span><span class="sxs-lookup"><span data-stu-id="20f2b-112"><a href="../discover/immersive-headset-hardware-details.md"><strong>Immersive headsets</strong></a></span></span></td>
    </tr>
     <tr>
        <td><span data-ttu-id="20f2b-113">공간 매핑</span><span class="sxs-lookup"><span data-stu-id="20f2b-113">Spatial mapping</span></span></td>
        <td><span data-ttu-id="20f2b-114">✔️</span><span class="sxs-lookup"><span data-stu-id="20f2b-114">✔️</span></span></td>
        <td><span data-ttu-id="20f2b-115">✔️</span><span class="sxs-lookup"><span data-stu-id="20f2b-115">✔️</span></span></td>
        <td>❌</td>
    </tr>
</table>


## <a name="why-is-spatial-mapping-important"></a><span data-ttu-id="20f2b-116">공간 매핑이 중요 한 이유는 무엇 인가요?</span><span class="sxs-lookup"><span data-stu-id="20f2b-116">Why is spatial mapping important?</span></span>

<span data-ttu-id="20f2b-117">공간 매핑을 사용하면 개체를 실제 표면에 배치할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-117">Spatial mapping makes it possible to place objects on real surfaces.</span></span> <span data-ttu-id="20f2b-118">이렇게 하면 사용자의 세계에서 개체를 고정 하 고 실제 깊이 있는 큐를 활용할 수 있습니다. 다른 holograms 및 실제 개체를 기반으로 하는 holograms를 Occluding 사용자는 이러한 holograms 실제로 공간에 있음을 사용자에 게 유도할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-118">This helps anchor objects in the user's world and takes advantage of real world depth cues. Occluding your holograms based on other holograms and real world objects helps convince the user that these holograms are actually in their space.</span></span> <span data-ttu-id="20f2b-119">공간에 부동이 Holograms 사용자로 이동 하는 것은 진정한 느낌이 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-119">Holograms floating in space or moving with the user won't feel as real.</span></span> <span data-ttu-id="20f2b-120">가능 하면 편안 하 게 항목을 입력 합니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-120">When possible, place items for comfort.</span></span>

<span data-ttu-id="20f2b-121">Holograms를 배치 하거나 이동할 때 화면을 시각화 합니다 (투영 된 표 사용).</span><span class="sxs-lookup"><span data-stu-id="20f2b-121">Visualize surfaces when placing or moving holograms (use a projected grid).</span></span> <span data-ttu-id="20f2b-122">이렇게 하면 사용자가 holograms를 가장 잘 찾을 수 있는 위치를 알 수 있으며, 홀로그램을 찾고 있는 지점이 매핑되지 않은 경우를 볼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-122">This helps users know where they can best place their holograms, and shows if the spot they're trying to place the hologram isn't mapped.</span></span> <span data-ttu-id="20f2b-123">사용자가 너무 많은 각도를 종료 하는 경우 사용자에 게 "항목을" 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-123">You can "billboard items" toward the user if they end up at too much of an angle.</span></span>

## <a name="conceptual-overview"></a><span data-ttu-id="20f2b-124">개념적 개요</span><span class="sxs-lookup"><span data-stu-id="20f2b-124">Conceptual overview</span></span>

<span data-ttu-id="20f2b-125">![대화방을 덮고 있는 메시 서피스](images/SurfaceReconstruction.jpg)</span><span class="sxs-lookup"><span data-stu-id="20f2b-125">![Mesh surfaces covering a room](images/SurfaceReconstruction.jpg)</span></span><br>
<span data-ttu-id="20f2b-126">*공간을 다루는 공간 매핑 메시의 예*</span><span class="sxs-lookup"><span data-stu-id="20f2b-126">*An example of a spatial mapping mesh covering a room*</span></span>

<span data-ttu-id="20f2b-127">공간 매핑에 사용 되는 두 가지 기본 개체 형식은 ' 공간 표면 관찰자 ' 및 ' 공간 표면 '입니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-127">The two primary object types used for spatial mapping are the 'Spatial Surface Observer' and the 'Spatial Surface'.</span></span>

<span data-ttu-id="20f2b-128">응용 프로그램은 공간 표면 관찰자에 하나 이상의 경계 볼륨을 제공 하 여 응용 프로그램이 공간 매핑 데이터를 받으려는 공간 영역을 정의 합니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-128">The application provides the Spatial Surface Observer with one or more bounding volumes, to define the regions of space in which the application wishes to receive spatial mapping data.</span></span> <span data-ttu-id="20f2b-129">이러한 각 볼륨에 대해 공간 매핑은 공간 표면의 집합을 응용 프로그램에 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-129">For each of these volumes, spatial mapping will provide the application with a set of Spatial Surfaces.</span></span>

<span data-ttu-id="20f2b-130">이러한 볼륨은 실제 세계를 기반으로 하는 고정 된 위치에 고정 되어 있거나 HoloLens에 연결 될 수 있습니다 (환경에서 이동할 때 HoloLens로 이동 되지만 회전 하지 않음).</span><span class="sxs-lookup"><span data-stu-id="20f2b-130">These volumes may be stationary (in a fixed location based on the real world) or they may be attached to the HoloLens (they move, but don't rotate, with the HoloLens as it moves through the environment).</span></span> <span data-ttu-id="20f2b-131">각 공간 표면은 세계 잠긴 [공간 좌표계](coordinate-systems.md)에 연결 된 삼각형 망으로 표시 되는 작은 공간의 실제 표면에 대해 설명 합니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-131">Each spatial surface describes real-world surfaces in a small volume of space, represented as a triangle mesh attached to a world-locked [spatial coordinate system](coordinate-systems.md).</span></span>

<span data-ttu-id="20f2b-132">HoloLens가 환경에 대 한 새 데이터를 수집 하 고 환경에 대 한 변경 사항이 발생 하면 공간 서피스가 표시 되 고 사라집니다. 변경 됩니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-132">As the HoloLens gathers new data about the environment, and as changes to the environment occur, spatial surfaces will appear, disappear, and change.</span></span>

## <a name="spatial-mapping-vs-scene-understanding-worldmesh"></a><span data-ttu-id="20f2b-133">공간 매핑과 장면 이해 WorldMesh</span><span class="sxs-lookup"><span data-stu-id="20f2b-133">Spatial Mapping vs. Scene Understanding WorldMesh</span></span>

<span data-ttu-id="20f2b-134">HoloLens 2의 경우 [장면 이해 SDK](../develop/platform-capabilities-and-apis/scene-understanding-SDK.md) (EnableWorldMesh 설정)를 사용 하 여 공간 매핑 데이터의 정적 버전을 쿼리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-134">For HoloLens 2, it's possible to query a static version of the spatial mapping data using [Scene understanding SDK](../develop/platform-capabilities-and-apis/scene-understanding-SDK.md) (EnableWorldMesh setting).</span></span> <span data-ttu-id="20f2b-135">공간 매핑 데이터에 액세스 하는 두 가지 방법의 차이점은 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-135">Here are the differences between two ways of accessing the spatial mapping data:</span></span>
* <span data-ttu-id="20f2b-136">공간 매핑 API:</span><span class="sxs-lookup"><span data-stu-id="20f2b-136">Spatial Mapping API:</span></span>
   * <span data-ttu-id="20f2b-137">제한 된 범위: 응용 프로그램에서 사용 가능한 공간 매핑 데이터는 제한 된 크기의 응용 프로그램에서 사용자 주위에 ' 거품형 '으로 캐시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-137">Limited range: the spatial mapping data available to applications in a limited size cached 'bubble' around the user.</span></span>
   * <span data-ttu-id="20f2b-138">SurfacesChanged 이벤트를 통해 변경 된 메시 영역에 대 한 짧은 대기 시간 업데이트를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-138">Provides low latency updates of changed mesh regions through SurfacesChanged events.</span></span>
   * <span data-ttu-id="20f2b-139">큐빅 미터 매개 변수만 삼각형에 의해 제어 되는 세부 정보의 변수 수준입니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-139">Variable level of details controlled by Triangles Per Cubic Meter parameter.</span></span>
* <span data-ttu-id="20f2b-140">장면 이해 SDK:</span><span class="sxs-lookup"><span data-stu-id="20f2b-140">Scene understanding SDK:</span></span>
   * <span data-ttu-id="20f2b-141">무제한 범위-쿼리 반경 내에서 검색 된 모든 공간 매핑 데이터를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-141">Unlimited range - provides all the scanned spatial mapping data within the query radius.</span></span>
   * <span data-ttu-id="20f2b-142">공간 매핑 데이터의 정적 스냅숏을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-142">Provides a static snapshot of the spatial mapping data.</span></span> <span data-ttu-id="20f2b-143">업데이트 된 공간 매핑 데이터를 가져오려면 전체 메시에 대해 새 쿼리를 실행 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-143">Getting the updated spatial mapping data requires running a new query for the whole mesh.</span></span>
   * <span data-ttu-id="20f2b-144">RequestedMeshLevelOfDetail 설정에 의해 제어 되는 일관 된 세부 수준입니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-144">Consistent level of details controlled by RequestedMeshLevelOfDetail setting.</span></span>

## <a name="what-influences-spatial-mapping-quality"></a><span data-ttu-id="20f2b-145">공간 매핑 품질에 영향을 주는 것은 무엇 인가요?</span><span class="sxs-lookup"><span data-stu-id="20f2b-145">What influences spatial mapping quality?</span></span>

<span data-ttu-id="20f2b-146">[여기](/hololens/hololens-environment-considerations)에서 자세히 설명 하는 몇 가지 요소는 이러한 오류의 빈도 및 심각도에 영향을 줄 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-146">Several factors, detailed [here](/hololens/hololens-environment-considerations), can affect the frequency and severity of these errors.</span></span>  <span data-ttu-id="20f2b-147">그러나 공간 매핑 데이터에 오류가 있는 경우에도 사용자가 목표를 달성할 수 있도록 응용 프로그램을 디자인 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-147">However, you should design your application so that the user can achieve their goals even in the presence of errors in the spatial mapping data.</span></span>

## <a name="common-usage-scenarios"></a><span data-ttu-id="20f2b-148">일반 시나리오</span><span class="sxs-lookup"><span data-stu-id="20f2b-148">Common usage scenarios</span></span>

![일반적인 공간 매핑 사용 시나리오의 그림: 배치, 폐색, 물리 및 탐색](images/sm-concepts-1000px.png)

### <a name="placement"></a><span data-ttu-id="20f2b-150">배치</span><span class="sxs-lookup"><span data-stu-id="20f2b-150">Placement</span></span>

<span data-ttu-id="20f2b-151">공간 매핑은 응용 프로그램에 사용자에 게 친숙 하 고 친숙 한 형태의 상호 작용을 제공할 수 있는 기회를 제공 합니다. 책상에 휴대폰을 배치 하는 것 보다 자연스럽 게 무엇을 할 수 있나요?</span><span class="sxs-lookup"><span data-stu-id="20f2b-151">Spatial mapping provides applications with the opportunity to present natural and familiar forms of interaction to the user; what could be more natural than placing down your phone on the desk?</span></span>

<span data-ttu-id="20f2b-152">Holograms (또는 더 일반적으로 공간 위치 선택)의 배치를 화면에 배치 하는 것은 3D (지점에서의 경우)에서 2D (point on surface)로의 자연 스러운 매핑을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-152">Constraining the placement of holograms (or more generally, any selection of spatial locations) to lie on surfaces provides a natural mapping from 3D (point in space) to 2D (point on surface).</span></span> <span data-ttu-id="20f2b-153">이를 통해 사용자가 응용 프로그램에 제공 해야 하는 정보의 양을 줄이고 사용자의 상호 작용을 보다 쉽고 정확 하 게 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-153">This reduces the amount of information the user needs to provide to the application and makes the user's interactions faster, easier, and more precise.</span></span> <span data-ttu-id="20f2b-154">' 거리가 먼 쪽 '은 다른 사람이 나 컴퓨터와 물리적으로 통신 하는 데 사용 되는 것이 아니기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-154">This is true because 'distance away' isn't something that we're used to physically communicating to other people or to computers.</span></span> <span data-ttu-id="20f2b-155">손가락을 가리키면 거리가 아니라 방향을 지정 하 게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-155">When we point with our finger, we're specifying a direction but not a distance.</span></span>

<span data-ttu-id="20f2b-156">여기서 중요 한 점은 응용 프로그램이 방향에서 거리를 유추 하는 경우 (예: 사용자의 응시 방향에 따라 가장 가까운 공간 화면을 찾기 위해 raycast를 수행 하는 경우), 사용자가 안정적으로 예측할 수 있는 결과를 생성 해야 한다는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-156">An important caveat here's that when an application infers distance from direction (for example by doing a raycast along the user's gaze direction to find the nearest spatial surface), this must yield results that the user can reliably predict.</span></span> <span data-ttu-id="20f2b-157">그렇지 않으면 사용자가 제어를 사용할 수 없게 되 고,이로 인해 속도가 어려울 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-157">Otherwise, the user will lose their sense of control and this can quickly become frustrating.</span></span> <span data-ttu-id="20f2b-158">이 작업에 도움이 되는 방법 중 하나는 하나 아니라 여러 raycasts를 수행 하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-158">One method that helps with this is to do multiple raycasts instead of just one.</span></span> <span data-ttu-id="20f2b-159">집계 결과는 보다 빠르고 예측 가능 하며 일시적 ' 이상 ' 결과에 영향을 미칠 수 있습니다. 즉, 작은 구멍이 나 사용자가 인식 하지 않는 작은 기 하 도형 비트에 도달 하 여 발생 하는 빛 때문에 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-159">The aggregate results should be smoother and more predictable, less susceptible to influence from transient 'outlier' results (as can be caused by rays passing through tiny holes or hitting small bits of geometry that the user isn't aware of).</span></span> <span data-ttu-id="20f2b-160">집계 또는 다듬기를 시간에 따라 수행할 수도 있습니다. 예를 들어, 사용자의 거리에 따라 홀로그램의 최대 속도를 제한할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-160">Aggregation or smoothing can also be performed over time; for example, you can limit the maximum speed at which a hologram can vary in distance from the user.</span></span> <span data-ttu-id="20f2b-161">최소 및 최대 거리 값을 제한 하는 것도 도움이 될 수 있으므로 이동 하는 홀로그램은 갑자기 멀리 이동 하거나 사용자의 얼굴에 다시 충돌 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-161">Simply limiting the minimum and maximum distance value can also help, so the hologram being moved doesn't suddenly fly away into the distance or come crashing back into the user's face.</span></span>

<span data-ttu-id="20f2b-162">응용 프로그램은 표면의 모양과 방향을 사용 하 여 홀로그램 배치를 안내할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-162">Applications can also use the shape and direction of surfaces to guide hologram placement.</span></span> <span data-ttu-id="20f2b-163">Holographic의 상태는 벽을 통과 하지 않아야 하 고, 약간 불균형 하지 않아도 바닥을 가만히 두어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-163">A holographic chair shouldn't penetrate through walls and should sit flush with the floor even if it's slightly uneven.</span></span> <span data-ttu-id="20f2b-164">이러한 종류의 기능은 raycasts 보다는 물리학 충돌을 사용 하는 경우에도 적용 될 수 있지만 이와 유사한 우려 사항이 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-164">This kind of functionality would likely rely upon the use of physics collisions rather than raycasts, however similar concerns will apply.</span></span> <span data-ttu-id="20f2b-165">배치 되는 홀로그램에 한도의 다리와 같이 작은 여러 개의 작은 다각형이 있는 경우, snagging 없이 공간 표면 보다 더 많이 이동할 수 있도록 해당 다각형의 물리학 표현을 보다 넓거나 부드러운 것으로 확장 하는 것이 좋을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-165">If the hologram being placed has many small polygons that stick out, like the legs on a chair, it may make sense to expand the physics representation of those polygons to something wider and smoother so that they're more able to slide over spatial surfaces without snagging.</span></span>

<span data-ttu-id="20f2b-166">사용자 입력이 완전히 간소화 되 고 공간 표면이 전체 자동 홀로그램 배치를 수행 하는 데 사용 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-166">At its extreme, user input can be simplified away entirely and spatial surfaces can be used to do entirely automatic hologram placement.</span></span> <span data-ttu-id="20f2b-167">예를 들어, 응용 프로그램은 사용자가 누르기 위해 벽 어딘가에 holographic을 둘 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-167">For example, the application could place a holographic light-switch somewhere on the wall for the user to press.</span></span> <span data-ttu-id="20f2b-168">예측 가능성에 대 한 동일한 주의 사항은 여기에서 이중으로 적용 됩니다. 사용자가 홀로그램 배치를 제어 하는 것으로 기대 하지만 응용 프로그램에서 예상 되는 위치에 항상 holograms를 배치 하지 않는 경우 (빛 스위치가 사용자에 게 도달할 수 없는 어딘가에 표시 되는 경우)이는 불편 한 경험입니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-168">The same caveat about predictability applies doubly here; if the user expects control over hologram placement, but the application doesn't always place holograms where they expect (if the light-switch appears somewhere that the user can't reach), then this will be a frustrating experience.</span></span> <span data-ttu-id="20f2b-169">사용자가 항상 배치를 수행 해야 하는 것 보다 사용자 수정이 필요한 자동 배치를 수행 하는 것이 더 낮을 수 있습니다. 자동 배치가 *정상적* 으로 수행 되기 때문에 수동 수정은 부담이 되는 것 처럼 보입니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-169">It can actually be worse to do automatic placement that requires user correction some of the time, than to just require the user to always do placement themselves; because successful automatic placement is *expected*, manual correction feels like a burden!</span></span>

<span data-ttu-id="20f2b-170">또한 배치를 위해 공간 표면을 사용 하는 응용 프로그램의 기능은 응용 프로그램의 [검색 환경](spatial-mapping.md#the-environment-scanning-experience)에 따라 크게 달라 집니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-170">Note also that the ability of an application to use spatial surfaces for placement depends heavily on the application's [scanning experience](spatial-mapping.md#the-environment-scanning-experience).</span></span> <span data-ttu-id="20f2b-171">표면이 스캔 되지 않은 경우 배치에 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-171">If a surface hasn't been scanned, then it cannot be used for placement.</span></span> <span data-ttu-id="20f2b-172">새 화면을 검색 하거나 새 위치를 선택할 수 있도록 사용자에 게이를 명확 하 게 표시 하는 것은 응용 프로그램에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-172">It's up to the application to make this clear to the user, so that they can either help scan new surfaces or select a new location.</span></span>

<span data-ttu-id="20f2b-173">사용자에 게 시각적 피드백은 배치 중 가장 중요 한 것입니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-173">Visual feedback to the user is of paramount importance during placement.</span></span> <span data-ttu-id="20f2b-174">사용자는 [접지 효과](spatial-mapping.md#visualization)와 가장 가까운 표면에 따라 홀로그램의 위치를 알고 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-174">The user needs to know where the hologram is based on the nearest surface with [grounding effects](spatial-mapping.md#visualization).</span></span> <span data-ttu-id="20f2b-175">홀로그램의 이동이 제한 되는 이유를 이해 해야 합니다 (예: 인접 한 다른 표면의 충돌 때문).</span><span class="sxs-lookup"><span data-stu-id="20f2b-175">They should understand why the movement of their hologram is being constrained (for example, because of collisions with another nearby surface).</span></span> <span data-ttu-id="20f2b-176">현재 위치에 홀로그램을 넣을 수 없는 경우 시각적 피드백을 통해 이유를 명확 하 게 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-176">If they can't place a hologram in the current location, then visual feedback should make it clear why not.</span></span> <span data-ttu-id="20f2b-177">예를 들어 사용자가 holographic 소파를 벽에 고정 하 려 하는 경우 벽 뒤에 있는 소파의 부분은 화난 색으로 pulsate 됩니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-177">For example, if the user is trying to place a holographic couch stuck half-way into the wall, then the portions of the couch that are behind the wall should pulsate in an angry color.</span></span> <span data-ttu-id="20f2b-178">반대로 응용 프로그램이 실제 화면을 볼 수 있는 위치에서 공간 화면을 찾을 수 없는 경우 응용 프로그램에서이를 명확 하 게 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-178">Or conversely, if the application can't find a spatial surface in a location where the user can see a real-world surface, then the application should make this clear.</span></span> <span data-ttu-id="20f2b-179">이 영역에서 접지 효과가 확실 하지 않은 것은이 목적을 달성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-179">The obvious absence of a grounding effect in this area may achieve this purpose.</span></span>

### <a name="occlusion"></a><span data-ttu-id="20f2b-180">폐색</span><span class="sxs-lookup"><span data-stu-id="20f2b-180">Occlusion</span></span>

<span data-ttu-id="20f2b-181">공간 매핑 표면의 주요 용도 중 하나는 단순히 려 holograms입니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-181">One of the primary uses of spatial mapping surfaces is simply to occlude holograms.</span></span> <span data-ttu-id="20f2b-182">이 간단한 동작은 holograms의 인식 된 현실감에 상당한 영향을 주므로 실제로 사용자와 동일한 물리적 공간을 inhabits 하는 visceral sense를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-182">This simple behavior has a huge impact on the perceived realism of holograms, helping to create a visceral sense that really inhabits the same physical space as the user.</span></span>

<span data-ttu-id="20f2b-183">또한 폐색는 사용자에 게 정보를 제공 합니다. 홀로그램은 실제 표면에 의해 폐색 보이는 것 처럼 보이지만 전 세계의 해당 홀로그램 공간 위치에 대 한 추가 시각적 피드백을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-183">Occlusion also provides information to the user; when a hologram appears to be occluded by a real-world surface, this provides extra visual feedback as to the spatial location of that hologram in the world.</span></span> <span data-ttu-id="20f2b-184">반대로 폐색는 사용자 로부터 정보를 유용한 *숨길* 수도 있습니다. 벽이 occluding holograms은 직관적인 방식으로 시각적 개체를 줄일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-184">Conversely, occlusion can also usefully *hide* information from the user; occluding holograms behind walls can reduce visual clutter in an intuitive way.</span></span> <span data-ttu-id="20f2b-185">홀로그램을 숨기 거 나 표시 하려면 사용자가 자신의 헤드를 이동 하기만 하면 됩니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-185">To hide or reveal a hologram, the user merely has to move their head.</span></span>

<span data-ttu-id="20f2b-186">폐색를 사용 하 여 친숙 한 물리적 상호 작용을 기반으로 자연 사용자 인터페이스에 대 한 기대를 파악할 수도 있습니다. 홀로그램을 표면에 폐색 하는 경우 해당 서피스가 solid 이기 때문입니다. 따라서 사용자는 홀로그램이 해당 화면과 *충돌* 하 고 통과 하지 않을 것으로 간주 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-186">Occlusion can also be used to prime expectations for a natural user interface based upon familiar physical interactions; if a hologram is occluded by a surface it is because that surface is solid, so the user should expect that the hologram will *collide* with that surface and not pass through it.</span></span>

<span data-ttu-id="20f2b-187">경우에 따라 holograms의 폐색는 바람직하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-187">Sometimes, occlusion of holograms is undesirable.</span></span> <span data-ttu-id="20f2b-188">사용자가 홀로그램과 상호 작용 해야 하는 경우 실제 화면 뒤에 있더라도이를 확인 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-188">If a user needs to interact with a hologram, then they need to see it - even if it is behind a real-world surface.</span></span> <span data-ttu-id="20f2b-189">이러한 경우 일반적으로 폐색 때 이러한 홀로그램을 다르게 렌더링 하는 것이 좋습니다 (예: 밝기 감소).</span><span class="sxs-lookup"><span data-stu-id="20f2b-189">In such cases, it usually makes sense to render such a hologram differently when it's occluded (for example, by reducing its brightness).</span></span> <span data-ttu-id="20f2b-190">이렇게 하면 사용자가 홀로그램를 시각적으로 찾을 수 있지만 여전히 무언가를 확인 하는 것을 알 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-190">This way, the user can visually locate the hologram, but they'll still know it's behind something.</span></span>

### <a name="physics"></a><span data-ttu-id="20f2b-191">Physics</span><span class="sxs-lookup"><span data-stu-id="20f2b-191">Physics</span></span>

<span data-ttu-id="20f2b-192">물리 시뮬레이션을 사용 하는 또 다른 방법은 공간 매핑을 사용 하 여 사용자의 실제 공간에서 holograms의 *존재* 를 강화할 수 있는 또 다른 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-192">The use of physics simulation is another way in which spatial mapping can be used to reinforce the *presence* of holograms in the user's physical space.</span></span> <span data-ttu-id="20f2b-193">내 holographic 고무 공이 우리 책상에서 사실적으로 롤업되 면 바닥에 바운스 하 고 소파 아래에 사라지면 안 되는 것으로 생각 하는 것이 어려울 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-193">When my holographic rubber ball rolls realistically off my desk, bounces across the floor and disappears under the couch, it might be hard for me to believe that it's not there.</span></span>

<span data-ttu-id="20f2b-194">또한 물리학 시뮬레이션에서는 응용 프로그램이 자연스럽 고 친숙 한 물리학 기반 상호 작용을 사용할 수 있는 기회를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-194">Physics simulation also provides the opportunity for an application to use natural and familiar physics-based interactions.</span></span> <span data-ttu-id="20f2b-195">Holographic 가구의 피스를 이동 하는 것은 가구가 적절 한 관성 및 마찰으로 바닥을 슬라이딩 하는 것 처럼 반응 하는 경우 사용자에 게 더 쉬울 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-195">Moving a piece of holographic furniture around on the floor will likely be easier for the user if the furniture responds as if it were sliding across the floor with the appropriate inertia and friction.</span></span>

<span data-ttu-id="20f2b-196">실제 동작을 생성 하기 위해 구멍 채우기, 부동 hallucinations 제거 및 대략적인 표면 다듬기와 같은 [메시 처리](spatial-mapping.md#mesh-processing) 를 수행 해야 할 가능성이 높습니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-196">To generate realistic physical behaviors, you'll likely need to do some [mesh processing](spatial-mapping.md#mesh-processing) such as filling holes, removing floating hallucinations and smoothing rough surfaces.</span></span>

<span data-ttu-id="20f2b-197">또한 응용 프로그램의 [검사 환경이](spatial-mapping.md#the-environment-scanning-experience) 물리 시뮬레이션에 미치는 영향을 고려해 야 합니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-197">You'll also need to consider how your application's [scanning experience](spatial-mapping.md#the-environment-scanning-experience) influences its physics simulation.</span></span> <span data-ttu-id="20f2b-198">첫째, 누락 된 표면은 어떤 것 과도 충돌 하지 않습니다. 고무 공이 어느에서 벗어나 알려진 세계의 끝에서 롤업되 면 어떻게 되나요?</span><span class="sxs-lookup"><span data-stu-id="20f2b-198">Firstly, missing surfaces won't collide with anything; what happens when the rubber ball rolls off down the corridor and off the end of the known world?</span></span> <span data-ttu-id="20f2b-199">둘째로, 시간이 지남에 따라 환경의 변화에 대 한 응답을 계속할지 여부를 결정 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-199">Secondly, you need to decide whether you'll continue to respond to changes in the environment over time.</span></span> <span data-ttu-id="20f2b-200">경우에 따라 최대한 신속 하 게 응답 하는 것이 좋습니다. 사용자가 들어오는 로마 화살표의 템 피스트에 대해 방어에서 이동 가능한 barricades로 도어 및 가구를 사용 하 고 있다고 가정 합니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-200">In some cases, you'll want to respond as quickly as possible; say if the user is using doors and furniture as movable barricades in defense against a tempest of incoming Roman arrows.</span></span> <span data-ttu-id="20f2b-201">그러나 다른 경우에는 새 업데이트를 무시 하는 것이 좋습니다. holographic 스포츠 자동차를 바닥의 트랙 가운데에 배치 하기로 결정 한 경우에는이를 통해 재미 없게 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-201">In other cases though, you may want to ignore new updates; driving your holographic sports car around the racetrack on your floor may suddenly not be so fun if your dog decides to sit in the middle of the track.</span></span>

### <a name="navigation"></a><span data-ttu-id="20f2b-202">탐색</span><span class="sxs-lookup"><span data-stu-id="20f2b-202">Navigation</span></span>

<span data-ttu-id="20f2b-203">응용 프로그램은 공간 매핑 데이터를 사용 하 여 실제 사용자와 동일한 방식으로 실제 세계를 탐색 하는 기능을 holographic 문자 (또는 에이전트)에 게 부여할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-203">Applications can use spatial mapping data to grant holographic characters (or agents) the ability to navigate the real world in the same way a real person would.</span></span> <span data-ttu-id="20f2b-204">이렇게 하면 사용자와 사용자의 친구와 동일한 자연스럽 고 친숙 한 동작 집합으로 제한 하 여 holographic 문자를 더욱 쉽게 확인할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-204">This can help reinforce the presence of holographic characters by restricting them to the same set of natural, familiar behaviors as those of the user and their friends.</span></span>

<span data-ttu-id="20f2b-205">탐색 기능은 사용자에 게 유용할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-205">Navigation capabilities could be useful to users as well.</span></span> <span data-ttu-id="20f2b-206">지정 된 영역에서 탐색 맵을 작성 한 후에는 해당 위치에 익숙하지 않은 새 사용자에 대 한 holographic 방향을 제공 하도록 공유할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-206">Once a navigation map has been built in a given area, it could be shared to provide holographic directions for new users unfamiliar with that location.</span></span> <span data-ttu-id="20f2b-207">이 맵은 보행자의 ' 교통 ' 트래픽을 원활 하 게 전달 하거나 생성 사이트와 같은 위험한 위치에서 사고를 방지할 수 있도록 설계 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-207">This map could be designed to help keep pedestrian 'traffic' flowing smoothly, or to avoid accidents in dangerous locations like construction sites.</span></span>

<span data-ttu-id="20f2b-208">탐색 기능을 구현 하는 것과 관련 된 핵심 기술 과제는 walkable 표면 (사람이 테이블을 탐색 하지 않음)을 안정적으로 검색 하 고 환경의 변화에 대 한 적절 한 적응 (사람이 폐쇄형 도어를 통하지 않음)을 수행 하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-208">The key technical challenges involved in implementing navigation functionality will be reliable detection of walkable surfaces (humans don't walk on tables!) and graceful adaptation to changes in the environment (humans don't walk through closed doors!).</span></span> <span data-ttu-id="20f2b-209">메시는 경로 계획 및 가상 문자 탐색에 사용할 수 있도록 하기 전에 몇 가지 [처리](spatial-mapping.md#mesh-processing) 를 요구할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-209">The mesh may require some [processing](spatial-mapping.md#mesh-processing) before it's usable for path-planning and navigation by a virtual character.</span></span> <span data-ttu-id="20f2b-210">메시를 매끄럽게 하 고 hallucinations를 제거 하면 문자가 중단 되지 않도록 방지할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-210">Smoothing the mesh and removing hallucinations may help avoid characters becoming stuck.</span></span> <span data-ttu-id="20f2b-211">메시를 크게 단순화 하 여 문자의 경로 계획 및 탐색 계산 속도를 높일 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-211">You may also wish to drastically simplify the mesh to speed up your character's path-planning and navigation calculations.</span></span> <span data-ttu-id="20f2b-212">이러한 문제는 비디오 게임 기술의 개발에 상당한 주의가 필요 하며, 이러한 주제에 대 한 다양 한 연구 자료를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-212">These challenges have received a great deal of attention in the development of video game technology, and there's a wealth of available research literature on these topics.</span></span>

<span data-ttu-id="20f2b-213">Unity의 기본 제공 NavMesh 기능은 공간 매핑 화면에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-213">The built-in NavMesh functionality in Unity cannot be used with spatial mapping surfaces.</span></span> <span data-ttu-id="20f2b-214">이는 응용 프로그램이 시작 될 때 까지는 공간 매핑 서피스가 알려지지 않지만 NavMesh 데이터 파일은 소스 자산에서 미리 생성 되어야 하기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-214">This is because spatial mapping surfaces aren't known until the application starts, but NavMesh data files need to be generated from source assets ahead of time.</span></span> <span data-ttu-id="20f2b-215">또한 공간 매핑 시스템은 사용자의 현재 위치에서 멀리 [떨어진 화면에 대 한 정보](spatial-mapping.md#the-environment-scanning-experience) 를 제공 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-215">Also note that, the spatial mapping system won't provide [information about surfaces far away](spatial-mapping.md#the-environment-scanning-experience) from the user's current location.</span></span> <span data-ttu-id="20f2b-216">따라서 응용 프로그램은 많은 영역의 지도를 작성 하는 경우에는 화면 자체를 ' 주의 ' 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-216">So the application must 'remember' surfaces itself if it's to build a map of a large area.</span></span>

### <a name="visualization"></a><span data-ttu-id="20f2b-217">시각화</span><span class="sxs-lookup"><span data-stu-id="20f2b-217">Visualization</span></span>

<span data-ttu-id="20f2b-218">대부분의 경우 공간 표면을 표시 하지 않는 것이 좋습니다. 시각적으로 혼란을 최소화 하 고 실제 세계를 대상으로 말할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-218">Most of the time it's appropriate for spatial surfaces to be invisible; to minimize visual clutter and let the real world speak for itself.</span></span> <span data-ttu-id="20f2b-219">그러나 실제 요소는 표시 되기에도 불구 하 고 공간 매핑 표면을 직접 시각화 하는 것이 유용한 경우도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-219">However, sometimes it's useful to visualize spatial mapping surfaces directly, despite their real-world counterparts being visible.</span></span>

<span data-ttu-id="20f2b-220">예를 들어 사용자가 표면에 홀로그램을 배치 하려고 할 때 (예: 벽에 holographic 캐비닛 배치) 그림자를 화면으로 캐스팅 하 여 홀로그램을 ' 그라운드 ' 하는 데 유용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-220">For example, when the user is trying to place a hologram onto a surface (placing a holographic cabinet on the wall, say) it can be useful to 'ground' the hologram by casting a shadow onto the surface.</span></span> <span data-ttu-id="20f2b-221">이렇게 하면 사용자에 게 홀로그램과 표면 사이의 정확한 물리적 근접 한 의미가 제공 됩니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-221">This gives the user a much clearer sense of the exact physical proximity between the hologram and the surface.</span></span> <span data-ttu-id="20f2b-222">사용자가 커밋하기 전에 변경을 시각적으로 ' 미리 보기 ' 하는 일반적인 방법의 예 이기도 합니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-222">This is also an example of the more general practice of visually 'previewing' a change before the user commits to it.</span></span>

<span data-ttu-id="20f2b-223">응용 프로그램은 화면을 시각화 하 여 환경에 대 한 이해를 사용자와 공유할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-223">By visualizing surfaces, the application can share with the user its understanding of the environment.</span></span> <span data-ttu-id="20f2b-224">예를 들어 holographic board game은 ' 테이블 '로 식별 된 가로 표면을 시각화할 수 있으므로 사용자가 상호 작용 해야 하는 위치를 알 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-224">For example, a holographic board game could visualize the horizontal surfaces that it has identified as 'tables', so the user knows where they should go to interact.</span></span>

<span data-ttu-id="20f2b-225">화면 시각화는 뷰에서 숨겨진 사용자에 게 인접 한 공간을 표시 하는 데 유용한 방법일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-225">Visualizing surfaces can be a useful way to show the user nearby spaces that are hidden from view.</span></span> <span data-ttu-id="20f2b-226">이를 통해 사용자에 게 거실에서 부엌 (그리고 포함 된 모든 holograms)에 대 한 액세스 권한을 제공할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-226">This could provide a way to give the user access to their kitchen (and all of its contained holograms) from their living room.</span></span>

<span data-ttu-id="20f2b-227">공간 매핑에서 제공 되는 surface 메시는 특히 ' clean ' 일 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-227">The surface meshes provided by spatial mapping may not be particularly 'clean'.</span></span> <span data-ttu-id="20f2b-228">적절 하 게 시각화 하는 것이 중요 합니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-228">It's important to visualize them appropriately.</span></span> <span data-ttu-id="20f2b-229">기존 조명 계산은 시각적으로 혼란을 줄 수 있는 표면 법선의 오류를 강조 표시할 수 있습니다. 반면 표면에 투영 된 ' clean ' 질감은 tidier 모양을 제공 하는 데 도움이 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-229">Traditional lighting calculations may highlight errors in surface normals in a visually distracting manner, while 'clean' textures projected onto the surface may help to give it a tidier appearance.</span></span> <span data-ttu-id="20f2b-230">표면이 렌더링 되기 전에 메시 속성을 개선 하기 위해 [메시 처리](spatial-mapping.md#mesh-processing) 를 수행할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-230">It's also possible to do [mesh processing](spatial-mapping.md#mesh-processing) to improve mesh properties, before the surfaces are rendered.</span></span>

> [!NOTE]
> <span data-ttu-id="20f2b-231">HoloLens 2는 혼합 현실 개발자에 게 배치, 폐색, 물리 및 탐색의 구현을 간소화 하도록 설계 된 구조화 된 고급 환경 표현을 제공 하는 새로운 [장면 이해 런타임을](scene-understanding.md)구현 합니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-231">HoloLens 2 implements a new [Scene Understanding Runtime](scene-understanding.md), that provides Mixed Reality developers with a structured, high-level environment representation designed to simplify the implementation of placement, occlusion, physics and navigation.</span></span>

## <a name="using-the-surface-observer"></a><span data-ttu-id="20f2b-232">Surface 관찰자 사용</span><span class="sxs-lookup"><span data-stu-id="20f2b-232">Using The Surface Observer</span></span>

<span data-ttu-id="20f2b-233">공간 매핑의 시작점은 표면 관찰자입니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-233">The starting point for spatial mapping is the surface observer.</span></span> <span data-ttu-id="20f2b-234">프로그램 흐름은 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-234">Program flow is as follows:</span></span>
* <span data-ttu-id="20f2b-235">Surface 관찰자 개체 만들기</span><span class="sxs-lookup"><span data-stu-id="20f2b-235">Create a surface observer object</span></span>
   * <span data-ttu-id="20f2b-236">하나 이상의 공간 볼륨을 제공 하 여 응용 프로그램이 공간 매핑 데이터를 받을 대상 영역을 정의 합니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-236">Provide one or more spatial volumes, to define the regions of interest in which the application wishes to receive spatial mapping data.</span></span> <span data-ttu-id="20f2b-237">공간 볼륨은 단지 구 또는 상자와 같은 공간의 영역을 정의 하는 셰이프입니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-237">A spatial volume is simply a shape defining a region of space, such as a sphere or a box.</span></span>
   * <span data-ttu-id="20f2b-238">세계에서 잠긴 공간 좌표계를 사용 하 여 공간 볼륨을 사용 하 여 실제 세계의 고정 영역을 식별 합니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-238">Use a spatial volume with a world-locked spatial coordinate system to identify a fixed region of the physical world.</span></span>
   * <span data-ttu-id="20f2b-239">본문 잠김 공간 좌표계를 사용 하 여 각 프레임을 업데이트 하는 공간 볼륨을 사용 하 여 사용자와의 이동 (회전 하지 않음) 하는 공간 영역을 식별 합니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-239">Use a spatial volume, updated each frame with a body-locked spatial coordinate system, to identify a region of space that moves (but doesn't rotate) with the user.</span></span>
   * <span data-ttu-id="20f2b-240">이러한 공간 볼륨은 나중에 언제 든 지 응용 프로그램 또는 사용자의 상태가 변경 됨에 따라 변경 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-240">These spatial volumes may be changed later at any time, as the status of the application or the user changes.</span></span>
* <span data-ttu-id="20f2b-241">폴링 또는 알림을 사용 하 여 공간 표면에 대 한 정보 검색</span><span class="sxs-lookup"><span data-stu-id="20f2b-241">Use polling or notification to retrieve information about spatial surfaces</span></span>
   * <span data-ttu-id="20f2b-242">언제 든 지 공간 노출 상태에 대 한 표면 관찰자를 ' 폴링할 ' 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-242">You may 'poll' the surface observer for spatial surface status at any time.</span></span> <span data-ttu-id="20f2b-243">대신 공간 표면이 변경 될 때 응용 프로그램에 알리는 surface 관찰자의 ' 표면 변경 ' 이벤트를 등록할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-243">Instead, you may register for the surface observer's 'surfaces changed' event, which will notify the application when spatial surfaces have changed.</span></span>
   * <span data-ttu-id="20f2b-244">뷰 하위 수준 또는 본문 잠금 볼륨과 같은 동적 공간 볼륨의 경우, 응용 프로그램은 관심 영역을 설정 하 고 현재 공간 표면의 집합을 가져와 각 프레임의 변경을 폴링합니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-244">For a dynamic spatial volume, such as the view frustum, or a body-locked volume, applications will need to poll for changes each frame by setting the region of interest and then obtaining the current set of spatial surfaces.</span></span>
   * <span data-ttu-id="20f2b-245">단일 대화방을 포함 하는 세계에서 잠긴 큐브와 같은 정적 볼륨의 경우 응용 프로그램에서 ' surface changed ' 이벤트를 등록 하 여 해당 볼륨 내의 공간 표면이 변경 되었을 때 알리도록 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-245">For a static volume, such as a world-locked cube covering a single room, applications may register for the 'surfaces changed' event to be notified when spatial surfaces inside that volume may have changed.</span></span>
* <span data-ttu-id="20f2b-246">프로세스 표면 변경</span><span class="sxs-lookup"><span data-stu-id="20f2b-246">Process surfaces changes</span></span>
   * <span data-ttu-id="20f2b-247">제공 된 공간 표면의 집합을 반복 합니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-247">Iterate the provided set of spatial surfaces.</span></span>
   * <span data-ttu-id="20f2b-248">공간 표면을 추가, 변경 또는 제거 된 것으로 분류 합니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-248">Classify spatial surfaces as added, changed, or removed.</span></span>
   * <span data-ttu-id="20f2b-249">추가 되거나 변경 된 각 공간 표면의 경우 적절 한 세부 수준에서 표면의 현재 상태를 나타내는 업데이트 된 메시를 수신 하는 비동기 요청을 적절 하 게 제출 합니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-249">For each added or changed spatial surface, if appropriate submit an asynchronous request to receive updated mesh representing the surface's current state at the desired level of detail.</span></span>
* <span data-ttu-id="20f2b-250">비동기 메시 요청을 처리 합니다 (다음 섹션에서 자세히 설명).</span><span class="sxs-lookup"><span data-stu-id="20f2b-250">Process the asynchronous mesh request (more details in following sections).</span></span>

## <a name="mesh-caching"></a><span data-ttu-id="20f2b-251">메시 캐싱</span><span class="sxs-lookup"><span data-stu-id="20f2b-251">Mesh Caching</span></span>

<span data-ttu-id="20f2b-252">공간 표면은 조밀한 삼각형 메시로 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-252">Spatial surfaces are represented by dense triangle meshes.</span></span> <span data-ttu-id="20f2b-253">이러한 메시의 저장, 렌더링 및 처리는 상당한 계산 및 저장소 리소스를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-253">Storing, rendering, and processing these meshes can consume significant computational and storage resources.</span></span> <span data-ttu-id="20f2b-254">따라서 각 응용 프로그램은 메시 처리 및 저장소에 사용 되는 리소스를 최소화 하기 위해 요구 사항에 적합 한 메시 캐싱 체계를 채택 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-254">As such, each application should adopt a mesh caching scheme appropriate to its needs, to minimize the resources used for mesh processing and storage.</span></span> <span data-ttu-id="20f2b-255">이 체계는 유지할 메시와 삭제할 메시 및 각 공간 표면의 메시를 업데이트할 시기를 결정 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-255">This scheme should determine which meshes to keep and which to discard, and when to update the mesh for each spatial surface.</span></span>

<span data-ttu-id="20f2b-256">여기에서 설명 하는 대부분의 고려 사항은 응용 프로그램이 메시 캐싱에 접근 하는 방법을 직접 알려 줍니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-256">Many of the considerations discussed there will directly inform how your application should approach mesh caching.</span></span> <span data-ttu-id="20f2b-257">사용자가 환경에서 이동 하는 방법, 여러 서피스가 관찰 될 때, 환경의 변경 내용을 캡처해야 하는 경우를 고려해 야 합니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-257">You should consider how the user moves through the environment, which surfaces are needed, when different surfaces will be observed and when changes in the environment should be captured.</span></span>

<span data-ttu-id="20f2b-258">Surface 관찰자가 제공 하는 ' 표면 변화 ' 이벤트를 해석할 때 기본 메시 캐싱 논리는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-258">When interpreting the 'surfaces changed' event provided by the surface observer, the basic mesh caching logic is as follows:</span></span>
* <span data-ttu-id="20f2b-259">응용 프로그램에서 이전에 표시 되지 않은 공간 노출 ID를 확인 하는 경우이를 새로운 공간 표면으로 처리 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-259">If the application sees a spatial surface ID that it hasn't seen before, it should treat this as a new spatial surface.</span></span>
* <span data-ttu-id="20f2b-260">응용 프로그램에서 지정 된 ID를 가진 공간 표면의 새 업데이트 시간을 확인 하는 경우이를 업데이트 된 공간 화면으로 처리 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-260">If the application sees a spatial surface with a known ID but with a new update time, it should treat this as an updated spatial surface.</span></span>
* <span data-ttu-id="20f2b-261">응용 프로그램에서 더 이상 알려진 ID의 공간 표면을 인식 하지 못하는 경우 제거 된 공간 서피스로이를 처리 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-261">If the application no longer sees a spatial surface with a known ID, it should treat this as a removed spatial surface.</span></span>

<span data-ttu-id="20f2b-262">각 응용 프로그램은 다음과 같이 선택할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-262">It's up to each application to then make the following choices:</span></span>
* <span data-ttu-id="20f2b-263">새 공간 표면의 경우 메시를 요청 해야 하나요?</span><span class="sxs-lookup"><span data-stu-id="20f2b-263">For new spatial surfaces, should mesh be requested?</span></span>
   * <span data-ttu-id="20f2b-264">일반적으로 메시는 사용자에 게 유용한 새 정보를 제공할 수 있는 새 공간 표면에 대해 즉시 요청 되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-264">Generally mesh should be requested immediately for new spatial surfaces, which may provide useful new information to the user.</span></span>
   * <span data-ttu-id="20f2b-265">그러나 사용자 앞의 및 앞에 있는 새 공간 표면에 우선 순위를 지정 하 고 해당 메시를 먼저 요청 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-265">However, new spatial surfaces near and in front of the user should be given priority and their mesh should be requested first.</span></span>
   * <span data-ttu-id="20f2b-266">새 메쉬가 필요 하지 않은 경우, 예를 들어 응용 프로그램이 환경 모델을 영구적으로 또는 일시적으로 ' 고정 ' 하는 경우 요청 되어서는 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-266">If the new mesh isn't needed, if for example the application has permanently or temporarily 'frozen' its model of the environment, then it shouldn't be requested.</span></span>
* <span data-ttu-id="20f2b-267">업데이트 된 공간 표면의 경우 메시를 요청 해야 하나요?</span><span class="sxs-lookup"><span data-stu-id="20f2b-267">For updated spatial surfaces, should mesh be requested?</span></span>
   * <span data-ttu-id="20f2b-268">사용자의 앞과 뒤에 있는 업데이트 된 공간 화면에 우선 순위를 지정 하 고 해당 메시를 먼저 요청 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-268">Updated spatial surfaces near and in front of the user should be given priority and their mesh should be requested first.</span></span>
   * <span data-ttu-id="20f2b-269">특히 스캔 환경에서 업데이트 된 표면 보다 새 표면에 더 높은 우선 순위를 부여 하는 것이 적합할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-269">It may also be appropriate to give higher priority to new surfaces than to updated surfaces, especially during the scanning experience.</span></span>
   * <span data-ttu-id="20f2b-270">처리 비용을 제한 하기 위해 응용 프로그램은 공간 표면의 업데이트를 처리 하는 속도를 제한 하고자 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-270">To limit processing costs, applications may wish to throttle the rate at which they process updates to spatial surfaces.</span></span>
   * <span data-ttu-id="20f2b-271">예를 들어 표면의 범위가 작은 경우 (예: 표면의 범위가 작은 경우), 처리 하는 데 충분 하지 않을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-271">It may be possible to infer that changes to a spatial surface are minor, for example if the bounds of the surface are small, in which case the update may not be important enough to process.</span></span>
   * <span data-ttu-id="20f2b-272">사용자를 대상으로 하는 현재 영역 외부의 공간 표면의 업데이트는 완전히 무시 될 수 있지만,이 경우 surface 관찰자가 사용 하는 공간 경계 볼륨을 수정 하는 것이 더 효율적일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-272">Updates to spatial surfaces outside the current region of interest of the user may be ignored entirely, though in this case it may be more efficient to modify the spatial bounding volumes in use by the surface observer.</span></span>
* <span data-ttu-id="20f2b-273">제거 된 공간 표면의 경우 메시를 삭제 해야 하나요?</span><span class="sxs-lookup"><span data-stu-id="20f2b-273">For removed spatial surfaces, should mesh be discarded?</span></span>
   * <span data-ttu-id="20f2b-274">일반적으로 메시는 제거 된 공간 표면에 대해 즉시 삭제 되어야 하므로 홀로그램 폐색는 올바른 상태로 유지 됩니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-274">Generally mesh should be discarded immediately for removed spatial surfaces, so that hologram occlusion remains correct.</span></span>
   * <span data-ttu-id="20f2b-275">그러나 응용 프로그램에서 사용자 환경 디자인을 기반으로 하 여 공간 표면이 곧 다시 나타나는 것으로 예상 되는 경우에는 메시를 삭제 하 고 나중에 다시 만드는 것 보다 더 효율적일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-275">However, if the application has reason to believe that a spatial surface will reappear shortly (based upon the design of the user experience), then it may be more efficient to keep it than to discard its mesh and recreate it again later.</span></span>
   * <span data-ttu-id="20f2b-276">응용 프로그램이 사용자 환경의 대규모 모델을 빌드하는 경우 메시를 전혀 삭제 하지 않을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-276">If the application is building a large-scale model of the user's environment, then it may not wish to discard any meshes at all.</span></span> <span data-ttu-id="20f2b-277">공간 서피스가 사라질 때 메시를 디스크로 스풀링하는 경우에도 리소스 사용량을 제한 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-277">It will still need to limit resource usage though, possibly by spooling meshes to disk as spatial surfaces disappear.</span></span>
   * <span data-ttu-id="20f2b-278">공간 surface를 생성 하는 동안 비교적 드물게 발생 하는 일부 이벤트는 다른 Id를 사용 하 여 비슷한 위치의 새 공간 서피스로 공간 표면을 대체할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-278">Some relatively rare events during spatial surface generation can cause spatial surfaces to be replaced by new spatial surfaces in a similar location but with different IDs.</span></span> <span data-ttu-id="20f2b-279">따라서 제거 된 화면을 삭제 하지 않도록 선택 하는 응용 프로그램은 동일한 위치를 포함 하는 여러 개의 겹치는 공간 표면 메시로 끝나지 않도록 주의 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-279">So, applications that choose not to discard a removed surface should take care not to end up with multiple highly overlapped spatial surfaces meshes covering the same location.</span></span>
* <span data-ttu-id="20f2b-280">다른 공간 표면의 메시를 삭제 해야 하나요?</span><span class="sxs-lookup"><span data-stu-id="20f2b-280">Should mesh be discarded for any other spatial surfaces?</span></span>
   * <span data-ttu-id="20f2b-281">공간 표면이 있는 동안에도 사용자 환경에 더 이상 유용 하지 않은 경우에는 삭제 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-281">Even while a spatial surface exists, if it's no longer useful to the user's experience then it should be discarded.</span></span> <span data-ttu-id="20f2b-282">예를 들어, 응용 프로그램이 이르는 길의 다른 쪽에 있는 대화방을 대체 가상 공간으로 대체 하는 경우 해당 공간의 공간 표면이 더 이상 중요 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-282">For example, if the application 'replaces' the room on the other side of a doorway with an alternate virtual space then the spatial surfaces in that room no longer matter.</span></span>

<span data-ttu-id="20f2b-283">다음은 공간 및 임시 임계값을 사용 하는 메시 캐싱 전략의 예입니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-283">Here's an example mesh caching strategy, using spatial and temporal hysteresis:</span></span>
* <span data-ttu-id="20f2b-284">사용자의 응시를 따르는 것과 같이 두 부분으로 이루어진 공간 볼륨을 사용 하려는 응용 프로그램을 살펴보세요.</span><span class="sxs-lookup"><span data-stu-id="20f2b-284">Consider an application that wishes to use a frustum-shaped spatial volume of interest that follows the user's gaze as they look around and walk around.</span></span>
* <span data-ttu-id="20f2b-285">사용자가 화면에서 멀리 떨어진 곳에서 또는 그 밖의 단계에서 멀리 떨어져 있기 때문에 공간 표면이 일시적으로이 볼륨에서 사라질 수 있습니다 ... 뒤로 다시 조회 하거나 나중에 다시 이동 합니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-285">A spatial surface may disappear temporarily from this volume simply because the user looks away from the surface or steps further away from it... only to look back or moves closer again a moment later.</span></span> <span data-ttu-id="20f2b-286">이 경우이 화면에 대 한 메시를 삭제 하 고 다시 만드는 것은 여러 중복 processings를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-286">In this case, discarding and re-creating the mesh for this surface represents many redundant processings.</span></span>
* <span data-ttu-id="20f2b-287">처리 되는 변경 내용 수를 줄이기 위해 응용 프로그램은 서로 다른 두 개의 공간 노출 관찰자를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-287">To reduce the number of changes processed, the application uses two spatial surface observers, one contained within the other.</span></span> <span data-ttu-id="20f2b-288">더 큰 볼륨은 구형 이며 사용자가 ' 지연 ' 됩니다. 센터가 사용자의 2.0 미터 이내에 있는지 확인 하는 데 필요한 경우에만 이동 합니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-288">The larger volume is spherical and follows the user 'lazily'; it only moves when necessary to ensure that its center is within 2.0 meters of the user.</span></span>
* <span data-ttu-id="20f2b-289">새 공간 및 업데이트 된 공간 노출 메시는 항상 작은 내부 표면 관찰자에서 처리 되지만 메시는 더 큰 외부 표면 관찰자에서 사라질 때까지 캐시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-289">New and updated spatial surface meshes are always processed from the smaller inner surface observer, but meshes are cached until they disappear from the larger outer surface observer.</span></span> <span data-ttu-id="20f2b-290">이렇게 하면 로컬 사용자 이동으로 인해 응용 프로그램에서 여러 가지 중복 된 변경 내용을 처리 하지 않아도 됩니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-290">This allows the application to avoid processing many redundant changes because of local user movement.</span></span>
* <span data-ttu-id="20f2b-291">공간 표면은 추적 손실로 인해 일시적으로 사라질 수도 있으므로 응용 프로그램은 손실을 추적 하는 동안 제거 된 공간 표면의 삭제를 지연 하기도 합니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-291">Since a spatial surface may also disappear temporarily because of tracking loss, the application also defers discarding removed spatial surfaces during tracking loss.</span></span>
* <span data-ttu-id="20f2b-292">일반적으로 응용 프로그램은 최적의 캐싱 전략을 결정 하기 위해 줄어든 업데이트 처리와 메모리 사용량 증가 간의 균형을 평가 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-292">In general, an application should evaluate the tradeoff between reduced update processing and increased memory usage to determine its ideal caching strategy.</span></span>

## <a name="rendering"></a><span data-ttu-id="20f2b-293">렌더링</span><span class="sxs-lookup"><span data-stu-id="20f2b-293">Rendering</span></span>

<span data-ttu-id="20f2b-294">공간 매핑 메시를 렌더링에 사용 하는 세 가지 기본 방법은 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-294">There are three primary ways in which spatial mapping meshes tend to be used for rendering:</span></span>
* <span data-ttu-id="20f2b-295">Surface 시각화</span><span class="sxs-lookup"><span data-stu-id="20f2b-295">For surface visualization</span></span>
   * <span data-ttu-id="20f2b-296">공간 표면을 직접 시각화 하는 것이 유용한 경우가 많습니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-296">It's often useful to visualize spatial surfaces directly.</span></span> <span data-ttu-id="20f2b-297">예를 들어 개체에서 공간 서피스로 ' shadows '를 캐스팅 하면 표면에 holograms 배치 하는 동안 사용자에 게 유용한 시각적 피드백을 제공할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-297">For example, casting 'shadows' from objects onto spatial surfaces can provide helpful visual feedback to the user while they're placing holograms on surfaces.</span></span>
   * <span data-ttu-id="20f2b-298">공간 메시는 3D 음악가에서 만들 수 있는 메시의 종류와는 다르다는 점입니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-298">One thing to bear in mind is that spatial meshes are different to the kind of meshes that a 3D artist might create.</span></span> <span data-ttu-id="20f2b-299">삼각형 토폴로지는 사람이 만든 토폴로지에서는 ' 정리 ' 되지 않으며 메시는 [다양 한 오류를 발생](spatial-mapping.md#what-influences-spatial-mapping-quality)시킬 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-299">The triangle topology won't be as 'clean' as human-created topology, and the mesh will suffer from [various errors](spatial-mapping.md#what-influences-spatial-mapping-quality).</span></span>
   * <span data-ttu-id="20f2b-300">보기 편 visual 미적을 만들려면 몇 가지 [메시 처리](spatial-mapping.md#mesh-processing)(예: 구멍 또는 부드러운 표면 법선 채우기)를 수행 하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-300">To create a pleasing visual aesthetic, you may want to do some [mesh processing](spatial-mapping.md#mesh-processing), for example to fill holes or smooth surface normals.</span></span> <span data-ttu-id="20f2b-301">메시 토폴로지 및 법선을 직접 시각화 하는 대신 셰이더를 사용 하 여 삽화에서 디자인 한 질감을 망상에 프로젝션 할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-301">You may also wish to use a shader to project artist-designed textures onto your mesh instead of directly visualizing mesh topology and normals.</span></span>
* <span data-ttu-id="20f2b-302">실제 세계 표면 뒤의 occluding holograms</span><span class="sxs-lookup"><span data-stu-id="20f2b-302">For occluding holograms behind real-world surfaces</span></span>
   * <span data-ttu-id="20f2b-303">공간 표면은 깊이 전용 패스에서 렌더링 될 수 있으며이는 [깊이 버퍼](/windows/win32/direct3d9/depth-buffers) 에만 영향을 주며 색 렌더링 대상에는 영향을 주지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-303">Spatial surfaces can be rendered in a depth-only pass, which only affects the [depth buffer](/windows/win32/direct3d9/depth-buffers) and doesn't affect color render targets.</span></span>
   * <span data-ttu-id="20f2b-304">이렇게 하면 prime는 깊이 버퍼를 려 공간 표면 뒤에 holograms 렌더링 합니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-304">This primes the depth buffer to occlude subsequently rendered holograms behind spatial surfaces.</span></span> <span data-ttu-id="20f2b-305">Holograms의 정확한 폐색은 실제로 사용자의 실제 공간 내에 존재 하는 의미를 향상 시킵니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-305">Accurate occlusion of holograms enhances the sense that holograms really exist within the user's physical space.</span></span>
   * <span data-ttu-id="20f2b-306">깊이 전용 렌더링을 사용 하려면 모든 색 렌더링 대상에 대해 blend 상태를 업데이트 하 여 [RenderTargetWriteMask](/windows/win32/api/d3d11_1/ns-d3d11_1-d3d11_render_target_blend_desc1) 을 0으로 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-306">To enable depth-only rendering, update your blend state to set the [RenderTargetWriteMask](/windows/win32/api/d3d11_1/ns-d3d11_1-d3d11_render_target_blend_desc1) to zero for all color render targets.</span></span>
* <span data-ttu-id="20f2b-307">실제 표면에의 한 holograms 폐색의 모양 수정</span><span class="sxs-lookup"><span data-stu-id="20f2b-307">For modifying the appearance of holograms occluded by real-world surfaces</span></span>
   * <span data-ttu-id="20f2b-308">일반적으로 렌더링 된 기 하 도형은 폐색 때 숨겨집니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-308">Normally rendered geometry is hidden when it's occluded.</span></span> <span data-ttu-id="20f2b-309">이렇게 하려면 [깊이 스텐실 상태](/windows/win32/api/d3d11/ns-d3d11-d3d11_depth_stencil_desc) 에서 깊이 함수를 "작거나 같음"으로 설정 합니다. 이렇게 하면 이전에 렌더링 된 모든 기 하 도형 보다 카메라에 **가까이** 있는 경우에만 기 하 도형을 볼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-309">This is achieved by setting the depth function in your [depth-stencil state](/windows/win32/api/d3d11/ns-d3d11-d3d11_depth_stencil_desc) to "less than or equal", which causes geometry to be visible only where it's **closer** to the camera than all previously rendered geometry.</span></span>
   * <span data-ttu-id="20f2b-310">그러나 폐색 경우에도 특정 기 하 도형을 표시 하 고 사용자에 게 시각적 피드백을 제공 하는 방법으로 폐색 때 모양을 수정 하는 것이 유용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-310">However, it may be useful to keep certain geometry visible even when it's occluded, and to modify its appearance when occluded as a way of providing visual feedback to the user.</span></span> <span data-ttu-id="20f2b-311">예를 들어 응용 프로그램에서 사용자에 게 개체의 위치를 표시 하는 동시에 실제 화면 뒤에 있는 것 처럼 명확 하 게 표시할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-311">For example, this allows the application to show the user the location of an object while making it clear that is behind a real-world surface.</span></span>
   * <span data-ttu-id="20f2b-312">이렇게 하려면 원하는 ' 폐색 ' 모양을 만드는 다른 셰이더를 사용 하 여 기 하 도형을 두 번째로 렌더링 합니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-312">To achieve this, render the geometry a second time with a different shader that creates the desired 'occluded' appearance.</span></span> <span data-ttu-id="20f2b-313">기 하 도형을 두 번째로 렌더링 하기 전에 [깊이 스텐실 상태](/windows/win32/api/d3d11/ns-d3d11-d3d11_depth_stencil_desc)를 두 번 변경 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-313">Before rendering the geometry for the second time, make two changes to your [depth-stencil state](/windows/win32/api/d3d11/ns-d3d11-d3d11_depth_stencil_desc).</span></span> <span data-ttu-id="20f2b-314">먼저, 이전에 렌더링 된 모든 기 하 도형 보다 카메라에서 **추가** 된 경우에만 기 하 도형을 볼 수 있도록 깊이 함수를 "크거나 같음"으로 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-314">First, set the depth function to "greater than or equal" so that the geometry will be visible only where it's **further** from the camera than all previously rendered geometry.</span></span> <span data-ttu-id="20f2b-315">두 번째로, 깊이 버퍼가 수정 되지 않도록 DepthWriteMask를 0으로 설정 합니다. 깊이 버퍼는 카메라와 **가장 가까운** 기 하 도형의 깊이를 계속 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-315">Second, set the DepthWriteMask to zero, so that the depth buffer won't be modified (the depth buffer should continue to represent the depth of the geometry **closest** to the camera).</span></span>

<span data-ttu-id="20f2b-316">공간 매핑 메시를 렌더링할 때 [성능은](../develop/platform-capabilities-and-apis/understanding-performance-for-mixed-reality.md) 중요 한 문제입니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-316">[Performance](../develop/platform-capabilities-and-apis/understanding-performance-for-mixed-reality.md) is an important concern when rendering spatial mapping meshes.</span></span> <span data-ttu-id="20f2b-317">다음은 공간 매핑 메시 렌더링과 관련 된 몇 가지 렌더링 성능 기술입니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-317">Here are some rendering performance techniques specific to rendering spatial mapping meshes:</span></span>
* <span data-ttu-id="20f2b-318">삼각형 밀도 조정</span><span class="sxs-lookup"><span data-stu-id="20f2b-318">Adjust triangle density</span></span>
   * <span data-ttu-id="20f2b-319">표면 관찰자 로부터 공간 표면 메시를 요청 하는 경우 요구 사항에 충분 한 삼각형 메시의 가장 낮은 밀도를 요청 합니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-319">When requesting spatial surface meshes from your surface observer, request the lowest density of triangle meshes that will suffice for your needs.</span></span>
   * <span data-ttu-id="20f2b-320">사용자의 표면 거리 및 사용자 환경에 대 한 관련성에 따라 표면의 표면에서 삼각형 밀도를 변경 하는 것이 적합할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-320">It may make sense to vary triangle density on a surface by surface basis, depending on the surface's distance from the user, and its relevance to the user experience.</span></span>
   * <span data-ttu-id="20f2b-321">삼각형 수를 줄이면 픽셀 처리 비용에 영향을 주지 않지만 GPU에서 메모리 사용량 및 꼭 짓 점 처리 비용이 줄어듭니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-321">Reducing triangle counts will reduce memory usage and vertex processing costs on the GPU, though it won't affect pixel processing costs.</span></span>
* <span data-ttu-id="20f2b-322">고르기 사용</span><span class="sxs-lookup"><span data-stu-id="20f2b-322">Use frustum culling</span></span>
   * <span data-ttu-id="20f2b-323">두 번째 고르기는 현재 표시의 외부에 있기 때문에 볼 수 없는 그리기 개체를 건너뜁니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-323">Frustum culling skips drawing objects that cannot be seen because they are outside the current display frustum.</span></span> <span data-ttu-id="20f2b-324">그러면 CPU와 GPU 처리 비용이 줄어듭니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-324">This reduces both CPU and GPU processing costs.</span></span>
   * <span data-ttu-id="20f2b-325">고르기는 메시 마다 수행 되 고 공간 표면은 클 수 있으므로 공간 표면이 클 수 있습니다. 각 공간 표면 메시를 작은 청크로 나누면 더 효율적인 고르기 (이 경우에는 더 적은 수의 스크린 된 삼각형이 렌더링 됨)가 생성 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-325">Since culling is performed on a per-mesh basis and spatial surfaces can be large, breaking each spatial surface mesh into smaller chunks may result in more efficient culling (in that fewer offscreen triangles are rendered).</span></span> <span data-ttu-id="20f2b-326">그러나 다음과 같은 단점이 있습니다. 메시가 많을 수록 더 많은 그리기 호출을 수행 해야 하므로 CPU 비용이 늘어날 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-326">There's a tradeoff, however; the more meshes you have, the more draw calls you must make, which can increase CPU costs.</span></span> <span data-ttu-id="20f2b-327">극단적인 경우에는 대/소문자 고르기 계산 자체에서 CPU 비용이 측정 될 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-327">In an extreme case, the frustum culling calculations themselves could even have a measurable CPU cost.</span></span>
* <span data-ttu-id="20f2b-328">렌더링 순서 조정</span><span class="sxs-lookup"><span data-stu-id="20f2b-328">Adjust rendering order</span></span>
   * <span data-ttu-id="20f2b-329">공간 표면은이를 둘러싼 사용자의 전체 환경을 나타내므로 공간 표면은 클 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-329">Spatial surfaces tend to be large, because they represent the user's entire environment surrounding them.</span></span> <span data-ttu-id="20f2b-330">GPU의 픽셀 처리 비용은 특히 표시 되는 기 하 도형 (공간 서피스와 기타 holograms 모두 포함)의 계층이 둘 이상 있는 경우에 매우 높을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-330">Pixel processing costs on the GPU can be high, especially in cases where there's more than one layer of visible geometry (including both spatial surfaces and other holograms).</span></span> <span data-ttu-id="20f2b-331">이 경우 사용자에 게 가장 가까운 계층은 모든 계층을 occluding 하 게 되므로 더 멀리 떨어져 있는 계층을 렌더링 하는 데 걸린 GPU 시간은 낭비 됩니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-331">In this case, the layer nearest to the user will be occluding any layers further away, so any GPU time spent rendering those more distant layers is wasted.</span></span>
   * <span data-ttu-id="20f2b-332">GPU에서 이러한 중복 작업을 줄이기 위해 불투명 표면을 앞에서 뒤로 순서로 렌더링 하는 데 도움이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-332">To reduce this redundant work on the GPU, it helps to render opaque surfaces in front-to-back order (closer ones first, more distant ones last).</span></span> <span data-ttu-id="20f2b-333">' 불투명 '은 [깊이 스텐실 상태](/windows/win32/api/d3d11/ns-d3d11-d3d11_depth_stencil_desc)에서 DepthWriteMask가 1로 설정 된 표면을 의미 합니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-333">By 'opaque' we mean surfaces for which the DepthWriteMask is set to one in your [depth-stencil state](/windows/win32/api/d3d11/ns-d3d11-d3d11_depth_stencil_desc).</span></span> <span data-ttu-id="20f2b-334">가장 가까운 서피스가 렌더링 되 면 GPU의 픽셀 프로세서에서 더 멀리 떨어져 있는 표면을 효율적으로 건너뛰도록 깊이 버퍼를 소수 대로 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-334">When the nearest surfaces are rendered, they'll prime the depth buffer so that more distant surfaces are efficiently skipped by the pixel processor on the GPU.</span></span>

## <a name="mesh-processing"></a><span data-ttu-id="20f2b-335">메시 처리</span><span class="sxs-lookup"><span data-stu-id="20f2b-335">Mesh Processing</span></span>

<span data-ttu-id="20f2b-336">응용 프로그램은 요구 사항에 맞게 공간 노출 메시에서 [다양 한 작업](spatial-mapping.md#mesh-processing) 을 수행 하려고 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-336">An application may want to do [various operations](spatial-mapping.md#mesh-processing) on spatial surface meshes to suit its needs.</span></span> <span data-ttu-id="20f2b-337">각 공간 표면 메시와 함께 제공 되는 인덱스 및 꼭 짓 점 데이터는 모든 최신 렌더링 Api에서 삼각형 메시를 렌더링 하는 데 사용 되는 [꼭 짓 점 및 인덱스 버퍼](/windows/win32/direct3d9/rendering-from-vertex-and-index-buffers) 와 동일한 익숙한 레이아웃을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-337">The index and vertex data provided with each spatial surface mesh uses the same familiar layout as the [vertex and index buffers](/windows/win32/direct3d9/rendering-from-vertex-and-index-buffers) that are used for rendering triangle meshes in all modern rendering APIs.</span></span> <span data-ttu-id="20f2b-338">그러나 기억해 야 할 한 가지 중요 한 사실은 공간 매핑 삼각형에 **시계 반대 방향 굴곡 순서가** 있다는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-338">However, one key fact to be aware of is that spatial mapping triangles have a **front-clockwise winding order**.</span></span> <span data-ttu-id="20f2b-339">각 삼각형은 메시의 인덱스 버퍼에서 3 개의 꼭 짓 점 인덱스로 표시 되 고, 이러한 인덱스는 삼각형이 **front** 에서 표시 되는 경우 **시계 방향** 으로 삼각형의 꼭 짓 점을 식별 합니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-339">Each triangle is represented by three vertex indices in the mesh's index buffer and these indices will identify the triangle's vertices in a **clockwise** order, when the triangle is viewed from the **front** side.</span></span> <span data-ttu-id="20f2b-340">공간 표면 망상의 전면 (또는 외부)은 실제 세계 표면의 정면 (표시)와 일치 하는 것으로 간주 됩니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-340">The front side (or outside) of spatial surface meshes corresponds as you would expect to the front (visible) side of real world surfaces.</span></span>

<span data-ttu-id="20f2b-341">Surface 관찰자가 제공 하는 coarsest 삼각형 밀도가 아직 불충분 않은 경우 응용 프로그램은 메시 단순화만 수행 해야 합니다 .이 작업은 계산 비용이 많이 들고 런타임에 의해 제공 되는 다양 한 세부 정보 수준을 생성 하는 데 이미 수행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-341">Applications should only do mesh simplification if the coarsest triangle density provided by the surface observer is still insufficiently coarse - this work is computationally expensive and already being performed by the runtime to generate the various provided levels of detail.</span></span>

<span data-ttu-id="20f2b-342">각 표면 관찰자는 연결 되지 않은 여러 공간 표면을 제공할 수 있으므로 일부 응용 프로그램은 이러한 공간 노출 영역 메시를 서로 클리핑 한 다음 함께 zipper 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-342">Because each surface observer can provide multiple unconnected spatial surfaces, some applications may wish to clip these spatial surface meshes against each other, then zipper them together.</span></span> <span data-ttu-id="20f2b-343">일반적으로 주변 공간 표면 메시가 약간 겹치면 일반적으로 클리핑 단계가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-343">In general, the clipping step is required, as nearby spatial surface meshes often overlap slightly.</span></span>

## <a name="raycasting-and-collision"></a><span data-ttu-id="20f2b-344">Raycasting 및 충돌</span><span class="sxs-lookup"><span data-stu-id="20f2b-344">Raycasting and Collision</span></span>

<span data-ttu-id="20f2b-345">물리 API (예: [Havok](https://www.havok.com/))가 공간 표면의 raycasting 및 충돌 기능을 제공 하는 응용 프로그램을 제공 하기 위해 응용 프로그램은 공간 노출 영역 메시를 물리학 API에 제공 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-345">In order for a physics API (such as [Havok](https://www.havok.com/)) to provide an application with raycasting and collision functionality for spatial surfaces, the application must provide spatial surface meshes to the physics API.</span></span> <span data-ttu-id="20f2b-346">물리학에 사용 되는 메시에는 종종 다음과 같은 속성이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-346">Meshes used for physics often have the following properties:</span></span>
* <span data-ttu-id="20f2b-347">적은 수의 삼각형만 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-347">They contain only small numbers of triangles.</span></span> <span data-ttu-id="20f2b-348">물리 연산은 렌더링 작업 보다 계산 집약적입니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-348">Physics operations are more computationally intensive than rendering operations.</span></span>
* <span data-ttu-id="20f2b-349">' 아주 좁게 ' 됩니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-349">They're 'water-tight'.</span></span> <span data-ttu-id="20f2b-350">Solid로 설계 된 표면에는 작은 구멍이 있어서는 안 됩니다. 표시 될 수 있을 정도로 작은 구멍이 있어도 문제가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-350">Surfaces intended to be solid shouldn't have small holes in them; even holes too small to be visible can cause problems.</span></span>
* <span data-ttu-id="20f2b-351">이러한 코드는 볼록 hulls로 변환 됩니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-351">They're converted into convex hulls.</span></span> <span data-ttu-id="20f2b-352">볼록 hulls는 약간의 다각형이 있으며 구멍이 없는 것 이며 원시 삼각형 메시 보다 처리 하기에 훨씬 더 많은 계산을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-352">Convex hulls have few polygons and are free of holes, and they're much more computationally efficient to process than raw triangle meshes.</span></span>

<span data-ttu-id="20f2b-353">공간 표면에 대해 raycasts를 수행 하는 경우 이러한 표면은 종종 복잡 하 고 복잡 한 모양이 약간 복잡 합니다 .이는 책상과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-353">When doing raycasts against spatial surfaces, bear in mind that these surfaces are often complex, cluttered shapes full of messy little details - just like your desk!</span></span> <span data-ttu-id="20f2b-354">즉, 단일 raycast가 화면 모양에 대 한 충분 한 정보와 근처의 빈 공간 셰이프를 제공 하기에 충분 하지 않은 경우가 많습니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-354">This means that a single raycast is often insufficient to give you enough information about the shape of the surface and the shape of the empty space near it.</span></span> <span data-ttu-id="20f2b-355">일반적으로 작은 영역 내에서 많은 raycasts를 수행 하 고 집계 결과를 사용 하 여 화면에 대 한 보다 안정적인 이해를 유도 하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-355">It's usually a good idea to do many raycasts within a small area and to use the aggregate results to derive a more reliable understanding of the surface.</span></span> <span data-ttu-id="20f2b-356">예를 들어, 화면에서 홀로그램 배치를 안내 하는 평균 10 개의 raycasts를 사용 하면 단일 raycasts를 사용 하는 훨씬 더 부드럽고 ' 떨림 ' 결과를 얻을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-356">For example, using the average of 10 raycasts to guide hologram placement on a surface will yield a far smoother and less 'jittery' result that using just a single raycast.</span></span>

<span data-ttu-id="20f2b-357">그러나 각 raycast에는 높은 계산 비용이 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-357">However, bear in mind that each raycast can have a high computational cost.</span></span> <span data-ttu-id="20f2b-358">사용 시나리오에 따라 공간 메시 (공간 메시가 업데이트 되는 경우 수행 됨)의 계산 비용을 사용 하 여 [메시 처리](spatial-mapping.md#mesh-processing) 의 계산 비용을 계산 하 여 공간 표면의 구멍을 매끄럽게 및 제거 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-358">Depending on your usage scenario, you should trade off the computational cost of extra raycasts (done every frame) against the computational cost of [mesh processing](spatial-mapping.md#mesh-processing) to smooth and remove holes in spatial surfaces (done when spatial meshes are updated).</span></span>

## <a name="the-environment-scanning-experience"></a><span data-ttu-id="20f2b-359">환경 검사 환경</span><span class="sxs-lookup"><span data-stu-id="20f2b-359">The environment scanning experience</span></span>

<span data-ttu-id="20f2b-360">공간 매핑을 사용 하는 각 응용 프로그램은 ' 스캔 환경 '을 제공 하는 것을 고려해 야 합니다. 응용 프로그램에서 응용 프로그램이 제대로 작동 하는 데 필요한 표면을 검색 하는 데 사용 하는 프로세스입니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-360">Each application that uses spatial mapping should consider providing a 'scanning experience'; the process through which the application guides the user to scan surfaces that are necessary for the application to function correctly.</span></span>

<span data-ttu-id="20f2b-361">![검색 예제](images/sr-mixedworld-140429-8pm-00068-1000px.png)</span><span class="sxs-lookup"><span data-stu-id="20f2b-361">![Example of scanning](images/sr-mixedworld-140429-8pm-00068-1000px.png)</span></span><br>
<span data-ttu-id="20f2b-362">*검색 예제*</span><span class="sxs-lookup"><span data-stu-id="20f2b-362">*Example of scanning*</span></span>

<span data-ttu-id="20f2b-363">이러한 검색 환경의 특성은 각 응용 프로그램의 요구 사항에 따라 크게 다를 수 있지만 두 가지 주요 원칙에 따라 디자인을 안내 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-363">The nature of this scanning experience can vary greatly depending upon each application's needs, but two main principles should guide its design.</span></span>

<span data-ttu-id="20f2b-364">첫째, **사용자와의 통신을 명확 하 게 하는 것이 중요** 합니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-364">Firstly, **clear communication with the user is the primary concern**.</span></span> <span data-ttu-id="20f2b-365">사용자는 항상 응용 프로그램의 요구 사항을 충족 하는지 여부를 알고 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-365">The user should always be aware of whether the application's requirements are being met.</span></span> <span data-ttu-id="20f2b-366">충족 되지 않는 경우 사용자에 게 즉시 명확 하 게 표시 되어야 하 고, 적절 한 조치를 취하는 데 신속 하 게 발생 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-366">When they aren't being met, it should be immediately clear to the user why this is so and they should be quickly led to take the appropriate action.</span></span>

<span data-ttu-id="20f2b-367">둘째, **응용 프로그램은 효율성과 안정성 간의 균형** 을 유지 하려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-367">Secondly, **applications should attempt to strike a balance between efficiency and reliability**.</span></span> <span data-ttu-id="20f2b-368">**안정적** 으로 수행할 수 있는 경우 응용 프로그램은 공간 매핑 데이터를 자동으로 분석 하 여 사용자 시간을 저장 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-368">When it's possible to do so **reliably**, applications should automatically analyze spatial mapping data to save the user time.</span></span> <span data-ttu-id="20f2b-369">안정적으로 수행할 수 없는 경우 응용 프로그램은 사용자가 응용 프로그램에 필요한 추가 정보를 신속 하 게 제공할 수 있도록 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-369">When it isn't possible to do so reliably, applications should instead enable the user to quickly provide the application with the additional information it requires.</span></span>

<span data-ttu-id="20f2b-370">적절 한 검색 환경을 디자인 하는 데 도움이 되도록 응용 프로그램에 적용할 수 있는 다음 가능성을 고려 합니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-370">To help design the right scanning experience, consider which of the following possibilities are applicable to your application:</span></span>

* <span data-ttu-id="20f2b-371">**검색 환경 없음**</span><span class="sxs-lookup"><span data-stu-id="20f2b-371">**No scanning experience**</span></span>
   * <span data-ttu-id="20f2b-372">응용 프로그램은 단계별 검사 환경을 사용 하지 않고 완벽 하 게 작동할 수 있습니다. 자연 스러운 사용자 이동 과정에서 관찰 되는 표면에 대해 알아봅니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-372">An application may function perfectly without any guided scanning experience; it will learn about surfaces that are observed in the course of natural user movement.</span></span>
   * <span data-ttu-id="20f2b-373">예를 들어 사용자가 holographic 스프레이 그림판을 사용 하 여 표면에 그릴 수 있도록 하는 응용 프로그램에는 현재 사용자에 게 표시 되는 표면에 대 한 정보만 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-373">For example, an application that lets the user draw on surfaces with holographic spray paint requires knowledge only of the surfaces currently visible to the user.</span></span>
   * <span data-ttu-id="20f2b-374">사용자가 HoloLens를 사용 하 여 이미 많은 시간을 사용한 경우 환경이 이미 검색 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-374">The environment may be scanned already if it's one in which the user has already spent lots of time using the HoloLens.</span></span>
   * <span data-ttu-id="20f2b-375">그러나 공간 매핑에 사용 되는 카메라는 사용자 앞에 3.1 m만 표시 될 수 있으므로, 사용자가 이전 보다 더 가까운 거리에서 관찰 한 적이 없으면 공간 매핑에서 더 멀리 떨어져 있는 표면을 인식 하지 못합니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-375">Bear in mind however that the camera used by spatial mapping can only see 3.1 m in front of the user, so spatial mapping won't know about any more distant surfaces unless the user has observed them from a closer distance in the past.</span></span>
   * <span data-ttu-id="20f2b-376">사용자가 검색 된 표면을 이해 하는 경우 응용 프로그램은 이러한 효과에 대 한 시각적 피드백을 제공 해야 합니다. 예를 들어 스캔 된 표면에 가상 그림자를 캐스팅 하면 사용자가 해당 화면에 holograms 하는 데 도움이 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-376">So the user understands which surfaces have been scanned, the application should provide visual feedback to this effect, for example casting virtual shadows onto scanned surfaces may help the user place holograms on those surfaces.</span></span>
   * <span data-ttu-id="20f2b-377">이 경우 공간 표면 관찰자의 경계 볼륨은 사용자를 따르기 위해 각 프레임을 본문 잠김 [공간 좌표계](coordinate-systems.md)로 업데이트 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-377">For this case, the spatial surface observer's bounding volumes should be updated each frame to a body-locked [spatial coordinate system](coordinate-systems.md), so that they follow the user.</span></span>

* <span data-ttu-id="20f2b-378">**적절 한 위치 찾기**</span><span class="sxs-lookup"><span data-stu-id="20f2b-378">**Find a suitable location**</span></span>
   * <span data-ttu-id="20f2b-379">응용 프로그램은 특정 요구 사항이 있는 위치에서 사용 하도록 디자인 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-379">An application may be designed for use in a location with specific requirements.</span></span>
   * <span data-ttu-id="20f2b-380">예를 들어 응용 프로그램은 holographic kung-fu를 안전 하 게 연습 하기 위해 사용자에 게 빈 영역을 요구할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-380">For example, the application may require an empty area around the user so they can safely practice holographic kung-fu.</span></span>
   * <span data-ttu-id="20f2b-381">응용 프로그램은 사용자에 게 모든 특정 요구 사항을 알리고 명확한 시각적 피드백을 통해 보강 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-381">Applications should communicate any specific requirements to the user up-front, and reinforce them with clear visual feedback.</span></span>
   * <span data-ttu-id="20f2b-382">이 예제에서 응용 프로그램은 필요한 빈 영역의 범위를 시각화 하 고이 영역 내에서 원치 않는 개체가 있는지 시각적으로 강조 표시 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-382">In this example, the application should visualize the extent of the required empty area and visually highlight the presence of any undesired objects within this zone.</span></span>
   * <span data-ttu-id="20f2b-383">이 경우 공간 표면 관찰자의 경계 볼륨은 선택한 위치에서 세계에서 잠긴 [공간 좌표계](coordinate-systems.md) 를 사용 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-383">For this case, the spatial surface observer's bounding volumes should use a world-locked [spatial coordinate system](coordinate-systems.md) in the chosen location.</span></span>

* <span data-ttu-id="20f2b-384">**적절 한 화면 구성 찾기**</span><span class="sxs-lookup"><span data-stu-id="20f2b-384">**Find a suitable configuration of surfaces**</span></span>
   * <span data-ttu-id="20f2b-385">응용 프로그램에는 특정 화면 구성 (예: 두 개의 크고 플랫, 반대 벽)이 필요 하 여 holographic 홀을 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-385">An application may require a specific configuration of surfaces, for example two large, flat, opposing walls to create a holographic hall of mirrors.</span></span>
   * <span data-ttu-id="20f2b-386">이러한 경우 응용 프로그램은 공간 매핑에서 제공 되는 표면을 분석 하 여 적절 한 표면을 검색 하 고 사용자에 게 전달 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-386">In such cases, the application will need to analyze the surfaces provided by spatial mapping to detect suitable surfaces, and direct the user toward them.</span></span>
   * <span data-ttu-id="20f2b-387">응용 프로그램의 surface 분석을 신뢰할 수 없는 경우 사용자에 게 대체 (fallback) 옵션이 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-387">The user should have a fallback option if the application's surface analysis isn't reliable.</span></span> <span data-ttu-id="20f2b-388">예를 들어 응용 프로그램이 이르는 길를 플랫 벽으로 잘못 식별 하는 경우 사용자에 게이 오류를 수정 하는 간단한 방법이 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-388">For example, if the application incorrectly identifies a doorway as a flat wall, the user needs a simple way to correct this error.</span></span>

* <span data-ttu-id="20f2b-389">**환경의 일부를 검색 합니다.**</span><span class="sxs-lookup"><span data-stu-id="20f2b-389">**Scan part of the environment**</span></span>
   * <span data-ttu-id="20f2b-390">응용 프로그램은 사용자의 지시에 따라 환경의 일부만 캡처할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-390">An application may wish to only capture part of the environment, as directed by the user.</span></span>
   * <span data-ttu-id="20f2b-391">예를 들어 응용 프로그램은 대화방의 일부를 검사 하 여 판매 하려는 가구에 대해 holographic 분류 된 광고를 게시할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-391">For example, the application scans part of a room so the user may post a holographic classified ad for furniture they wish to sell.</span></span>
   * <span data-ttu-id="20f2b-392">이 경우 응용 프로그램은 검색 하는 동안 사용자가 관찰 한 지역 내에서 공간 매핑 데이터를 캡처해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-392">In this case, the application should capture spatial mapping data within the regions observed by the user during their scan.</span></span>

* <span data-ttu-id="20f2b-393">**전체 대화방 스캔**</span><span class="sxs-lookup"><span data-stu-id="20f2b-393">**Scan the whole room**</span></span>
   * <span data-ttu-id="20f2b-394">응용 프로그램을 사용 하려면 사용자 뒤의 모든 화면을 포함 하 여 현재 대화방의 모든 화면을 검색 해야 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-394">An application may require a scan of all of the surfaces in the current room, including those behind the user.</span></span>
   * <span data-ttu-id="20f2b-395">예를 들어 게임에서 사용자가 Gulliver의 역할을 할 수 있습니다 .이는 모든 방향에서 가장 적은 수의 Lilliputians에 대 한 공 성함입니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-395">For example, a game may put the user in the role of Gulliver, under siege from hundreds of tiny Lilliputians approaching from all directions.</span></span>
   * <span data-ttu-id="20f2b-396">이러한 경우 응용 프로그램은 현재 방에서 이미 검색 된 표면의 수를 확인 하 고, 사용자의 응시를 통해 상당한 격차를 채우도록 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-396">In such cases, the application will need to determine how many of the surfaces in the current room have already been scanned, and direct the user's gaze to fill in significant gaps.</span></span>
   * <span data-ttu-id="20f2b-397">이 프로세스의 핵심은 아직 검색 되지 않은 화면을 사용자에 게 명확 하 게 표시 하는 시각적 피드백을 제공 하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-397">The key to this process is providing visual feedback that makes it clear to the user which surfaces haven't yet been scanned.</span></span> <span data-ttu-id="20f2b-398">예를 들어, 응용 프로그램은 [거리 기반 안개](/windows/win32/direct3d9/fog-formulas) 를 사용 하 여 공간 매핑 화면에서 다루지 않는 영역을 시각적으로 강조 표시할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-398">The application could, for example,  use [distance-based fog](/windows/win32/direct3d9/fog-formulas) to visually highlight regions that aren't covered by spatial mapping surfaces.</span></span>

* <span data-ttu-id="20f2b-399">**환경에 대 한 초기 스냅숏 만들기**</span><span class="sxs-lookup"><span data-stu-id="20f2b-399">**Take an initial snapshot of the environment**</span></span>
   * <span data-ttu-id="20f2b-400">응용 프로그램은 초기 ' 스냅숏 '을 수행한 후 환경의 모든 변경 내용을 무시 하려고 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-400">An application may wish to ignore all changes in the environment after taking an initial 'snapshot'.</span></span>
   * <span data-ttu-id="20f2b-401">이는 환경의 초기 상태와 긴밀 하 게 연결 되는 사용자가 만든 데이터의 중단을 방지 하는 데 적합할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-401">This may be appropriate to avoid disruption of user-created data that is tightly coupled to the initial state of the environment.</span></span>
   * <span data-ttu-id="20f2b-402">이 경우 응용 프로그램은 검색이 완료 된 후 초기 상태에서 공간 매핑 데이터의 복사본을 만들어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-402">In this case, the application should make a copy of the spatial mapping data in its initial state once the scan is complete.</span></span>
   * <span data-ttu-id="20f2b-403">환경에서 holograms를 올바르게 폐색 하는 경우 응용 프로그램은 공간 매핑 데이터에 대 한 업데이트를 계속 수신 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-403">Applications should continue receiving updates to spatial mapping data if holograms are still to be correctly occluded by the environment.</span></span>
   * <span data-ttu-id="20f2b-404">공간 매핑 데이터를 지속적으로 업데이트 하 여 발생 한 모든 변경 내용을 시각화할 수 있으며, 환경의 이전 상태와 현재 상태 간의 차이를 명확 하 게 이해 하기도 합니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-404">Continued updates to spatial mapping data also allow visualizing any changes that have occurred, clarifying to the user the differences between prior and present states of the environment.</span></span>

* <span data-ttu-id="20f2b-405">**사용자가 시작한 환경의 스냅숏 만들기**</span><span class="sxs-lookup"><span data-stu-id="20f2b-405">**Take user-initiated snapshots of the environment**</span></span>
   * <span data-ttu-id="20f2b-406">응용 프로그램은 사용자가 지시 하는 경우 환경 변경 내용에만 응답할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-406">An application may only wish to respond to environmental changes when instructed by the user.</span></span>
   * <span data-ttu-id="20f2b-407">예를 들어 사용자는 다른 순간에 포즈를 캡처하여 friend의 여러 3D ' 동상 '을 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-407">For example, the user could create multiple 3D 'statues' of a friend by capturing their poses at different moments.</span></span>

* <span data-ttu-id="20f2b-408">**사용자가 환경을 변경할 수 있도록 허용**</span><span class="sxs-lookup"><span data-stu-id="20f2b-408">**Allow the user to change the environment**</span></span>
   * <span data-ttu-id="20f2b-409">응용 프로그램은 사용자 환경에서 변경 된 내용에 대해 실시간으로 응답 하도록 디자인 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-409">An application may be designed to respond in real time to any changes made in the user's environment.</span></span>
   * <span data-ttu-id="20f2b-410">예를 들어 방식을를 그리는 사용자는 다른 쪽에서 발생 하는 holographic play에 대해 ' 장면 변경 '을 트리거할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-410">For example, the user drawing a curtain could trigger 'scene change' for a holographic play taking place on the other side.</span></span>

* <span data-ttu-id="20f2b-411">**공간 매핑 데이터의 오류를 방지 하기 위해 사용자에 게 안내**</span><span class="sxs-lookup"><span data-stu-id="20f2b-411">**Guide the user to avoid errors in the spatial mapping data**</span></span>
   * <span data-ttu-id="20f2b-412">응용 프로그램에서 환경을 검색 하는 동안 사용자에 게 지침을 제공 하고자 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-412">An application may wish to provide guidance to the user while they're scanning their environment.</span></span>
   * <span data-ttu-id="20f2b-413">이렇게 하면 사용자가 sunlit windows 또는 미러를 사용 하는 등의 방법으로 [공간 매핑 데이터에서](spatial-mapping.md#what-influences-spatial-mapping-quality)특정 유형의 오류를 방지할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-413">This can help the user to avoid certain kinds of [errors in the spatial mapping data](spatial-mapping.md#what-influences-spatial-mapping-quality), for example by staying away from sunlit windows or mirrors.</span></span>

<span data-ttu-id="20f2b-414">유의 해야 할 추가 정보 중 하나는 공간 매핑 데이터의 ' 범위 '에 제한이 없다는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-414">One extra detail to be aware of is that the 'range' of spatial mapping data isn't unlimited.</span></span> <span data-ttu-id="20f2b-415">공간 매핑이 큰 공간의 영구 데이터베이스를 작성 하는 동안에는 사용자가 제한 된 크기의 ' 거품형 '에서 응용 프로그램에만 데이터를 사용할 수 있도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-415">While spatial mapping does build a permanent database of large spaces, it only makes that data available to applications in a 'bubble' of limited size around the user.</span></span> <span data-ttu-id="20f2b-416">긴 어느의 시작 부분에서 시작 하 여 시작 부분에서 멀리 떨어진 곳에서 시작 하는 경우 결국 공간 서피스가 다시 시작 부분에서 사라집니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-416">If you start at the beginning of a long corridor and walk far enough away from the start, then eventually the spatial surfaces back at the beginning will disappear.</span></span> <span data-ttu-id="20f2b-417">사용 가능한 공간 매핑 데이터에서 사라진 후에 응용 프로그램에서 해당 표면을 캐싱하여이를 완화할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-417">You can mitigate this by caching those surfaces in your application after they've disappeared from the available spatial mapping data.</span></span>

## <a name="mesh-processing"></a><span data-ttu-id="20f2b-418">메시 처리</span><span class="sxs-lookup"><span data-stu-id="20f2b-418">Mesh processing</span></span>

<span data-ttu-id="20f2b-419">이를 통해 표면에서 일반적인 오류 유형을 검색 하 고 공간 매핑 데이터를 적절 하 게 필터링, 제거 또는 수정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-419">It may help to detect common types of errors in surfaces and to filter, remove or modify the spatial mapping data as appropriate.</span></span>

<span data-ttu-id="20f2b-420">공간 매핑 데이터는 실제 표면에 최대한 적합 되도록 하기 위한 것 이므로, 모든 처리를 통해 ' 참 '에서 화면을 이동 하는 위험을 적용 합니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-420">Bear in mind that spatial mapping data is intended to be as faithful as possible to real-world surfaces, so any processing you apply risks shifting your surfaces further from the 'truth'.</span></span>

<span data-ttu-id="20f2b-421">다음은 유용 하 게 사용할 수 있는 여러 유형의 메시 처리에 대 한 몇 가지 예입니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-421">Here are some examples of different types of mesh processing that you may find useful:</span></span>

* <span data-ttu-id="20f2b-422">**구멍 채우기**</span><span class="sxs-lookup"><span data-stu-id="20f2b-422">**Hole filling**</span></span>
   * <span data-ttu-id="20f2b-423">어두운 재질의 작은 개체가 스캔 되지 않으면 주변 화면에 구멍이 남습니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-423">If a small object made of a dark material fails to scan, it will leave a hole in the surrounding surface.</span></span>
   * <span data-ttu-id="20f2b-424">구멍은 폐색에 영향을 줍니다. holograms은 임의의 불투명 실제 표면에서 ' ~ ' 구멍을 볼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-424">Holes affect occlusion: holograms can be seen 'through' a hole in a supposedly opaque real-world surface.</span></span>
   * <span data-ttu-id="20f2b-425">결함은 raycasts에 영향을 줍니다. raycasts를 사용 하 여 사용자가 서피스와 상호 작용 하는 데 도움이 되는 경우 이러한 광선을 통해 구멍이 전달 되는 것이 바람직하지 않을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-425">Holes affect raycasts: if you're using raycasts to help users interact with surfaces, it may be undesirable for these rays to pass through holes.</span></span> <span data-ttu-id="20f2b-426">한 가지 완화 방법은 적절 한 크기의 영역을 포함 하는 여러 raycasts 번들을 사용 하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-426">One mitigation is to use a bundle of multiple raycasts covering an appropriately sized region.</span></span> <span data-ttu-id="20f2b-427">이를 통해 ' 이상 값 ' 결과를 필터링 할 수 있습니다 .이 경우 한 가지 raycast가 작은 구멍을 통과 하더라도 집계 결과는 계속 유효 합니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-427">This will allow you to filter 'outlier' results, so that even if one raycast passes through a small hole, the aggregate result will still be valid.</span></span> <span data-ttu-id="20f2b-428">그러나이 방법은 계산 비용으로 제공 됩니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-428">However, this approach comes at a computational cost.</span></span>
   * <span data-ttu-id="20f2b-429">구멍은 물리학 충돌에 영향을 줍니다. 물리학 시뮬레이션으로 제어 되는 개체는 바닥의 구멍을 통해 삭제 되 고 손실 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-429">Holes affect physics collisions: an object controlled by physics simulation may drop through a hole in the floor and become lost.</span></span>
   * <span data-ttu-id="20f2b-430">표면 메시에서 이러한 구멍을 알고리즘 방식으로 채울 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-430">It's possible to algorithmically fill such holes in the surface mesh.</span></span> <span data-ttu-id="20f2b-431">그러나 windows 및 doorways 같은 ' 실제 구멍 '이 채워지지 않도록 알고리즘을 조정 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-431">However, you'll need to tune your algorithm so that 'real holes' such as windows and doorways don't get filled in.</span></span> <span data-ttu-id="20f2b-432">' 실제 구멍 '을 ' 허수 구멍 '과 안정적으로 구분 하는 것이 어려울 수 있으므로 ' 크기 ' 및 ' 경계 모양 '과 같은 다른 추론을 사용해 보아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-432">It can be difficult to reliably differentiate 'real holes' from 'imaginary holes', so you'll need to experiment with different heuristics such as 'size' and 'boundary shape'.</span></span>

* <span data-ttu-id="20f2b-433">**Hallucination 제거**</span><span class="sxs-lookup"><span data-stu-id="20f2b-433">**Hallucination removal**</span></span>
   * <span data-ttu-id="20f2b-434">반사, 밝은 조명 및 이동 개체는 약간의 느린 ' hallucinations ' 부동을 중간에 벗어날 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-434">Reflections, bright lights, and moving objects can leave small lingering 'hallucinations' floating in mid-air.</span></span>
   * <span data-ttu-id="20f2b-435">Hallucinations에 영향을 주는 폐색: Hallucinations는 및 occluding 다른 holograms의 앞으로 이동 하는 짙은 모양으로 표시 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-435">Hallucinations affect occlusion: hallucinations may become visible as dark shapes moving in front of and occluding other holograms.</span></span>
   * <span data-ttu-id="20f2b-436">Hallucinations는 raycasts에 영향을 줍니다. raycasts를 사용 하 여 사용자가 서피스와 상호 작용할 수 있도록 하는 경우 이러한 광선은 그 뒤의 표면 대신 hallucination에 도달할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-436">Hallucinations affect raycasts: if you're using raycasts to help users interact with surfaces, these rays could hit a hallucination instead of the surface behind it.</span></span> <span data-ttu-id="20f2b-437">구멍에서와 마찬가지로 한 가지 완화는 단일 raycasts 대신 많은 raycasts를 사용 하는 것 이지만, 다시이 경우 계산 비용이 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-437">As with holes, one mitigation is to use many raycasts instead of a single raycast, but again this will come at a computational cost.</span></span>
   * <span data-ttu-id="20f2b-438">Hallucinations는 물리학 충돌에 영향을 줍니다. 물리학 시뮬레이션에 의해 제어 되는 개체는 hallucination에 대해 중지 될 수 있으며, 빈 영역을 통해 이동할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-438">Hallucinations affect physics collisions: an object controlled by physics simulation may become stuck against a hallucination and be unable to move through a seemingly clear area of space.</span></span>
   * <span data-ttu-id="20f2b-439">Surface 메시에서 이러한 hallucinations를 필터링 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-439">It's possible to filter such hallucinations from the surface mesh.</span></span> <span data-ttu-id="20f2b-440">그러나 구멍과 마찬가지로 램프와 도어 핸들 등의 실제 작은 개체가 제거 되지 않도록 알고리즘을 조정 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-440">However, as with holes, you'll need to tune your algorithm so that real small objects such as lamp-stands and door handles don't get removed.</span></span>

* <span data-ttu-id="20f2b-441">**다듬기**</span><span class="sxs-lookup"><span data-stu-id="20f2b-441">**Smoothing**</span></span>
   * <span data-ttu-id="20f2b-442">공간 매핑은 실제 요소와 비교 하 여 황삭 또는 ' 잡음 '으로 표시 되는 표면을 반환할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-442">Spatial mapping may return surfaces that appear to be rough or 'noisy' in comparison to their real-world counterparts.</span></span>
   * <span data-ttu-id="20f2b-443">다듬기는 물리학 충돌에 영향을 줍니다. 바닥이 거칠게 되 면 실제로 시뮬레이션 된 golf 공이 직선으로이를 통해 원활 하 게 롤오버 되지 않을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-443">Smoothness affects physics collisions: if the floor is rough, a physically simulated golf ball may not roll smoothly across it in a straight line.</span></span>
   * <span data-ttu-id="20f2b-444">다듬기는 렌더링에 영향을 줍니다. 표면이 직접 시각화 되는 경우 대략적인 표면 법선은 해당 모양에 영향을 줄 수 있으며 ' 정리 ' 모양을 방해 합니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-444">Smoothness affects rendering: if a surface is visualized directly, rough surface normals can affect its appearance and disrupt a 'clean' look.</span></span> <span data-ttu-id="20f2b-445">화면을 렌더링 하는 데 사용 되는 셰이더에 적절 한 조명 및 질감을 사용 하 여이를 완화할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-445">It's possible to mitigate this by using appropriate lighting and textures in the shader that is used to render the surface.</span></span>
   * <span data-ttu-id="20f2b-446">표면 메시에서 황삭을 매끄럽게 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-446">It's possible to smooth out roughness in a surface mesh.</span></span> <span data-ttu-id="20f2b-447">그러나이로 인해 해당 하는 실제 화면에서 화면을 벗어날 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-447">However, this may push the surface further away from the corresponding real-world surface.</span></span> <span data-ttu-id="20f2b-448">근접 한 일치를 유지 하는 것은 정확한 홀로그램 폐색을 생성 하 고 사용자가 holographic 서피스와 정확 하 고 예측 가능한 상호 작용을 달성할 수 있도록 하는 데 중요 합니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-448">Maintaining a close correspondence is important to produce accurate hologram occlusion, and to enable users to achieve precise and predictable interactions with holographic surfaces.</span></span>
   * <span data-ttu-id="20f2b-449">코스메틱 변경만 필요한 경우 꼭 짓 점 위치를 변경 하지 않고 꼭 짓 점 법선을 사용 하는 것이 충분할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-449">If only a cosmetic change is required, it may be sufficient to smooth vertex normals without changing vertex positions.</span></span>

* <span data-ttu-id="20f2b-450">**평면 찾기**</span><span class="sxs-lookup"><span data-stu-id="20f2b-450">**Plane finding**</span></span>
   * <span data-ttu-id="20f2b-451">응용 프로그램이 공간 매핑에서 제공 된 표면에서 수행 하려는 많은 형태의 분석이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-451">There are many forms of analysis that an application may wish to perform on the surfaces provided by spatial mapping.</span></span>
   * <span data-ttu-id="20f2b-452">간단한 한 가지 예는 ' 평면 찾기 '입니다. 주로 표면의 평면 영역 경계를 식별 합니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-452">One simple example is 'plane finding'; identifying bounded, mostly planar regions of surfaces.</span></span>
   * <span data-ttu-id="20f2b-453">평면 지역은 응용 프로그램에서 holographic 콘텐츠를 자동으로 배치할 수 있는 holographic 작업 영역으로 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-453">Planar regions can be used as holographic work-surfaces, regions where holographic content can be automatically placed by the application.</span></span>
   * <span data-ttu-id="20f2b-454">평면 지역은 사용자 인터페이스를 제한할 수 있으므로 사용자가 요구 사항에 가장 적합 한 서피스와 상호 작용 하도록 안내 합니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-454">Planar regions can constrain the user interface, to guide users to interact with the surfaces that best suit their needs.</span></span>
   * <span data-ttu-id="20f2b-455">평면 영역을 실제 세계와 같이 사용 하 여 LCD 화면, 테이블 또는 화이트 보드와 같은 기능 개체에 대 한 holographic 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-455">Planar regions can be used as in the real world, for holographic counterparts to functional objects such as LCD screens, tables or whiteboards.</span></span>
   * <span data-ttu-id="20f2b-456">평면 지역은 재생 영역을 정의 하 여 비디오 게임 수준의 기반을 형성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-456">Planar regions can define play areas, forming the basis of video game levels.</span></span>
   * <span data-ttu-id="20f2b-457">평면 지역은 실제 사람들이 살펴볼 가능성이 높은 영역을 식별 하 여 가상 에이전트가 실제 세계를 탐색 하는 데 도움이 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-457">Planar regions can aid virtual agents to navigate the real world, by identifying the areas of floor that real people are likely to walk on.</span></span>

## <a name="prototyping-and-debugging"></a><span data-ttu-id="20f2b-458">프로토타입 및 디버깅</span><span class="sxs-lookup"><span data-stu-id="20f2b-458">Prototyping and debugging</span></span>

### <a name="useful-tools"></a><span data-ttu-id="20f2b-459">유용한 도구</span><span class="sxs-lookup"><span data-stu-id="20f2b-459">Useful tools</span></span>

* <span data-ttu-id="20f2b-460">[Hololens 에뮬레이터](../develop/platform-capabilities-and-apis/using-the-hololens-emulator.md) 는 실제 hololens에 액세스 하지 않고 공간 매핑을 사용 하 여 응용 프로그램을 개발 하는 데 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-460">The [HoloLens emulator](../develop/platform-capabilities-and-apis/using-the-hololens-emulator.md) can be used to develop applications using spatial mapping without access to a physical HoloLens.</span></span> <span data-ttu-id="20f2b-461">이 기능을 사용 하면 응용 프로그램에서 일반적으로 사용 하는 모든 데이터 (HoloLens 동작, 공간 좌표계 및 공간 매핑 메시 포함)를 사용 하 여 실제 환경에서 HoloLens의 라이브 세션을 시뮬레이션할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-461">It allows you to simulate a live session on a HoloLens in a realistic environment, with all of the data your application would normally consume, including HoloLens motion, spatial coordinate systems, and spatial mapping meshes.</span></span> <span data-ttu-id="20f2b-462">이는 문제를 디버깅 하 고 코드에 대 한 변경 사항을 평가 하는 데 유용할 수 있는 안정적이 고 반복 가능한 입력을 제공 하는 데 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-462">This can be used to provide reliable, repeatable input, which can be useful for debugging problems and evaluating changes to your code.</span></span>
* <span data-ttu-id="20f2b-463">시나리오를 재현 하려면 라이브 HoloLens에서 네트워크를 통해 공간 매핑 데이터를 캡처한 다음 디스크에 저장 하 고 나중에 디버깅 세션에서 다시 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-463">To reproduce a scenario, capture spatial mapping data over the network from a live HoloLens, then save it to disk and reuse it in later debugging sessions.</span></span>
* <span data-ttu-id="20f2b-464">[Windows 장치 포털 3d 보기](../develop/platform-capabilities-and-apis/using-the-windows-device-portal.md#3d-view) 에서는 공간 매핑 시스템을 통해 현재 사용할 수 있는 모든 공간 표면을 볼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-464">The [Windows device portal 3D view](../develop/platform-capabilities-and-apis/using-the-windows-device-portal.md#3d-view) provides a way to see all of the spatial surfaces currently available via the spatial mapping system.</span></span> <span data-ttu-id="20f2b-465">이는 응용 프로그램 내부의 공간 표면의 비교를 기반으로 합니다. 예를 들어 공간 서피스가 누락 되었거나 잘못 된 장소에 표시 되는지 쉽게 알 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-465">This provides a basis of comparison for the spatial surfaces inside your application; for example, you can easily tell if any spatial surfaces are missing or are being displayed in the wrong place.</span></span>

### <a name="general-prototyping-guidance"></a><span data-ttu-id="20f2b-466">일반 프로토타입 지침</span><span class="sxs-lookup"><span data-stu-id="20f2b-466">General prototyping guidance</span></span>

* <span data-ttu-id="20f2b-467">공간 매핑 데이터의 [오류](spatial-mapping.md#what-influences-spatial-mapping-quality) 는 사용자의 환경에 크게 영향을 줄 수 있으므로 다양 한 환경에서 응용 프로그램을 테스트 하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-467">Because [errors](spatial-mapping.md#what-influences-spatial-mapping-quality) in the spatial mapping data may strongly affect your user's experience, we recommend that you test your application in a wide variety of environments.</span></span>
* <span data-ttu-id="20f2b-468">동일한 위치 (예: 책상)에서 항상 테스트를 시작 하는 습관을 제공 하지 마세요.</span><span class="sxs-lookup"><span data-stu-id="20f2b-468">Don't get trapped in the habit of always testing in the same location, for example at your desk.</span></span> <span data-ttu-id="20f2b-469">다양 한 위치, 도형, 크기 및 재질의 여러 표면에서 테스트 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-469">Make sure to test on various surfaces of different positions, shapes, sizes, and materials.</span></span>
* <span data-ttu-id="20f2b-470">이와 유사 하 게, 가상 또는 기록 된 데이터는 디버깅에 유용할 수 있지만, 동일한 테스트 사례에는 의존 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-470">Similarly, while synthetic or recorded data can be useful for debugging, don't become too reliant upon the same few test cases.</span></span> <span data-ttu-id="20f2b-471">이렇게 하면 더 다양 한 테스트에서 이전에 발견 한 중요 한 문제 찾기가 지연 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-471">This may delay finding important issues that more varied testing would have caught earlier.</span></span>
* <span data-ttu-id="20f2b-472">실제 (그리고 이상적으로는 uncoached) 사용자를 사용 하 여 테스트를 수행 하는 것이 가장 좋은 방법으로 HoloLens 또는 응용 프로그램을 사용 하지 못할 수 있으므로 테스트를 수행 하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-472">It's a good idea to perform testing with real (and ideally uncoached) users, because they may not use the HoloLens or your application in exactly the same way that you do.</span></span> <span data-ttu-id="20f2b-473">실제로 사용자의 행동, 기술 자료 및 가정이 어떻게 될 수 있는지를 예상할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-473">In fact, it may surprise you how divergent people's behavior, knowledge, and assumptions can be!</span></span>

## <a name="troubleshooting"></a><span data-ttu-id="20f2b-474">문제 해결</span><span class="sxs-lookup"><span data-stu-id="20f2b-474">Troubleshooting</span></span>

* <span data-ttu-id="20f2b-475">표면 메시를 올바르게 지향 하려면 각 GameObject가 활성 상태 여야 메시를 생성 하기 위해 SurfaceObserver에 전송 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-475">In order for the surface meshes to be orientated correctly, each GameObject needs to be active before it's sent to the SurfaceObserver to have its mesh constructed.</span></span> <span data-ttu-id="20f2b-476">그렇지 않으면 메시는 공간에 표시 되지만 이상한 각도로 회전 됩니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-476">Otherwise, the meshes will show up in your space but rotated at weird angles.</span></span>
* <span data-ttu-id="20f2b-477">SurfaceObserver와 통신 하는 스크립트를 실행 하는 GameObject를 원본으로 설정 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-477">The GameObject that runs the script that communicates with the SurfaceObserver needs to be set to the origin.</span></span> <span data-ttu-id="20f2b-478">그렇지 않으면 사용자가 만들고 SurfaceObserver에 전송 하 여 메시를 생성 하는 모든 Gameobject 부모 게임 개체의 오프셋과 동일한 오프셋을 갖게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-478">Otherwise, all of GameObjects that you create and send to the SurfaceObserver to have their meshes constructed will have an offset equal to the offset of the Parent Game Object.</span></span> <span data-ttu-id="20f2b-479">이렇게 하면 메시를 몇 미터 떨어진 상태로 표시 하 여 진행 상황을 디버그 하기가 어려울 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20f2b-479">This can make your meshes show up several meters away, which makes it hard to debug what is going on.</span></span>

## <a name="see-also"></a><span data-ttu-id="20f2b-480">참고 항목</span><span class="sxs-lookup"><span data-stu-id="20f2b-480">See also</span></span>

* [<span data-ttu-id="20f2b-481">좌표계</span><span class="sxs-lookup"><span data-stu-id="20f2b-481">Coordinate systems</span></span>](coordinate-systems.md)
* [<span data-ttu-id="20f2b-482">DirectX의 공간 매핑</span><span class="sxs-lookup"><span data-stu-id="20f2b-482">Spatial mapping in DirectX</span></span>](../develop/native/spatial-mapping-in-directx.md)
* [<span data-ttu-id="20f2b-483">Unity의 공간 매핑</span><span class="sxs-lookup"><span data-stu-id="20f2b-483">Spatial mapping in Unity</span></span>](../develop/unity/spatial-mapping-in-unity.md)
* [<span data-ttu-id="20f2b-484">장면 이해</span><span class="sxs-lookup"><span data-stu-id="20f2b-484">Scene Understanding</span></span>](scene-understanding.md)
* [<span data-ttu-id="20f2b-485">실내 스캔 시각화</span><span class="sxs-lookup"><span data-stu-id="20f2b-485">Room scan visualization</span></span>](room-scan-visualization.md)
* [<span data-ttu-id="20f2b-486">공간 음향 디자인</span><span class="sxs-lookup"><span data-stu-id="20f2b-486">Spatial sound design</span></span>](spatial-sound-design.md)
* [<span data-ttu-id="20f2b-487">사례 연구 - 현실의 구멍 속 살펴보기</span><span class="sxs-lookup"><span data-stu-id="20f2b-487">Case study - Looking through holes in your reality</span></span>](../out-of-scope/case-study-looking-through-holes-in-your-reality.md)