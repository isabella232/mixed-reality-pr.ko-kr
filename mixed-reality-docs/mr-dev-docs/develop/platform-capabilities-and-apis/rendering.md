---
title: 렌더링
description: Holographic 렌더링을 사용 하면 응용 프로그램이 실제 세계에 정확 하 게 배치 되었는지 아니면 사용자가 만든 가상 영역 내에서 정확 하 게 배치 되었는지 여부에 관계 없이 사용자를 대상으로 하는 위치에서 홀로그램을 그릴 수 있습니다.
author: thetuvix
ms.author: alexturn
ms.date: 02/24/2019
ms.topic: article
keywords: 렌더링, 홀로그램
ms.openlocfilehash: 3bc882df8ec43fc188bae521a95ff91e5a59573c
ms.sourcegitcommit: 09599b4034be825e4536eeb9566968afd021d5f3
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 10/03/2020
ms.locfileid: "91684985"
---
# <a name="rendering"></a><span data-ttu-id="81e46-104">렌더링</span><span class="sxs-lookup"><span data-stu-id="81e46-104">Rendering</span></span>

<span data-ttu-id="81e46-105">Holographic 렌더링을 사용 하면 응용 프로그램이 실제 세계에 정확 하 게 배치 되었는지 아니면 사용자가 만든 가상 영역 내에서 정확 하 게 배치 되었는지 여부에 관계 없이 사용자를 대상으로 하는 위치에서 홀로그램을 그릴 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="81e46-105">Holographic rendering enables your application to draw a hologram at a precise location in the world around the user, whether it's precisely placed in the physical world or within a virtual realm you've created.</span></span> <span data-ttu-id="81e46-106">[Holograms](../../discover/hologram.md) 는 소리 및 조명의 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="81e46-106">[Holograms](../../discover/hologram.md) are objects made of sound and light.</span></span> <span data-ttu-id="81e46-107">렌더링을 사용 하면 응용 프로그램에서 조명을 추가할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="81e46-107">Rendering enables your application to add the light.</span></span>

## <a name="device-support"></a><span data-ttu-id="81e46-108">디바이스 지원</span><span class="sxs-lookup"><span data-stu-id="81e46-108">Device support</span></span>

<table>
    <colgroup>
    <col width="25%" />
    <col width="25%" />
    <col width="25%" />
    <col width="25%" />
    </colgroup>
    <tr>
        <td><span data-ttu-id="81e46-109"><strong>기능</strong></span><span class="sxs-lookup"><span data-stu-id="81e46-109"><strong>Feature</strong></span></span></td>
        <td><span data-ttu-id="81e46-110"><a href="../../hololens-hardware-details.md"><strong>HoloLens(1세대)</strong></a></span><span class="sxs-lookup"><span data-stu-id="81e46-110"><a href="../../hololens-hardware-details.md"><strong>HoloLens (1st gen)</strong></a></span></span></td>
        <td><span data-ttu-id="81e46-111"><a href="https://docs.microsoft.com/hololens/hololens2-hardware"><strong>HoloLens 2</strong></span><span class="sxs-lookup"><span data-stu-id="81e46-111"><a href="https://docs.microsoft.com/hololens/hololens2-hardware"><strong>HoloLens 2</strong></span></span></td>
        <td><span data-ttu-id="81e46-112"><a href="../../discover/immersive-headset-hardware-details.md"><strong>몰입형 헤드셋</strong></a></span><span class="sxs-lookup"><span data-stu-id="81e46-112"><a href="../../discover/immersive-headset-hardware-details.md"><strong>Immersive headsets</strong></a></span></span></td>
    </tr>
     <tr>
        <td><span data-ttu-id="81e46-113">렌더링</span><span class="sxs-lookup"><span data-stu-id="81e46-113">Rendering</span></span></td>
        <td><span data-ttu-id="81e46-114">✔️</span><span class="sxs-lookup"><span data-stu-id="81e46-114">✔️</span></span></td>
        <td><span data-ttu-id="81e46-115">✔️</span><span class="sxs-lookup"><span data-stu-id="81e46-115">✔️</span></span></td>
        <td><span data-ttu-id="81e46-116">✔️</span><span class="sxs-lookup"><span data-stu-id="81e46-116">✔️</span></span></td>
    </tr>
</table>

## <a name="holographic-rendering"></a><span data-ttu-id="81e46-117">홀로그램 렌더링</span><span class="sxs-lookup"><span data-stu-id="81e46-117">Holographic rendering</span></span>

<span data-ttu-id="81e46-118">Holographic 렌더링의 핵심은 사용자에 게 실제 세계와 holograms를 함께 볼 수 있도록 하는 HoloLens와 같은 보기 표시로 렌더링 하는지 아니면 전 세계를 차단 하는 Windows Mixed Reality 몰입 형 헤드셋과 같은 불투명 한 표시를 표시 하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="81e46-118">Key to holographic rendering is knowing whether you are rendering to a see-through display like HoloLens that lets the user see both the physical world and your holograms together, or an opaque display like a Windows Mixed Reality immersive headset that blocks out the world.</span></span>

<span data-ttu-id="81e46-119">[HoloLens](../../hololens-hardware-details.md)와 같이 표시 되는 **디스플레이** 를 사용 하는 장치는 세계에 조명을 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="81e46-119">Devices with **see-through displays** , such as [HoloLens](../../hololens-hardware-details.md), add light to the world.</span></span> <span data-ttu-id="81e46-120">검은색 픽셀은 완전히 투명 하지만 밝은 픽셀은 점차 불투명 합니다.</span><span class="sxs-lookup"><span data-stu-id="81e46-120">Black pixels are fully transparent, while brighter pixels are increasingly opaque.</span></span> <span data-ttu-id="81e46-121">디스플레이의 조명이 실제 세계의 조명에 추가 되기 때문에 흰색 픽셀은 약간 반투명 합니다.</span><span class="sxs-lookup"><span data-stu-id="81e46-121">Because the light from the displays is added to the light from the real world, white pixels are somewhat translucent.</span></span>

<span data-ttu-id="81e46-122">Stereoscopic 렌더링은 holograms에 대 한 깊이 있는 한 가지 큐를 제공 하는 반면, [접지 효과](../../design/interaction-fundamentals.md) 를 추가 하면 홀로그램이 가까이 있는 표면을 더 쉽게 볼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="81e46-122">While stereoscopic rendering provides one depth cue for your holograms, adding [grounding effects](../../design/interaction-fundamentals.md) can help users see more easily what surface a hologram is near.</span></span> <span data-ttu-id="81e46-123">한 가지 접지 기술은 근처 표면에서 홀로그램 주위에 광선을 추가한 다음이 광선에 대해 그림자를 렌더링 하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="81e46-123">One grounding technique is to add a glow around a hologram on the nearby surface, and then render a shadow against this glow.</span></span> <span data-ttu-id="81e46-124">이러한 방식으로 섀도는 환경에서 광원을 빼는 것 처럼 보입니다.</span><span class="sxs-lookup"><span data-stu-id="81e46-124">In this way, your shadow appears to subtract light from the environment.</span></span> <span data-ttu-id="81e46-125">[공간 사운드](../../design/spatial-sound.md) 는 다른 매우 중요 한 깊이 큐로, 사용자가 홀로그램의 거리와 상대 위치에 대 한 이유를 알려 줍니다.</span><span class="sxs-lookup"><span data-stu-id="81e46-125">[Spatial sound](../../design/spatial-sound.md) is another extremely important depth cue, letting users reason about the distance and relative location of a hologram.</span></span>

<span data-ttu-id="81e46-126">[Windows Mixed Reality 몰입 형 헤드셋](../../discover/immersive-headset-hardware-details.md)과 같이 **불투명 디스플레이** 를 사용 하는 장치는 전 세계를 차단 합니다.</span><span class="sxs-lookup"><span data-stu-id="81e46-126">Devices with **opaque displays** , like [Windows Mixed Reality immersive headsets](../../discover/immersive-headset-hardware-details.md), block out the world.</span></span> <span data-ttu-id="81e46-127">검정 픽셀은 검정 픽셀이 고 다른 색은 사용자에 게 해당 색으로 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="81e46-127">Black pixels are solid black, and any other color appears as that color to the user.</span></span> <span data-ttu-id="81e46-128">응용 프로그램은 사용자에 게 표시 되는 모든 항목을 렌더링 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="81e46-128">Your application is responsible for rendering everything the user sees.</span></span> <span data-ttu-id="81e46-129">이렇게 하면 사용자가 편안 하 게 사용할 수 있도록 일정 한 새로 고침 빈도를 유지 관리 하는 것이 훨씬 더 중요 합니다.</span><span class="sxs-lookup"><span data-stu-id="81e46-129">This makes it even more important to maintain a constant refresh rate so that users have a comfortable experience.</span></span>

## <a name="predicted-rendering-parameters"></a><span data-ttu-id="81e46-130">예측 된 렌더링 매개 변수</span><span class="sxs-lookup"><span data-stu-id="81e46-130">Predicted rendering parameters</span></span>

<span data-ttu-id="81e46-131">혼합 현실 헤드셋 (HoloLens 및 몰입 형 헤드셋)은 주변에 상대적인 사용자 헤드의 위치와 방향을 지속적으로 추적 합니다.</span><span class="sxs-lookup"><span data-stu-id="81e46-131">Mixed reality headsets (both HoloLens and immersive headsets) continually track the position and orientation of the user's head relative to their surroundings.</span></span> <span data-ttu-id="81e46-132">응용 프로그램에서 다음 프레임의 준비를 시작 하면 시스템은 사용자의 헤드가 화면에 표시 되는 순간에 사용자의 헤드가 나중에 표시 되는 위치를 예측 합니다.</span><span class="sxs-lookup"><span data-stu-id="81e46-132">As your application begins preparing its next frame, the system predicts where the user's head will be in the future at the exact moment that the frame shows up on the displays.</span></span> <span data-ttu-id="81e46-133">이 예측을 기반으로 시스템은 해당 프레임에 사용할 뷰 및 프로젝션 변환을 계산 합니다.</span><span class="sxs-lookup"><span data-stu-id="81e46-133">Based on this prediction, the system calculates the view and the projection transforms to use for that frame.</span></span> <span data-ttu-id="81e46-134">응용 프로그램에서 **이러한 변환을 사용 하 여 올바른 결과를 생성 해야 합니다** . 시스템에서 제공 하는 변환을 사용 하지 않는 경우 결과 이미지가 실제 세계와 일치 하지 않아 사용자 discomfort이 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="81e46-134">Your application **must use these transforms to produce correct results** ; if system-supplied transforms are not used, the resulting image will not align with the real world, leading to user discomfort.</span></span>

<span data-ttu-id="81e46-135">새 프레임이 디스플레이에 도달 하는 시기를 정확 하 게 예측 하기 위해 시스템은 응용 프로그램의 렌더링 파이프라인에 대 한 효과적인 종단 간 대기 시간을 지속적으로 측정 합니다.</span><span class="sxs-lookup"><span data-stu-id="81e46-135">Note that to accurately predict when a new frame will reach the displays, the system is constantly measuring the effective end-to-end latency of your application's rendering pipeline.</span></span> <span data-ttu-id="81e46-136">시스템이 렌더링 파이프라인의 길이로 조정 되는 동안 해당 파이프라인을 가능한 한 짧게 유지 하 여 홀로그램의 안정성을 향상 시킬 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="81e46-136">While the system adjusts to the length of your rendering pipeline, you can improve hologram stability by keeping that pipeline as short as possible.</span></span>

<span data-ttu-id="81e46-137">고급 기술을 사용 하 여 시스템 예측을 보강 하는 응용 프로그램은 시스템 뷰 및 프로젝션 변환을 재정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="81e46-137">Applications that use advanced techniques to augment the system prediction can override the system view and projection transforms.</span></span> <span data-ttu-id="81e46-138">이러한 응용 프로그램은 의미 있는 결과를 생성 하기 위해 사용자 지정 변환의 기반으로 시스템 제공 변환을 계속 사용 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="81e46-138">These applications must still use system-supplied transforms as a basis for their custom transforms in order to produce meaningful results.</span></span>

## <a name="other-rendering-parameters"></a><span data-ttu-id="81e46-139">기타 렌더링 매개 변수</span><span class="sxs-lookup"><span data-stu-id="81e46-139">Other rendering parameters</span></span>

<span data-ttu-id="81e46-140">프레임을 렌더링할 때 시스템은 응용 프로그램에서 그려야 하는 백 버퍼 뷰포트를 지정 합니다.</span><span class="sxs-lookup"><span data-stu-id="81e46-140">When rendering a frame, the system specifies the back-buffer viewport in which your application should draw.</span></span> <span data-ttu-id="81e46-141">이 viewport는 프레임 버퍼의 전체 크기 보다 작은 경우가 많습니다.</span><span class="sxs-lookup"><span data-stu-id="81e46-141">This viewport is often smaller than the full size of the frame buffer.</span></span> <span data-ttu-id="81e46-142">응용 프로그램에서 프레임을 렌더링 한 후에는 뷰포트 크기에 관계 없이 이미지를 확장 하 여 전체 화면을 채웁니다.</span><span class="sxs-lookup"><span data-stu-id="81e46-142">Regardless of the viewport size, once the frame is rendered by the application, the system upscales the image to fill the entirety of the displays.</span></span>

<span data-ttu-id="81e46-143">자동으로 필요한 새로 고침 속도로 렌더링할 수 없는 응용 프로그램의 경우 메모리 압력을 줄이고 픽셀 앨리어싱을 늘리기 위해 [시스템 렌더링 매개 변수를 구성할 수 있습니다](https://docs.microsoft.com/uwp/api/Windows.Graphics.Holographic.HolographicViewConfiguration#Windows_Graphics_Holographic_HolographicViewConfiguration) .</span><span class="sxs-lookup"><span data-stu-id="81e46-143">For applications that find themselves unable to render at the required refresh rate, [system rendering parameters can be configured](https://docs.microsoft.com/uwp/api/Windows.Graphics.Holographic.HolographicViewConfiguration#Windows_Graphics_Holographic_HolographicViewConfiguration) to reduce memory pressure and rendering cost at the cost of increased pixel aliasing.</span></span> <span data-ttu-id="81e46-144">백 버퍼 형식을 변경할 수도 있습니다 .이 경우 일부 앱에서 메모리 대역폭과 픽셀 처리량을 향상 시키는 데 도움이 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="81e46-144">The back buffer format can also be changed, which for some apps can help to improve memory bandwidth and pixel throughput.</span></span>

<span data-ttu-id="81e46-145">앱이 렌더링 되는 것으로 확인 되는 렌더링의 대/소문자, 해상도 및 프레임 속도가 프레임에서 프레임으로 변경 될 수도 있으며, 왼쪽 및 오른쪽 눈에 걸쳐 달라질 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="81e46-145">The rendering frustum, resolution, and framerate in which your app is asked to render might also change from frame to frame, and might differ across the left and right eye.</span></span> <span data-ttu-id="81e46-146">예를 들어 [혼합 현실 캡처](../../mixed-reality-capture.md) (mrc)가 활성 상태이 고 [photo/video 카메라 보기 구성을](https://docs.microsoft.com/uwp/api/Windows.Graphics.Holographic.HolographicViewConfigurationKind#Windows_Graphics_Holographic_HolographicViewConfigurationKind) 옵트인 (opt in) 할 수 없는 경우에는 한 눈이 더 큰 FOV 또는 해상도로 렌더링 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="81e46-146">For example, when [mixed reality capture](../../mixed-reality-capture.md) (MRC) is active and the [photo/video camera view configuration](https://docs.microsoft.com/uwp/api/Windows.Graphics.Holographic.HolographicViewConfigurationKind#Windows_Graphics_Holographic_HolographicViewConfigurationKind) is not opted-into, one eye might be rendered with a larger FOV or resolution.</span></span>

<span data-ttu-id="81e46-147">지정 된 프레임의 경우 응용 프로그램은 시스템에서 제공 하는 뷰 변환, 프로젝션 변환 및 뷰포트 해상도를 사용 하 여 렌더링 *해야 합니다* .</span><span class="sxs-lookup"><span data-stu-id="81e46-147">For any given frame, your app *must* render using the view transform, projection transform, and viewport resolution provided by the system.</span></span> <span data-ttu-id="81e46-148">또한 응용 프로그램은 렌더링 또는 뷰 매개 변수가 프레임-프레임에서 고정 된 상태로 유지 되는 것으로 가정해 서는 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="81e46-148">Additionally, your application must never assume that any rendering or view parameter remains fixed from frame-to-frame.</span></span> <span data-ttu-id="81e46-149">Unity와 같은 엔진은 사용자의 실제 이동과 시스템 상태가 항상 적용 되도록 이러한 모든 변환을 자체 카메라 개체에서 처리 합니다.</span><span class="sxs-lookup"><span data-stu-id="81e46-149">Engines like Unity handle all these transforms for you in their own camera objects so that the physical movement of your users and the state of the system is always respected.</span></span> <span data-ttu-id="81e46-150">응용 프로그램에서 전 세계 사용자의 가상 이동을 허용 하는 경우 (예: 게임 패드에서 엄지 스틱 사용), 부모 rig 개체를 이동 하는 카메라 위에 부모 rig 개체를 추가할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="81e46-150">If your application allows for virtual movement of the user through the world (e.g. using the thumbstick on a gamepad), you can add a parent rig object above the camera that moves it around.</span></span> <span data-ttu-id="81e46-151">이렇게 하면 카메라는 사용자의 가상 및 실제 움직임을 반영 합니다.</span><span class="sxs-lookup"><span data-stu-id="81e46-151">This causes the camera to reflect both the user's virtual and physical motion.</span></span> <span data-ttu-id="81e46-152">응용 프로그램이 시스템에서 제공 하는 뷰 변환, 프로젝션 변환 또는 뷰포트 차원을 수정 하는 경우 적절 한 [재정의 API](https://docs.microsoft.com/uwp/api/Windows.Graphics.Holographic.HolographicCameraPose#Windows_Graphics_Holographic_HolographicCameraPose)를 호출 하 여 시스템에 알려야 합니다.</span><span class="sxs-lookup"><span data-stu-id="81e46-152">If your application modifies the view transform, projection transform, or viewport dimension provided by the system, it must inform the system by calling the appropriate [override API](https://docs.microsoft.com/uwp/api/Windows.Graphics.Holographic.HolographicCameraPose#Windows_Graphics_Holographic_HolographicCameraPose).</span></span>

<span data-ttu-id="81e46-153">Holographic 렌더링의 안정성을 향상 시키기 위해 앱은 렌더링에 사용 되는 깊이 버퍼를 각 프레임에 제공 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="81e46-153">To enhance the stability of your holographic rendering, your app should provide to Windows each frame the depth buffer it used for rendering.</span></span> <span data-ttu-id="81e46-154">앱에서 깊이 버퍼를 제공 하는 경우에는 카메라에서 미터 단위로 표시 된 깊이 있는 깊이 값이 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="81e46-154">If your app does provide a depth buffer, it should have coherent depth values, with depth expressed in meters from the camera.</span></span> <span data-ttu-id="81e46-155">이를 통해 사용자의 헤드가 예측 위치에서 약간의 오프셋을 종료 하는 경우 시스템에서 픽셀 당 깊이 데이터를 사용 하 여 안정화 된 콘텐츠를 더 효율적으로 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="81e46-155">This enables the system to use your per-pixel depth data to better stabilize content if the user's head ends up slightly offset from the predicted location.</span></span> <span data-ttu-id="81e46-156">깊이 버퍼를 제공할 수 없는 경우에는 대부분의 콘텐츠를 잘라내는 평면을 정의 하는 포커스 지점과 법선을 제공할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="81e46-156">If you are not able to provide your depth buffer, you can provide a focus point and normal, defining a plane that cuts through most of your content.</span></span> <span data-ttu-id="81e46-157">깊이 버퍼와 포커스 평면이 모두 제공 되는 경우 시스템은 두 가지 모두를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="81e46-157">If both the depth buffer and a focus plane are provided, the system might use both.</span></span> <span data-ttu-id="81e46-158">특히 응용 프로그램에서 동작 중인 holograms 표시 하는 경우 속도 벡터를 포함 하는 집중 지점과 깊이 버퍼를 모두 제공 하는 것이 유용 합니다.</span><span class="sxs-lookup"><span data-stu-id="81e46-158">In particular, it is helpful to provide both the depth buffer and a focus point that includes a velocity vector when your application displays holograms that are in motion.</span></span>

<span data-ttu-id="81e46-159">항목에 대 한 하위 수준 세부 정보는 [DirectX의 렌더링](../native/rendering-in-directx.md) 문서를 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="81e46-159">Refer to [Rendering in DirectX](../native/rendering-in-directx.md) article for low-level details about his topic.</span></span>

## <a name="holographic-cameras"></a><span data-ttu-id="81e46-160">Holographic 카메라</span><span class="sxs-lookup"><span data-stu-id="81e46-160">Holographic cameras</span></span>

<span data-ttu-id="81e46-161">Windows Mixed Reality에서는 **holographic 카메라** 의 개념을 소개 합니다.</span><span class="sxs-lookup"><span data-stu-id="81e46-161">Windows Mixed Reality introduces the concept of a **holographic camera** .</span></span> <span data-ttu-id="81e46-162">Holographic 카메라는 3D 그래픽 텍스트에 있는 전통적인 카메라와 비슷합니다. 외부 (위치 및 방향) 및 내장 카메라 속성을 모두 정의 합니다.</span><span class="sxs-lookup"><span data-stu-id="81e46-162">Holographic cameras are similar to the traditional camera found in 3D graphics texts; they define both the extrinsic (position and orientation) and intrinsic camera properties.</span></span> <span data-ttu-id="81e46-163">(예: 뷰 필드는 가상 3D 장면을 보는 데 사용 됩니다.) 기존의 3D 카메라와 달리 응용 프로그램은 카메라의 위치, 방향 및 기본 속성을 제어 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="81e46-163">(For example:, field-of-view is used to view a virtual 3D scene.) Unlike traditional 3D cameras, the application is not in control of the position, orientation, and intrinsic properties of the camera.</span></span> <span data-ttu-id="81e46-164">대신 holographic 카메라의 위치와 방향은 사용자의 움직임에 의해 암시적으로 제어 됩니다.</span><span class="sxs-lookup"><span data-stu-id="81e46-164">Rather, the position and orientation of the holographic camera is implicitly controlled by the user's movement.</span></span> <span data-ttu-id="81e46-165">사용자의 이동은 뷰 변환을 통해 프레임 단위로 응용 프로그램에 릴레이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="81e46-165">The user's movement is relayed to the application on a frame-by-frame basis via a view transform.</span></span> <span data-ttu-id="81e46-166">마찬가지로 카메라의 내장 속성은 장치의 보정 된 광학에서 정의 되며 프로젝션 변환을 통해 프레임별로 릴레이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="81e46-166">Likewise, the camera's intrinsic properties are defined by the device's calibrated optics and relayed frame-by-frame via the projection transform.</span></span>

<span data-ttu-id="81e46-167">일반적으로 응용 프로그램은 단일 스테레오 카메라에 대해 렌더링 됩니다.</span><span class="sxs-lookup"><span data-stu-id="81e46-167">In general, your application will render for a single stereo camera.</span></span> <span data-ttu-id="81e46-168">그러나 강력한 렌더링 루프는 여러 카메라를 지원 하며 mono 및 스테레오 카메라를 모두 지원 합니다.</span><span class="sxs-lookup"><span data-stu-id="81e46-168">However, a robust rendering loop will support multiple cameras, and will support both mono and stereo cameras.</span></span> <span data-ttu-id="81e46-169">예를 들어, 사용자가 해당 하는 헤드셋의 셰이프에 따라 mrc ( [mixed reality capture](../../mixed-reality-capture.md) )와 같은 기능을 활성화 하는 경우 시스템은 대체 큐브 뷰에서 렌더링 하도록 응용 프로그램을 요청할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="81e46-169">For example, the system might ask your application to render from an alternate perspective when the user activates a feature like [mixed reality capture](../../mixed-reality-capture.md) (MRC), depending on the shape of the headset in question.</span></span> <span data-ttu-id="81e46-170">여러 카메라를 지원할 수 있는 응용 프로그램에서는 지원할 수 있는 카메라 [종류](https://docs.microsoft.com/uwp/api/Windows.Graphics.Holographic.HolographicViewConfigurationKind#Windows_Graphics_Holographic_HolographicViewConfigurationKind) 에 [옵트인](https://docs.microsoft.com/uwp/api/Windows.Graphics.Holographic.HolographicViewConfiguration#Windows_Graphics_Holographic_HolographicViewConfiguration) 하 여 해당 응용 프로그램을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="81e46-170">Applications that can support multiple cameras get them by [opting-in](https://docs.microsoft.com/uwp/api/Windows.Graphics.Holographic.HolographicViewConfiguration#Windows_Graphics_Holographic_HolographicViewConfiguration) to the [kind](https://docs.microsoft.com/uwp/api/Windows.Graphics.Holographic.HolographicViewConfigurationKind#Windows_Graphics_Holographic_HolographicViewConfigurationKind) of cameras they can support.</span></span>

## <a name="volume-rendering"></a><span data-ttu-id="81e46-171">볼륨 렌더링</span><span class="sxs-lookup"><span data-stu-id="81e46-171">Volume rendering</span></span>

<span data-ttu-id="81e46-172">3D에서 의료 MRIs 또는 엔지니어링 볼륨을 렌더링 하는 경우 [볼륨 렌더링](volume-rendering.md) 기술이 종종 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="81e46-172">When rendering medical MRIs or engineering volumes in 3D, [volume rendering](volume-rendering.md) techniques are often used.</span></span> <span data-ttu-id="81e46-173">이러한 기술은 혼합 현실에서 특히 유용할 수 있습니다. 사용자는 단순히 헤드를 이동 하 여 키 각도에서 이러한 볼륨을 자연스럽 게 볼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="81e46-173">These techniques can be particularly interesting in mixed reality, where users can naturally view such a volume from key angles, simply by moving their head.</span></span>

## <a name="supported-resolutions-on-hololens-1st-gen"></a><span data-ttu-id="81e46-174">HoloLens에서 지원 되는 해상도 (첫 번째 gen)</span><span class="sxs-lookup"><span data-stu-id="81e46-174">Supported resolutions on HoloLens (1st gen)</span></span>

* <span data-ttu-id="81e46-175">최대 뷰포트 크기는 [HolographicDisplay](https://docs.microsoft.com/uwp/api/windows.graphics.holographic.holographicdisplay)의 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="81e46-175">The max viewport size is a property of the [HolographicDisplay](https://docs.microsoft.com/uwp/api/windows.graphics.holographic.holographicdisplay).</span></span> <span data-ttu-id="81e46-176">HoloLens는 기본적으로 최대 뷰포트 크기 (720p (1268x720))로 설정 됩니다.</span><span class="sxs-lookup"><span data-stu-id="81e46-176">HoloLens is set to the maximum viewport size, which is 720p (1268x720), by default.</span></span>
* <span data-ttu-id="81e46-177">HolographicCamera의 ViewportScaleFactor를 설정 하 여 뷰포트 크기를 변경할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="81e46-177">The viewport size can be changed by setting the ViewportScaleFactor on the HolographicCamera.</span></span> <span data-ttu-id="81e46-178">이 배율 인수는 0에서 1 사이입니다.</span><span class="sxs-lookup"><span data-stu-id="81e46-178">This scale factor is in the range of 0 to 1.</span></span>
* <span data-ttu-id="81e46-179">HoloLens에서 지원 되는 가장 낮은 뷰포트 크기 (첫 번째 gen)는 360p (634x360) 인 720p의 50%입니다.</span><span class="sxs-lookup"><span data-stu-id="81e46-179">The lowest supported viewport size on HoloLens (1st gen) is 50% of 720p, which is 360p (634x360).</span></span> <span data-ttu-id="81e46-180">0.5의 ViewportScaleFactor입니다.</span><span class="sxs-lookup"><span data-stu-id="81e46-180">This is a ViewportScaleFactor of 0.5.</span></span>
* <span data-ttu-id="81e46-181">540p 보다 낮은 항목은 시각적 저하로 인해 권장 되지 않지만 픽셀 채우기 속도로 병목 상태를 식별 하는 데 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="81e46-181">Anything lower than 540p is not recommended due to visual degradation, but can be used to identify bottlenecks in pixel fill rate.</span></span>

## <a name="supported-resolutions-on-hololens-2"></a><span data-ttu-id="81e46-182">HoloLens 2에서 지원 되는 해상도</span><span class="sxs-lookup"><span data-stu-id="81e46-182">Supported resolutions on HoloLens 2</span></span>

* <span data-ttu-id="81e46-183">현재 지원 되는 최대 렌더링 대상 크기는 [뷰 구성](https://docs.microsoft.com/uwp/api/Windows.Graphics.Holographic.HolographicViewConfiguration#Windows_Graphics_Holographic_HolographicViewConfiguration)의 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="81e46-183">The current and maximum supported render target sizes are properties of the [view configuration](https://docs.microsoft.com/uwp/api/Windows.Graphics.Holographic.HolographicViewConfiguration#Windows_Graphics_Holographic_HolographicViewConfiguration).</span></span> <span data-ttu-id="81e46-184">HoloLens 2는 기본적으로 최대 렌더링 대상 크기 (1440x936)로 설정 됩니다.</span><span class="sxs-lookup"><span data-stu-id="81e46-184">HoloLens 2 is set to the maximum render target size, which is 1440x936, by default.</span></span>
* <span data-ttu-id="81e46-185">앱은 RequestRenderTargetSize 메서드를 호출 하 여 새 렌더링 대상 크기를 요청 하 여 렌더링 대상 버퍼의 크기를 변경할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="81e46-185">Apps can change the size of render target buffers by calling the RequestRenderTargetSize method to request a new render target size.</span></span> <span data-ttu-id="81e46-186">요청 된 렌더링 대상 크기를 충족 하거나 초과 하는 새 렌더링 대상 크기가 선택 됩니다.</span><span class="sxs-lookup"><span data-stu-id="81e46-186">A new render target size will be chosen, which meets or exceeds the requested render target size.</span></span> <span data-ttu-id="81e46-187">이 API는 GPU에서 메모리를 다시 할당 해야 하는 렌더링 대상 버퍼의 크기를 변경 합니다.</span><span class="sxs-lookup"><span data-stu-id="81e46-187">This API changes the size of the render target buffer, which requires memory reallocation on the GPU.</span></span> <span data-ttu-id="81e46-188">이에 대 한 의미는 다음과 같습니다. GPU의 메모리 압력을 줄이기 위해 렌더링 대상 크기를 축소할 수 있으며이 메서드는 높은 빈도로 호출 되지 않아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="81e46-188">The implications of this include: The render target size can be scaled down to reduce memory pressure on the GPU, and this method should not be called at high frequency.</span></span>
* <span data-ttu-id="81e46-189">앱은 HoloLens 1에 대해 수행한 것과 동일한 방식으로 뷰포트 크기를 변경할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="81e46-189">Apps can still change the viewport size in the same way that they did for HoloLens 1.</span></span> <span data-ttu-id="81e46-190">이로 인해 GPU에서 메모리가 다시 할당 되지 않으므로 빈도가 높은 빈도로 변경 될 수 있지만 GPU의 메모리 부족을 줄이는 데 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="81e46-190">This does not cause memory reallocation on the GPU, so it can be changed at high frequency, but it cannot be used to reduce memory pressure on the GPU.</span></span>
* <span data-ttu-id="81e46-191">HoloLens 2에서 지원 되는 가장 낮은 뷰포트 크기는 634x412입니다.</span><span class="sxs-lookup"><span data-stu-id="81e46-191">The lowest supported viewport size on HoloLens 2 is 634x412.</span></span> <span data-ttu-id="81e46-192">이는 기본 렌더링 대상 크기를 사용 하는 경우 약 0.44의 ViewportScaleFactor입니다.</span><span class="sxs-lookup"><span data-stu-id="81e46-192">This is a ViewportScaleFactor of approximately 0.44 when the default render target size is in use.</span></span>
* <span data-ttu-id="81e46-193">지원 되는 가장 낮은 뷰포트 크기 보다 작은 렌더링 대상 크기를 제공 하는 경우 뷰포트 배율 요소가 무시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="81e46-193">If a render target size is provided which is smaller than the lowest supported viewport size, the viewport scale factor will be ignored.</span></span>
* <span data-ttu-id="81e46-194">540p 보다 낮은 항목은 시각적 저하로 인해 권장 되지 않지만 픽셀 채우기 속도로 병목 상태를 식별 하는 데 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="81e46-194">Anything lower than 540p is not recommended due to visual degradation, but can be used to identify bottlenecks in pixel fill rate.</span></span>



## <a name="see-also"></a><span data-ttu-id="81e46-195">참조</span><span class="sxs-lookup"><span data-stu-id="81e46-195">See also</span></span>
* [<span data-ttu-id="81e46-196">홀로그램 안정성</span><span class="sxs-lookup"><span data-stu-id="81e46-196">Hologram stability</span></span>](hologram-stability.md)
* [<span data-ttu-id="81e46-197">DirectX의 렌더링</span><span class="sxs-lookup"><span data-stu-id="81e46-197">Rendering in DirectX</span></span>](../native/rendering-in-directx.md)
