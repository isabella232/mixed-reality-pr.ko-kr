---
title: DirectX의 헤드 및 모션 컨트롤러
description: 기본 DirectX 앱에서 직접 추적 및 동작 컨트롤러를 사용 하기 위한 개발자 가이드입니다.
author: caseymeekhof
ms.author: cmeekhof
ms.date: 08/04/2020
ms.topic: article
keywords: 손, 모션 컨트롤러, directx, 입력, holograms
ms.openlocfilehash: faa9abe224b554c45cf0175b62da40c297122ad1
ms.sourcegitcommit: 09599b4034be825e4536eeb9566968afd021d5f3
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 10/03/2020
ms.locfileid: "91685920"
---
# <a name="hands-and-motion-controllers-in-directx"></a><span data-ttu-id="aa851-104">DirectX의 헤드 및 모션 컨트롤러</span><span class="sxs-lookup"><span data-stu-id="aa851-104">Hands and motion controllers in DirectX</span></span>

> [!NOTE]
> <span data-ttu-id="aa851-105">이 문서는 레거시 WinRT 네이티브 Api와 관련이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="aa851-105">This article relates to the legacy WinRT native APIs.</span></span>  <span data-ttu-id="aa851-106">새 네이티브 앱 프로젝트의 경우 **[OPENXR API](openxr-getting-started.md)** 를 사용 하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="aa851-106">For new native app projects, we recommend using the **[OpenXR API](openxr-getting-started.md)** .</span></span>

<span data-ttu-id="aa851-107">Windows Mixed Reality에서 직접 및 [동작 컨트롤러](../../design/motion-controllers.md) 입력은 모두 [windows.](https://docs.microsoft.com/uwp/api/windows.ui.input.spatial) ui&gt; 네임 스페이스에 있는 공간 입력 api를 통해 처리 됩니다.</span><span class="sxs-lookup"><span data-stu-id="aa851-107">In Windows Mixed Reality, both hand and [motion controller](../../design/motion-controllers.md) input is handled through the spatial input APIs, found in the [Windows.UI.Input.Spatial](https://docs.microsoft.com/uwp/api/windows.ui.input.spatial) namespace.</span></span> <span data-ttu-id="aa851-108">이를 통해 바늘 및 모션 컨트롤러에서 같은 방식으로 **Select** 와 같은 일반적인 동작을 쉽게 처리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="aa851-108">This enables you to easily handle common actions like **Select** presses the same way across both hands and motion controllers.</span></span>

## <a name="getting-started"></a><span data-ttu-id="aa851-109">시작</span><span class="sxs-lookup"><span data-stu-id="aa851-109">Getting started</span></span>

<span data-ttu-id="aa851-110">Windows Mixed Reality의 공간 입력에 액세스 하려면 SpatialInteractionManager 인터페이스부터 시작 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa851-110">To access spatial input in Windows Mixed Reality, start with the SpatialInteractionManager interface.</span></span>  <span data-ttu-id="aa851-111">일반적으로 앱을 시작 하는 동안  [SpatialInteractionManager:: GetForCurrentView](https://docs.microsoft.com//uwp/api/windows.ui.input.spatial.spatialinteractionmanager.getforcurrentview)를 호출 하 여이 인터페이스에 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="aa851-111">You can access this interface by calling  [SpatialInteractionManager::GetForCurrentView](https://docs.microsoft.com//uwp/api/windows.ui.input.spatial.spatialinteractionmanager.getforcurrentview), typically sometime during app startup.</span></span>

```cpp
using namespace winrt::Windows::UI::Input::Spatial;

SpatialInteractionManager interactionManager = SpatialInteractionManager::GetForCurrentView();
```

<span data-ttu-id="aa851-112">SpatialInteractionManager의 작업은 입력의 원본을 나타내는 [SpatialInteractionSources](https://docs.microsoft.com//uwp/api/windows.ui.input.spatial.spatialinteractionsource)에 대 한 액세스를 제공 하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="aa851-112">The SpatialInteractionManager's job is to provide access to [SpatialInteractionSources](https://docs.microsoft.com//uwp/api/windows.ui.input.spatial.spatialinteractionsource), which represent a source of input.</span></span>  <span data-ttu-id="aa851-113">시스템에서 사용할 수 있는 SpatialInteractionSources에는 세 가지 종류가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="aa851-113">There are three kinds of SpatialInteractionSources available in the system.</span></span>
* <span data-ttu-id="aa851-114">사용자의 검색 된 **손을 나타냅니다.**</span><span class="sxs-lookup"><span data-stu-id="aa851-114">**Hand** represents a user's detected hand.</span></span> <span data-ttu-id="aa851-115">손으로는 HoloLens의 기본 제스처에서 HoloLens 2의 전체에 대 한 직접 추적에 이르는 장치에 따라 다양 한 기능을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa851-115">Hand sources offer different features based on the device, ranging from basic gestures on HoloLens to fully articulated hand tracking on HoloLens 2.</span></span> 
* <span data-ttu-id="aa851-116">**컨트롤러** 는 페어링된 동작 컨트롤러를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="aa851-116">**Controller** represents a paired motion controller.</span></span> <span data-ttu-id="aa851-117">동작 컨트롤러는 다양 한 기능을 제공할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="aa851-117">Motion controllers can offer a variety of capabilities.</span></span>  <span data-ttu-id="aa851-118">예: 트리거, 메뉴 단추, 클릭 단추, 터치 패드 및 thumbsticks를 선택 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa851-118">For example: Select triggers, Menu buttons, Grasp buttons, touchpads and thumbsticks.</span></span>
* <span data-ttu-id="aa851-119">**음성** 은 사용자의 음성 인식 시스템 검색 키워드를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="aa851-119">**Voice** represents the user's voice speaking system-detected keywords.</span></span> <span data-ttu-id="aa851-120">예를 들어이 소스는 사용자가 "선택" 이라고 표시 될 때마다 Select 누르기 및 릴리스를 삽입 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa851-120">For example, this source will inject a Select press and release whenever the user says "Select".</span></span>

<span data-ttu-id="aa851-121">원본에 대 한 프레임당 데이터는  [SpatialInteractionSourceState](https://docs.microsoft.com//uwp/api/windows.ui.input.spatial.spatialinteractionsourcestate) 인터페이스로 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="aa851-121">Per-frame data for a source is represented by the  [SpatialInteractionSourceState](https://docs.microsoft.com//uwp/api/windows.ui.input.spatial.spatialinteractionsourcestate) interface.</span></span> <span data-ttu-id="aa851-122">응용 프로그램에서 이벤트 기반 또는 폴링 기반 모델을 사용 하는지 여부에 따라이 데이터에 액세스 하는 두 가지 방법이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="aa851-122">There are two different ways to access this data, depending on whether you want to use an event-driven or polling-based model in your application.</span></span>

### <a name="event-driven-input"></a><span data-ttu-id="aa851-123">이벤트 기반 입력</span><span class="sxs-lookup"><span data-stu-id="aa851-123">Event-driven input</span></span>
<span data-ttu-id="aa851-124">SpatialInteractionManager는 앱이 수신할 수 있는 많은 이벤트를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa851-124">The SpatialInteractionManager provides a number of events that your app can listen for.</span></span>  <span data-ttu-id="aa851-125">[Sourcepressed](https://docs.microsoft.com//uwp/api/windows.ui.input.spatial.spatialinteractionmanager.sourcepressed), [SourceReleased](https://docs.microsoft.com//uwp/api/windows.ui.input.spatial.spatialinteractionmanager.sourcereleased) 및 [sourcepressed](https://docs.microsoft.com//uwp/api/windows.ui.input.spatial.spatialinteractionmanager.sourceupdated)를 예로 들 수가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="aa851-125">A few examples include   [SourcePressed](https://docs.microsoft.com//uwp/api/windows.ui.input.spatial.spatialinteractionmanager.sourcepressed), [SourceReleased](https://docs.microsoft.com//uwp/api/windows.ui.input.spatial.spatialinteractionmanager.sourcereleased) and [SourceUpdated](https://docs.microsoft.com//uwp/api/windows.ui.input.spatial.spatialinteractionmanager.sourceupdated).</span></span>

<span data-ttu-id="aa851-126">예를 들어 다음 코드는 MyApp:: OnSourcePressed 이벤트 처리기를 Source눌린 이벤트로 후크합니다.</span><span class="sxs-lookup"><span data-stu-id="aa851-126">For example, the following code hooks up an event handler called MyApp::OnSourcePressed to the SourcePressed event.</span></span>  <span data-ttu-id="aa851-127">이를 통해 앱은 모든 유형의 상호 작용 소스에서 누름을 검색할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="aa851-127">This allows your app to detect presses on any type of interaction source.</span></span>

```cpp
using namespace winrt::Windows::UI::Input::Spatial;

auto interactionManager = SpatialInteractionManager::GetForCurrentView();
interactionManager.SourcePressed({ this, &MyApp::OnSourcePressed });

```

<span data-ttu-id="aa851-128">이 누름 이벤트는 키가 발생 했을 때 해당 SpatialInteractionSourceState 함께 비동기적으로 앱에 전송 됩니다.</span><span class="sxs-lookup"><span data-stu-id="aa851-128">This pressed event is sent to your app asynchronously, along with the corresponding SpatialInteractionSourceState at the time the press happened.</span></span> <span data-ttu-id="aa851-129">앱 또는 게임 엔진에서 일부 처리를 즉시 수행 하거나 입력 처리 루틴에서 이벤트 데이터를 큐에 대기 시킬 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="aa851-129">Your app or game engine may want to perform some processing right away or you may want to queue up the event data in your input processing routine.</span></span> <span data-ttu-id="aa851-130">다음은 선택 단추가 눌러져 있는지 여부를 확인 하는 방법을 보여 주는 SourcePressed 이벤트에 대 한 이벤트 처리기 함수입니다.</span><span class="sxs-lookup"><span data-stu-id="aa851-130">Here is an event handler function for the SourcePressed event, which shows how to check whether the select button was pressed.</span></span>

```cpp
using namespace winrt::Windows::UI::Input::Spatial;

void MyApp::OnSourcePressed(SpatialInteractionManager const& sender, SpatialInteractionSourceEventArgs const& args)
{
    if (args.PressKind() == SpatialInteractionPressKind::Select)
    {
        // Select button was pressed, update app state
    }
}
```

<span data-ttu-id="aa851-131">위의 코드는 장치의 기본 작업에 해당 하는 ' Select ' 누르기만 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa851-131">The above code only checks for the 'Select' press, which corresponds to the primary action on the device.</span></span> <span data-ttu-id="aa851-132">예를 들어 HoloLens를 이동 하거나 동작 컨트롤러에서 트리거를 당겨 이동 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa851-132">Examples include doing an AirTap on HoloLens or pulling the trigger on a motion controller.</span></span>  <span data-ttu-id="aa851-133">' Select ' 누름은 대상으로 하는 홀로그램을 활성화 하는 사용자의 의도를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="aa851-133">'Select' presses represent the user's intention to activate the hologram they are targeting.</span></span>  <span data-ttu-id="aa851-134">SourcePressed 이벤트는 다양 한 단추 및 제스처에 대해 발생 하며, SpatialInteractionSource의 다른 속성을 검사 하 여 해당 사례를 테스트할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="aa851-134">The SourcePressed event will fire for a number of different buttons and gestures, and you can inspect other properties on the SpatialInteractionSource to test for those cases.</span></span>

### <a name="polling-based-input"></a><span data-ttu-id="aa851-135">폴링 기반 입력</span><span class="sxs-lookup"><span data-stu-id="aa851-135">Polling-based input</span></span>
<span data-ttu-id="aa851-136">또한 SpatialInteractionManager를 사용 하 여 모든 프레임의 현재 상태를 폴링할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="aa851-136">You can also use SpatialInteractionManager to poll for the current state of input every frame.</span></span>  <span data-ttu-id="aa851-137">이렇게 하려면 [GetDetectedSourcesAtTimestamp](https://docs.microsoft.com//uwp/api/windows.ui.input.spatial.spatialinteractionmanager.getdetectedsourcesattimestamp) 모든 프레임을 호출 하면 됩니다.</span><span class="sxs-lookup"><span data-stu-id="aa851-137">To do this, simply call [GetDetectedSourcesAtTimestamp](https://docs.microsoft.com//uwp/api/windows.ui.input.spatial.spatialinteractionmanager.getdetectedsourcesattimestamp) every frame.</span></span>  <span data-ttu-id="aa851-138">이 함수는 모든 활성 [SpatialInteractionSource](https://docs.microsoft.com//uwp/api/windows.ui.input.spatial.spatialinteractionsource)에 대해 하나의 [SpatialInteractionSourceState](https://docs.microsoft.com//uwp/api/windows.ui.input.spatial.spatialinteractionsourcestate) 를 포함 하는 배열을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa851-138">This function returns an array containing one [SpatialInteractionSourceState](https://docs.microsoft.com//uwp/api/windows.ui.input.spatial.spatialinteractionsourcestate) for every active [SpatialInteractionSource](https://docs.microsoft.com//uwp/api/windows.ui.input.spatial.spatialinteractionsource).</span></span> <span data-ttu-id="aa851-139">즉, 각 활성 동작 컨트롤러에 대해 하나씩, 추적 된 각 항목에 대해 하나씩, ' select ' 명령이 최근에 재생 된 경우 음성을 위한 하나를 의미 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa851-139">This means one for each active motion controller, one for each tracked hand, and one for speech if a 'select' command was recently uttered.</span></span> <span data-ttu-id="aa851-140">그런 다음 각 SpatialInteractionSourceState의 속성을 검사 하 여 입력을 응용 프로그램에 추가할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="aa851-140">You can then inspect the properties on each SpatialInteractionSourceState to drive input into your application.</span></span> 

<span data-ttu-id="aa851-141">다음은 폴링 방법을 사용 하 여 ' select ' 작업을 확인 하는 방법의 예입니다.</span><span class="sxs-lookup"><span data-stu-id="aa851-141">Here is an example of how to check for the 'select' action using the polling method.</span></span> <span data-ttu-id="aa851-142">*예측* 변수는 [HolographicFrame](https://docs.microsoft.com//uwp/api/windows.graphics.holographic.holographicframe)에서 가져올 수 있는 [HolographicFramePrediction](https://docs.microsoft.com//uwp/api/Windows.Graphics.Holographic.HolographicFramePrediction) 개체를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="aa851-142">Note that the *prediction* variable represents a [HolographicFramePrediction](https://docs.microsoft.com//uwp/api/Windows.Graphics.Holographic.HolographicFramePrediction) object, which can be obtained from the [HolographicFrame](https://docs.microsoft.com//uwp/api/windows.graphics.holographic.holographicframe).</span></span>

```cpp
using namespace winrt::Windows::UI::Input::Spatial;

auto interactionManager = SpatialInteractionManager::GetForCurrentView();
auto sourceStates = m_spatialInteractionManager.GetDetectedSourcesAtTimestamp(prediction.Timestamp());

for (auto& sourceState : sourceStates)
{
    if (sourceState.IsSelectPressed())
    {
        // Select button is down, update app state
    }
}
```

<span data-ttu-id="aa851-143">각 SpatialInteractionSource에는 새 원본을 식별 하 고 기존 소스와 프레임 간에 상관 관계를 지정 하는 데 사용할 수 있는 ID가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="aa851-143">Each SpatialInteractionSource has an ID, which you can use to identify new sources and correlate existing sources from frame to frame.</span></span>  <span data-ttu-id="aa851-144">시계를 떠날 때마다 새 ID가 할당 되 고, 컨트롤러 Id는 세션 기간 동안 정적 상태로 유지 됩니다.</span><span class="sxs-lookup"><span data-stu-id="aa851-144">Hands are assigned a new ID every time they leave and enter the FOV, but controller IDs remain static for the duration of the session.</span></span>  <span data-ttu-id="aa851-145">[Sourcedetected](https://docs.microsoft.com//uwp/api/windows.ui.input.spatial.spatialinteractionmanager.sourcedetected) 와 같은 SpatialInteractionManager의 이벤트를 사용 하 여 장치 [SourceLost](https://docs.microsoft.com//uwp/api/windows.ui.input.spatial.spatialinteractionmanager.sourcelost)보기를 시작 하거나 떠날 때 또는 동작 컨트롤러를 설정/해제 하거나 페어링된 경우에 반응할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="aa851-145">You can use the events on SpatialInteractionManager such as [SourceDetected](https://docs.microsoft.com//uwp/api/windows.ui.input.spatial.spatialinteractionmanager.sourcedetected) and [SourceLost](https://docs.microsoft.com//uwp/api/windows.ui.input.spatial.spatialinteractionmanager.sourcelost), to react when hands enter or leave the device's view, or when motion controllers are turned on/off or are paired/unpaired.</span></span>

### <a name="predicted-vs-historical-poses"></a><span data-ttu-id="aa851-146">예측 및 기록 포즈</span><span class="sxs-lookup"><span data-stu-id="aa851-146">Predicted vs. historical poses</span></span>
<span data-ttu-id="aa851-147">GetDetectedSourcesAtTimestamp에 timestamp 매개 변수가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="aa851-147">Note that GetDetectedSourcesAtTimestamp has a timestamp parameter.</span></span> <span data-ttu-id="aa851-148">이를 통해 예측 또는 기록 되는 상태 및 포즈 데이터를 요청 하 여 다른 입력 소스와 공간 상호 작용의 상관 관계를 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="aa851-148">This enables you to request state and pose data that is either predicted or historical, letting you correlate spatial interactions with other sources of input.</span></span> <span data-ttu-id="aa851-149">예를 들어 현재 프레임에서 손으로의 위치를 렌더링할 때 [HolographicFrame](https://docs.microsoft.com//uwp/api/windows.graphics.holographic.holographicframe)에서 제공 하는 예측 타임 스탬프를 전달할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="aa851-149">For example, when rendering the hand's position in the current frame, you can pass in the predicted timestamp provided by the [HolographicFrame](https://docs.microsoft.com//uwp/api/windows.graphics.holographic.holographicframe).</span></span> <span data-ttu-id="aa851-150">이를 통해 시스템은 렌더링 된 프레임 출력과 긴밀 하 게 일치 하는 손 위치를 전달 하 여 인식 대기 시간을 최소화 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa851-150">This enables the system to forward-predict the hand position to closely align with the rendered frame output, minimizing perceived latency.</span></span>

<span data-ttu-id="aa851-151">그러나 이러한 예측 된 포즈는 상호 작용 소스를 대상으로 지정 하기 위한 이상적인 포인팅 광선을 생성 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="aa851-151">However, such a predicted pose does not produce an ideal pointing ray for targeting with an interaction source.</span></span> <span data-ttu-id="aa851-152">예를 들어 동작 컨트롤러 단추를 누르면 해당 이벤트가 Bluetooth를 통해 운영 체제에 20ms 최대의 시간이 걸릴 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="aa851-152">For example, when a motion controller button is pressed, it can take up to 20ms for that event to bubble up through Bluetooth to the operating system.</span></span> <span data-ttu-id="aa851-153">마찬가지로 사용자가 손 제스처를 수행한 후에는 시스템이 제스처를 검색 한 후 앱에서 해당 제스처를 폴링하기 전에 몇 시간이 경과할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="aa851-153">Similarly, after a user performs a hand gesture, some amount of time may pass before the system detects the gesture and your app then polls for it.</span></span> <span data-ttu-id="aa851-154">앱이 상태 변경에 대해 폴링하는 시간에 따라 이전에 실제로 발생 한 상호 작용을 대상으로 하는 데 사용 되는 헤드와 손을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa851-154">By the time your app polls for a state change, the head and hand poses used to target that interaction actually happened in the past.</span></span> <span data-ttu-id="aa851-155">현재 HolographicFrame의 타임 스탬프를 GetDetectedSourcesAtTimestamp에 전달 하 여 대상으로 지정 하는 경우에는 프레임이 표시 될 때이를 대상 광선으로 예측 하 게 됩니다 .이는 나중에 20ms 이상일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="aa851-155">If you target by passing your current HolographicFrame's timestamp to GetDetectedSourcesAtTimestamp, the pose will instead be forward predicted to the targeting ray at the time the frame will be displayed, which could be more than 20ms in the future.</span></span> <span data-ttu-id="aa851-156">이 향후 포즈는 상호 작용 원본을 *렌더링* 하는 데 유용 하지만 과거에 사용자의 대상 지정이 복합어 상호 작용을 *대상으로 지정* 하는 데 시간 문제가 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa851-156">This future pose is good for *rendering* the interaction source, but compounds our time problem for *targeting* the interaction, as the user's targeting occurred in the past.</span></span>

<span data-ttu-id="aa851-157">다행히 [Sourcepressed](https://docs.microsoft.com//uwp/api/windows.ui.input.spatial.spatialinteractionmanager.sourcepressed), [SourceReleased](https://docs.microsoft.com//uwp/api/windows.ui.input.spatial.spatialinteractionmanager.sourcereleased) 및 [sourcepressed](https://docs.microsoft.com//uwp/api/windows.ui.input.spatial.spatialinteractionmanager.sourceupdated) 이벤트는 각 입력 이벤트와 연결 된 기록 [상태](https://docs.microsoft.com//uwp/api/windows.ui.input.spatial.spatialinteractionsourceeventargs.state) 를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa851-157">Fortunately, the [SourcePressed](https://docs.microsoft.com//uwp/api/windows.ui.input.spatial.spatialinteractionmanager.sourcepressed), [SourceReleased](https://docs.microsoft.com//uwp/api/windows.ui.input.spatial.spatialinteractionmanager.sourcereleased) and [SourceUpdated](https://docs.microsoft.com//uwp/api/windows.ui.input.spatial.spatialinteractionmanager.sourceupdated) events provide the historical [State](https://docs.microsoft.com//uwp/api/windows.ui.input.spatial.spatialinteractionsourceeventargs.state) associated with each input event.</span></span>  <span data-ttu-id="aa851-158">여기에는이 이벤트와 상관 관계를 위해 다른 Api에 전달할 수 있는 기록 [타임 스탬프](https://docs.microsoft.com//uwp/api/windows.ui.input.spatial.spatialinteractionsourcestate.timestamp) 와 함께 [TryGetPointerPose](https://docs.microsoft.com//uwp/api/windows.ui.input.spatial.spatialinteractionsourcestate.trygetpointerpose)를 통해 사용할 수 있는 기록 헤드 및 직접 포즈가 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="aa851-158">This directly includes the historical head and hand poses available through [TryGetPointerPose](https://docs.microsoft.com//uwp/api/windows.ui.input.spatial.spatialinteractionsourcestate.trygetpointerpose), along with a historical [Timestamp](https://docs.microsoft.com//uwp/api/windows.ui.input.spatial.spatialinteractionsourcestate.timestamp) that you can pass to other APIs to correlate with this event.</span></span>

<span data-ttu-id="aa851-159">그러면 각 프레임 및 컨트롤러를 사용 하 여 렌더링 하 고 대상을 지정할 때 다음과 같은 모범 사례가 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa851-159">That leads to the following best practices when rendering and targeting with hands and controllers each frame:</span></span>
* <span data-ttu-id="aa851-160">각 프레임의 **수동/컨트롤러 렌더링** 의 경우 앱은 현재 프레임의 photon 시간에 각 상호 작용 소스의 **앞으로 예측** 된 포즈를 **폴링합니다** .</span><span class="sxs-lookup"><span data-stu-id="aa851-160">For **hand/controller rendering** each frame, your app should **poll** for the **forward-predicted** pose of each interaction source at the current frame’s photon time.</span></span>  <span data-ttu-id="aa851-161">[HolographicFrame:: CurrentPrediction](https://docs.microsoft.com//uwp/api/windows.graphics.holographic.holographicframe.currentprediction)제공 하는 예측 타임 스탬프를 전달 하 여 각 프레임 [GetDetectedSourcesAtTimestamp](https://docs.microsoft.com//uwp/api/windows.ui.input.spatial.spatialinteractionmanager.getdetectedsourcesattimestamp) 를 호출 하 여 모든 상호 작용 소스에 대해 폴링할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="aa851-161">You can poll for all interaction sources by calling [GetDetectedSourcesAtTimestamp](https://docs.microsoft.com//uwp/api/windows.ui.input.spatial.spatialinteractionmanager.getdetectedsourcesattimestamp) each frame, passing in the predicted timestamp provided by [HolographicFrame::CurrentPrediction](https://docs.microsoft.com//uwp/api/windows.graphics.holographic.holographicframe.currentprediction).</span></span>
* <span data-ttu-id="aa851-162">보도 나 릴리스를 대상으로 하는 **직접/컨트롤러를 대상** 으로 하는 경우 앱은 해당 이벤트에 대 한 **기록** 헤드 또는 핸드 포즈를 기반으로 하는 raycasting 나 눌린/릴리스 **이벤트** 를 처리 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa851-162">For **hand/controller targeting** upon a press or release, your app should handle pressed/released **events** , raycasting based on the **historical** head or hand pose for that event.</span></span> <span data-ttu-id="aa851-163">[Sourcepressed](https://docs.microsoft.com//uwp/api/windows.ui.input.spatial.spatialinteractionmanager.sourcepressed) 또는 [SourceReleased](https://docs.microsoft.com//uwp/api/windows.ui.input.spatial.spatialinteractionmanager.sourcereleased) 이벤트를 처리 하 고, 이벤트 인수에서 [State](https://docs.microsoft.com//uwp/api/windows.ui.input.spatial.spatialinteractionsourceeventargs.state) 속성을 가져온 다음, [TryGetPointerPose](https://docs.microsoft.com//uwp/api/windows.ui.input.spatial.spatialinteractionsourcestate.trygetpointerpose) 메서드를 호출 하 여이 대상 광선을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="aa851-163">You get this targeting ray by handling the [SourcePressed](https://docs.microsoft.com//uwp/api/windows.ui.input.spatial.spatialinteractionmanager.sourcepressed) or [SourceReleased](https://docs.microsoft.com//uwp/api/windows.ui.input.spatial.spatialinteractionmanager.sourcereleased) event, getting the [State](https://docs.microsoft.com//uwp/api/windows.ui.input.spatial.spatialinteractionsourceeventargs.state) property from the event arguments, and then calling its [TryGetPointerPose](https://docs.microsoft.com//uwp/api/windows.ui.input.spatial.spatialinteractionsourcestate.trygetpointerpose) method.</span></span>

## <a name="cross-device-input-properties"></a><span data-ttu-id="aa851-164">장치 간 입력 속성</span><span class="sxs-lookup"><span data-stu-id="aa851-164">Cross-device input properties</span></span>
<span data-ttu-id="aa851-165">SpatialInteractionSource API는 다양 한 기능을 갖춘 컨트롤러 및 핸드 추적 시스템을 지원 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa851-165">The SpatialInteractionSource API supports controllers and hand tracking systems with a wide range of capabilities.</span></span> <span data-ttu-id="aa851-166">이러한 기능 중 몇 가지는 장치 유형 간에 공통적으로 제공 됩니다.</span><span class="sxs-lookup"><span data-stu-id="aa851-166">A number of these capabilities are common between device types.</span></span> <span data-ttu-id="aa851-167">예를 들어 직접 추적 및 동작 컨트롤러는 모두 ' select ' 작업과 3D 위치를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa851-167">For example, hand tracking and motion controllers both provide a 'select' action and a 3D position.</span></span> <span data-ttu-id="aa851-168">가능 하면 API는 이러한 일반적인 기능을 SpatialInteractionSource의 동일한 속성에 매핑합니다.</span><span class="sxs-lookup"><span data-stu-id="aa851-168">Wherever possible, the API maps these common capabilities to the same properties on the SpatialInteractionSource.</span></span>  <span data-ttu-id="aa851-169">이를 통해 응용 프로그램은 다양 한 입력 형식을 보다 쉽게 지원할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="aa851-169">This enables applications to more easily support a wide range of input types.</span></span> <span data-ttu-id="aa851-170">다음 표에서는 지원 되는 속성과 이러한 속성이 입력 형식에서 비교 되는 방식을 설명 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa851-170">The following table describes the properties that are supported, and how they compare across input types.</span></span>

| <span data-ttu-id="aa851-171">속성</span><span class="sxs-lookup"><span data-stu-id="aa851-171">Property</span></span> | <span data-ttu-id="aa851-172">Description</span><span class="sxs-lookup"><span data-stu-id="aa851-172">Description</span></span> | <span data-ttu-id="aa851-173">HoloLens (첫 번째 gen) 제스처</span><span class="sxs-lookup"><span data-stu-id="aa851-173">HoloLens(1st gen) Gestures</span></span> | <span data-ttu-id="aa851-174">동작 컨트롤러</span><span class="sxs-lookup"><span data-stu-id="aa851-174">Motion Controllers</span></span> | <span data-ttu-id="aa851-175">트레일러 식</span><span class="sxs-lookup"><span data-stu-id="aa851-175">Articulated Hands</span></span>|
|--- |--- |--- |--- |--- |
| [<span data-ttu-id="aa851-176">SpatialInteractionSource:: **손**</span><span class="sxs-lookup"><span data-stu-id="aa851-176">SpatialInteractionSource:: **Handedness**</span></span>](https://docs.microsoft.com//uwp/api/windows.ui.input.spatial.spatialinteractionsource.handedness) | <span data-ttu-id="aa851-177">오른쪽 또는 왼쪽/컨트롤러입니다.</span><span class="sxs-lookup"><span data-stu-id="aa851-177">Right or left hand / controller.</span></span> | <span data-ttu-id="aa851-178">지원되지 않음</span><span class="sxs-lookup"><span data-stu-id="aa851-178">Not Supported</span></span> | <span data-ttu-id="aa851-179">지원됨</span><span class="sxs-lookup"><span data-stu-id="aa851-179">Supported</span></span> | <span data-ttu-id="aa851-180">지원됨</span><span class="sxs-lookup"><span data-stu-id="aa851-180">Supported</span></span> |
| [<span data-ttu-id="aa851-181">SpatialInteractionSourceState:: **Isselectpressed**</span><span class="sxs-lookup"><span data-stu-id="aa851-181">SpatialInteractionSourceState:: **IsSelectPressed**</span></span>](https://docs.microsoft.com//uwp/api/windows.ui.input.spatial.spatialinteractionsourcestate.isselectpressed) | <span data-ttu-id="aa851-182">기본 단추의 현재 상태입니다.</span><span class="sxs-lookup"><span data-stu-id="aa851-182">Current state of the primary button.</span></span> | <span data-ttu-id="aa851-183">공기 탭</span><span class="sxs-lookup"><span data-stu-id="aa851-183">Air Tap</span></span> | <span data-ttu-id="aa851-184">트리거</span><span class="sxs-lookup"><span data-stu-id="aa851-184">Trigger</span></span> | <span data-ttu-id="aa851-185">완화 공기 탭 (수직으로)</span><span class="sxs-lookup"><span data-stu-id="aa851-185">Relaxed Air Tap (upright pinch)</span></span> |
| [<span data-ttu-id="aa851-186">SpatialInteractionSourceState:: **IsGrasped**</span><span class="sxs-lookup"><span data-stu-id="aa851-186">SpatialInteractionSourceState:: **IsGrasped**</span></span>](https://docs.microsoft.com//uwp/api/windows.ui.input.spatial.spatialinteractionsourcestate.isgrasped) | <span data-ttu-id="aa851-187">잡기 단추의 현재 상태입니다.</span><span class="sxs-lookup"><span data-stu-id="aa851-187">Current state of the grab button.</span></span> | <span data-ttu-id="aa851-188">지원되지 않음</span><span class="sxs-lookup"><span data-stu-id="aa851-188">Not Supported</span></span> | <span data-ttu-id="aa851-189">잡기 단추</span><span class="sxs-lookup"><span data-stu-id="aa851-189">Grab button</span></span> | <span data-ttu-id="aa851-190">손가락으로 나 폐쇄</span><span class="sxs-lookup"><span data-stu-id="aa851-190">Pinch or Closed Hand</span></span> |
| [<span data-ttu-id="aa851-191">SpatialInteractionSourceState:: **IsMenuPressed**</span><span class="sxs-lookup"><span data-stu-id="aa851-191">SpatialInteractionSourceState:: **IsMenuPressed**</span></span>](https://docs.microsoft.com//uwp/api/windows.ui.input.spatial.spatialinteractionsourcestate.ismenupressed) | <span data-ttu-id="aa851-192">메뉴 단추의 현재 상태입니다.</span><span class="sxs-lookup"><span data-stu-id="aa851-192">Current state of the menu button.</span></span>    | <span data-ttu-id="aa851-193">지원되지 않음</span><span class="sxs-lookup"><span data-stu-id="aa851-193">Not Supported</span></span> | <span data-ttu-id="aa851-194">메뉴 단추</span><span class="sxs-lookup"><span data-stu-id="aa851-194">Menu Button</span></span> | <span data-ttu-id="aa851-195">지원되지 않음</span><span class="sxs-lookup"><span data-stu-id="aa851-195">Not Supported</span></span> |
| [<span data-ttu-id="aa851-196">SpatialInteractionSourceLocation:: **Position**</span><span class="sxs-lookup"><span data-stu-id="aa851-196">SpatialInteractionSourceLocation:: **Position**</span></span>](https://docs.microsoft.com//uwp/api/windows.ui.input.spatial.spatialinteractionsourcelocation.position) | <span data-ttu-id="aa851-197">컨트롤러에서 손 모양 또는 그립 위치의 XYZ 위치입니다.</span><span class="sxs-lookup"><span data-stu-id="aa851-197">XYZ location of the hand or grip position on the controller.</span></span> | <span data-ttu-id="aa851-198">팜 위치</span><span class="sxs-lookup"><span data-stu-id="aa851-198">Palm location</span></span> | <span data-ttu-id="aa851-199">그립 포즈 위치</span><span class="sxs-lookup"><span data-stu-id="aa851-199">Grip pose position</span></span> | <span data-ttu-id="aa851-200">팜 위치</span><span class="sxs-lookup"><span data-stu-id="aa851-200">Palm location</span></span> |
| [<span data-ttu-id="aa851-201">SpatialInteractionSourceLocation:: **Orientation**</span><span class="sxs-lookup"><span data-stu-id="aa851-201">SpatialInteractionSourceLocation:: **Orientation**</span></span>](https://docs.microsoft.com//uwp/api/windows.ui.input.spatial.spatialinteractionsourcelocation.orientation) | <span data-ttu-id="aa851-202">컨트롤러에서 손 방향 또는 그립 포즈를 나타내는 4 원수입니다.</span><span class="sxs-lookup"><span data-stu-id="aa851-202">Quaternion representing the orientation of the hand or grip pose on the controller.</span></span> | <span data-ttu-id="aa851-203">지원되지 않음</span><span class="sxs-lookup"><span data-stu-id="aa851-203">Not Supported</span></span> | <span data-ttu-id="aa851-204">그립 포즈 방향</span><span class="sxs-lookup"><span data-stu-id="aa851-204">Grip pose orientation</span></span> | <span data-ttu-id="aa851-205">팜 방향</span><span class="sxs-lookup"><span data-stu-id="aa851-205">Palm orientation</span></span> |
| [<span data-ttu-id="aa851-206">SpatialPointerInteractionSourcePose:: **Position**</span><span class="sxs-lookup"><span data-stu-id="aa851-206">SpatialPointerInteractionSourcePose:: **Position**</span></span>](https://docs.microsoft.com//uwp/api/windows.ui.input.spatial.spatialpointerinteractionsourcepose.position#Windows_UI_Input_Spatial_SpatialPointerInteractionSourcePose_Position) | <span data-ttu-id="aa851-207">포인팅 광선의 원점입니다.</span><span class="sxs-lookup"><span data-stu-id="aa851-207">Origin of the pointing ray.</span></span> | <span data-ttu-id="aa851-208">지원되지 않음</span><span class="sxs-lookup"><span data-stu-id="aa851-208">Not Supported</span></span> | <span data-ttu-id="aa851-209">지원됨</span><span class="sxs-lookup"><span data-stu-id="aa851-209">Supported</span></span> | <span data-ttu-id="aa851-210">지원됨</span><span class="sxs-lookup"><span data-stu-id="aa851-210">Supported</span></span> |
| [<span data-ttu-id="aa851-211">SpatialPointerInteractionSourcePose:: **Forwarddirection**</span><span class="sxs-lookup"><span data-stu-id="aa851-211">SpatialPointerInteractionSourcePose:: **ForwardDirection**</span></span>](https://docs.microsoft.com//uwp/api/windows.ui.input.spatial.spatialpointerinteractionsourcepose.forwarddirection#Windows_UI_Input_Spatial_SpatialPointerInteractionSourcePose_ForwardDirection) | <span data-ttu-id="aa851-212">포인팅 광선의 방향입니다.</span><span class="sxs-lookup"><span data-stu-id="aa851-212">Direction of the pointing ray.</span></span> | <span data-ttu-id="aa851-213">지원되지 않음</span><span class="sxs-lookup"><span data-stu-id="aa851-213">Not Supported</span></span> | <span data-ttu-id="aa851-214">지원됨</span><span class="sxs-lookup"><span data-stu-id="aa851-214">Supported</span></span> | <span data-ttu-id="aa851-215">지원됨</span><span class="sxs-lookup"><span data-stu-id="aa851-215">Supported</span></span> |

<span data-ttu-id="aa851-216">일부 속성은 일부 장치에서 사용할 수 없으며 API는이에 대 한 테스트 수단을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa851-216">Some of the above properties are not available on all devices, and the API provides a means to test for this.</span></span> <span data-ttu-id="aa851-217">예를 들어 [SpatialInteractionSource:: Isgrsupported](https://docs.microsoft.com//uwp/api/windows.ui.input.spatial.spatialinteractionsource.isgraspsupported) 속성을 검사 하 여 원본에서 판단 동작을 제공 하는지 여부를 확인할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="aa851-217">For example, you can inspect the [SpatialInteractionSource::IsGraspSupported](https://docs.microsoft.com//uwp/api/windows.ui.input.spatial.spatialinteractionsource.isgraspsupported) property to determine whether the source provides a grasp action.</span></span>

### <a name="grip-pose-vs-pointing-pose"></a><span data-ttu-id="aa851-218">그립 포즈 및 포인팅 포즈</span><span class="sxs-lookup"><span data-stu-id="aa851-218">Grip pose vs. pointing pose</span></span>

<span data-ttu-id="aa851-219">Windows Mixed Reality는 다양 한 폼 팩터에서 동작 컨트롤러를 지원 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa851-219">Windows Mixed Reality supports motion controllers in a variety of form factors.</span></span>  <span data-ttu-id="aa851-220">또한 트레일러 식 추적 시스템도 지원 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa851-220">It also supports articulated hand tracking systems.</span></span>  <span data-ttu-id="aa851-221">이러한 모든 시스템에는 앱이 사용자 손으로 개체를 가리키거나 렌더링 하는 데 사용 해야 하는 손 위치와 자연 스러운 "전달" 방향 간에 서로 다른 관계가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="aa851-221">All of these systems have different relationships between the hand position and the natural "forward" direction that apps should use for pointing or rendering objects in the user's hand.</span></span>  <span data-ttu-id="aa851-222">이를 모두 지원 하기 위해 직접 추적 및 동작 컨트롤러 모두에 두 가지 유형의 3D 포즈를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa851-222">To support all of this, there are two types of 3D poses provided for both hand tracking and motion controllers.</span></span>  <span data-ttu-id="aa851-223">첫 번째는 그립 포즈 이며 사용자의 손 위치를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="aa851-223">The first is grip pose, which represents the user's hand position.</span></span>  <span data-ttu-id="aa851-224">두 번째는 사용자의 손 또는 컨트롤러에서 시작 하는 광선을 나타내는 포즈를 가리킵니다.</span><span class="sxs-lookup"><span data-stu-id="aa851-224">The second is pointing pose, which represents a pointing ray originating from the user's hand or controller.</span></span> <span data-ttu-id="aa851-225">따라서 사용자의 손을 또는 소드와 같은 **사용자의 손으로 저장 된 개체** **를 렌더링 하려면** 그립 포즈를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa851-225">So, if you want to render **the user's hand** or **an object held in the user's hand** , such as a sword or gun, use the grip pose.</span></span> <span data-ttu-id="aa851-226">예를 들어 사용자가 **UI를 가리키고** 있는 경우와 같이 컨트롤러에서 raycast를 사용 하려는 경우 포인팅 포즈를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa851-226">If you want to raycast from the controller or hand, for example when the user is **pointing at UI** , use the pointing pose.</span></span>

<span data-ttu-id="aa851-227">[SpatialInteractionSourceState::P roperties:: TryGetLocation (...)](https://docs.microsoft.com//uwp/api/windows.ui.input.spatial.spatialinteractionsourceproperties.trygetlocation#Windows_UI_Input_Spatial_SpatialInteractionSourceProperties_TryGetLocation_Windows_Perception_Spatial_SpatialCoordinateSystem_)을 통해 **그립 포즈** 에 액세스할 수 있습니다.  다음과 같이 정의 됩니다.</span><span class="sxs-lookup"><span data-stu-id="aa851-227">You can access the **grip pose** through [SpatialInteractionSourceState::Properties::TryGetLocation(...)](https://docs.microsoft.com//uwp/api/windows.ui.input.spatial.spatialinteractionsourceproperties.trygetlocation#Windows_UI_Input_Spatial_SpatialInteractionSourceProperties_TryGetLocation_Windows_Perception_Spatial_SpatialCoordinateSystem_).  It is defined as follows:</span></span>
* <span data-ttu-id="aa851-228">**그립 위치** : 컨트롤러를 자연스럽 게 유지 하는 경우 왼쪽 또는 오른쪽으로 조정 하 여 그립 내 위치를 가운데에 맞춥니다.</span><span class="sxs-lookup"><span data-stu-id="aa851-228">The **grip position** : The palm centroid when holding the controller naturally, adjusted left or right to center the position within the grip.</span></span>
* <span data-ttu-id="aa851-229">**그립 방향 오른쪽 축** : 손 모양 5 손가락 포즈를 형성 하는 손을 완전히 열 때 palm (왼쪽 야자나무에서 오른쪽으로 뒤로)의 광선을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="aa851-229">The **grip orientation's Right axis** : When you completely open your hand to form a flat 5-finger pose, the ray that is normal to your palm (forward from left palm, backward from right palm)</span></span>
* <span data-ttu-id="aa851-230">**그립 방향 전방 축: 핸들** 을 부분적으로 (컨트롤러를 보유 하는 것 처럼) 닫는 경우 비 엄지 손가락으로 형성 된 튜브를 통해 "전달" 하는 광선이 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="aa851-230">The **grip orientation's Forward axis** : When you close your hand partially (as if holding the controller), the ray that points "forward" through the tube formed by your non-thumb fingers.</span></span>
* <span data-ttu-id="aa851-231">**그립 방향 up 축** : 오른쪽 및 전방 정의에 의해 암시 된 위쪽 축입니다.</span><span class="sxs-lookup"><span data-stu-id="aa851-231">The **grip orientation's Up axis** : The Up axis implied by the Right and Forward definitions.</span></span>

<span data-ttu-id="aa851-232">[SpatialInteractionSourceState::P roperties:: TryGetLocation (...):: SourcePointerPose](https://docs.microsoft.com/uwp/api/windows.ui.input.spatial.spatialinteractionsourcelocation#Windows_UI_Input_Spatial_SpatialInteractionSourceLocation_SourcePointerPose) 또는 [SpatialInteractionSourceState:: TryGetPointerPose (...):: TryGetInteractionSourcePose](https://docs.microsoft.com/uwp/api/windows.ui.input.spatial.spatialpointerpose#Windows_UI_Input_Spatial_SpatialPointerPose_TryGetInteractionSourcePose_Windows_UI_Input_Spatial_SpatialInteractionSource_)를 통해 **포인터 포즈** 에 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="aa851-232">You can access the **pointer pose** through [SpatialInteractionSourceState::Properties::TryGetLocation(...)::SourcePointerPose](https://docs.microsoft.com/uwp/api/windows.ui.input.spatial.spatialinteractionsourcelocation#Windows_UI_Input_Spatial_SpatialInteractionSourceLocation_SourcePointerPose) or [SpatialInteractionSourceState::TryGetPointerPose(...)::TryGetInteractionSourcePose](https://docs.microsoft.com/uwp/api/windows.ui.input.spatial.spatialpointerpose#Windows_UI_Input_Spatial_SpatialPointerPose_TryGetInteractionSourcePose_Windows_UI_Input_Spatial_SpatialInteractionSource_).</span></span>

## <a name="controller-specific-input-properties"></a><span data-ttu-id="aa851-233">컨트롤러 특정 입력 속성</span><span class="sxs-lookup"><span data-stu-id="aa851-233">Controller-specific input properties</span></span>
<span data-ttu-id="aa851-234">컨트롤러의 경우 SpatialInteractionSource에는 추가 기능이 있는 컨트롤러 속성이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="aa851-234">For controllers, the SpatialInteractionSource has a Controller property with additional capabilities.</span></span>
* <span data-ttu-id="aa851-235">**Hasthumbstick 스틱:** True 이면 컨트롤러에 엄지 스틱이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="aa851-235">**HasThumbstick:** If true, the controller has a thumbstick.</span></span> <span data-ttu-id="aa851-236">SpatialInteractionSourceState의 [Controllerproperties](https://docs.microsoft.com/uwp/api/windows.ui.input.spatial.spatialinteractioncontrollerproperties) 속성을 검사 하 여 엄지 스틱 x 및 y 값 (ThumbstickX 및 ThumbstickY) 뿐만 아니라 눌린 상태 (IsThumbstickPressed)를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="aa851-236">Inspect the [ControllerProperties](https://docs.microsoft.com/uwp/api/windows.ui.input.spatial.spatialinteractioncontrollerproperties) property of the SpatialInteractionSourceState to acquire the thumbstick x and y values (ThumbstickX and ThumbstickY), as well as its pressed state (IsThumbstickPressed).</span></span>
* <span data-ttu-id="aa851-237">**HasTouchpad:** True 이면 컨트롤러에 터치 패드가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="aa851-237">**HasTouchpad:** If true, the controller has a touchpad.</span></span> <span data-ttu-id="aa851-238">SpatialInteractionSourceState의 ControllerProperties 속성을 검사 하 여 터치 패드 x 및 y 값 (TouchpadX 및 TouchpadY)을 획득 하 고 사용자가 pad (IsTouchpadTouched)와 접촉 하 고 있는지 여부를 확인 합니다 (IsTouchpadPressed).</span><span class="sxs-lookup"><span data-stu-id="aa851-238">Inspect the ControllerProperties property of the SpatialInteractionSourceState to acquire the touchpad x and y values (TouchpadX and TouchpadY), and to know if the user is touching the pad (IsTouchpadTouched) and if they are pressing the touchpad down (IsTouchpadPressed).</span></span>
* <span data-ttu-id="aa851-239">**SimpleHapticsController:** 컨트롤러에 대 한 SimpleHapticsController API를 사용 하면 컨트롤러의 haptics 기능을 검사 하 고 햅 피드백을 제어할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="aa851-239">**SimpleHapticsController:** The SimpleHapticsController API for the controller allows you to inspect the haptics capabilities of the controller, and it also allows you to control haptic feedback.</span></span>

<span data-ttu-id="aa851-240">터치 패드 및 엄지 스틱의 범위는 양쪽 축 (아래쪽에서 위쪽, 왼쪽에서 오른쪽)에 대해-1에서 1 사이입니다.</span><span class="sxs-lookup"><span data-stu-id="aa851-240">Note that the range for touchpad and thumbstick is -1 to 1 for both axes (from bottom to top, and from left to right).</span></span> <span data-ttu-id="aa851-241">SpatialInteractionSourceState:: Select보도 Sedvalue 속성을 사용 하 여 액세스 되는 아날로그 트리거의 범위는 0에서 1 사이입니다.</span><span class="sxs-lookup"><span data-stu-id="aa851-241">The range for the analog trigger, which is accessed using the SpatialInteractionSourceState::SelectPressedValue property, has a range of 0 to 1.</span></span> <span data-ttu-id="aa851-242">값 1은 IsSelectPressed이 true가 되는 것과 관련이 있습니다. 다른 모든 값은 false와 동일 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa851-242">A value of 1 correlates with IsSelectPressed being equal to true; any other value correlates with IsSelectPressed being equal to false.</span></span>

## <a name="articulated-hand-tracking"></a><span data-ttu-id="aa851-243">트레일러 식 추적</span><span class="sxs-lookup"><span data-stu-id="aa851-243">Articulated hand tracking</span></span>
<span data-ttu-id="aa851-244">Windows Mixed Reality API는 HoloLens 2와 같이 트레일러 식 추적을 완벽 하 게 지원 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa851-244">The Windows Mixed Reality API provides full support for articulated hand tracking, for example on HoloLens 2.</span></span> <span data-ttu-id="aa851-245">트레일러 식 추적을 사용 하 여 응용 프로그램에서 직접 조작 및 지점 및 커밋 입력 모델을 구현할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="aa851-245">Articulated hand tracking can be used to implement direct manipulation and point-and-commit input models in your applications.</span></span> <span data-ttu-id="aa851-246">이 클래스를 사용 하 여 완전 한 사용자 지정 상호 작용을 작성할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="aa851-246">It can also be used to author fully custom interactions.</span></span>

### <a name="hand-skeleton"></a><span data-ttu-id="aa851-247">직접 기초</span><span class="sxs-lookup"><span data-stu-id="aa851-247">Hand skeleton</span></span>
<span data-ttu-id="aa851-248">트레일러 식 추적은 다양 한 유형의 상호 작용을 가능 하 게 하는 25 개의 공동 구조를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa851-248">Articulated hand tracking provides a 25 joint skeleton that enables many different types of interactions.</span></span>  <span data-ttu-id="aa851-249">뼈대는 인덱스/중간/링/작은 손가락에 대해 5 개의 조인트, 엄지 단추에 대 한 4 개의 조인트 및 1 개의 손목 조인트를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa851-249">The skeleton provides 5 joints for the index/middle/ring/little fingers, 4 joints for the thumb, and 1 wrist joint.</span></span>  <span data-ttu-id="aa851-250">손목 조인트는 계층의 기반으로 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="aa851-250">The wrist joint serves as the base of the hierarchy.</span></span> <span data-ttu-id="aa851-251">다음 그림은 해골의 레이아웃을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="aa851-251">The following picture illustrates the layout of the skeleton.</span></span>

![직접 기초](images/hand-skeleton.png)

<span data-ttu-id="aa851-253">대부분의 경우 각 조인트는 나타내는 뼈에 따라 이름이 지정 됩니다.</span><span class="sxs-lookup"><span data-stu-id="aa851-253">In most cases, each joint is named based on the bone that it represents.</span></span>  <span data-ttu-id="aa851-254">모든 조인트에는 두 개의 뼈가 있기 때문에 해당 위치에서 자식 뼈를 기준으로 각 조인트의 이름을 지정 하는 규칙을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa851-254">Since there are two bones at every joint, we use a convention of naming each joint based on the child bone at that location.</span></span>  <span data-ttu-id="aa851-255">자식 뼈는 손목의 뼈로 정의 됩니다.</span><span class="sxs-lookup"><span data-stu-id="aa851-255">The child bone is defined as the bone further from the wrist.</span></span>  <span data-ttu-id="aa851-256">예를 들어 "Index Proximal" 조인트에는 인덱스 Proximal 뼈의 시작 위치와 해당 뼈의 방향이 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="aa851-256">For example, the "Index Proximal" joint contains the beginning position of the index proximal bone, and the orientation of that bone.</span></span>  <span data-ttu-id="aa851-257">뼈의 끝 위치를 포함 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="aa851-257">It does not contain the ending position of the bone.</span></span>  <span data-ttu-id="aa851-258">이를 필요로 하는 경우 계층의 다음 조인트 인 "인덱스 중간" 조인트에서 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="aa851-258">If you need that, you'd get it from the next joint in the hierarchy, the "Index Intermediate" joint.</span></span>

<span data-ttu-id="aa851-259">25 개의 계층 구조 조인트 외에도 시스템은 palm 조인트를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa851-259">In addition to the 25 hierarchical joints, the system provides a palm joint.</span></span>  <span data-ttu-id="aa851-260">팜은 일반적으로 골격 구조의 일부로 간주 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="aa851-260">The palm is not typically considered part of the skeletal structure.</span></span>  <span data-ttu-id="aa851-261">이는 직접 전체 위치와 방향을 가져오는 편리한 방법 으로만 제공 됩니다.</span><span class="sxs-lookup"><span data-stu-id="aa851-261">It is provided only as a convenient way to get the hand's overall position and orientation.</span></span>

<span data-ttu-id="aa851-262">각 조인트에 대해 다음과 같은 정보가 제공 됩니다.</span><span class="sxs-lookup"><span data-stu-id="aa851-262">The following information is provided for each joint:</span></span>

| <span data-ttu-id="aa851-263">Name</span><span class="sxs-lookup"><span data-stu-id="aa851-263">Name</span></span> | <span data-ttu-id="aa851-264">Description</span><span class="sxs-lookup"><span data-stu-id="aa851-264">Description</span></span> |
|--- |--- |
|<span data-ttu-id="aa851-265">위치</span><span class="sxs-lookup"><span data-stu-id="aa851-265">Position</span></span> | <span data-ttu-id="aa851-266">모든 요청 된 좌표계에서 사용할 수 있는 조인트의 3D 위치입니다.</span><span class="sxs-lookup"><span data-stu-id="aa851-266">3D position of the joint, available in any requested coordinate system.</span></span> |
|<span data-ttu-id="aa851-267">방향</span><span class="sxs-lookup"><span data-stu-id="aa851-267">Orientation</span></span> | <span data-ttu-id="aa851-268">요청 된 좌표계에서 사용할 수 있는 뼈의 3D 방향입니다.</span><span class="sxs-lookup"><span data-stu-id="aa851-268">3D orientation of the bone, available in any requested coordinate system.</span></span> |
|<span data-ttu-id="aa851-269">반지름</span><span class="sxs-lookup"><span data-stu-id="aa851-269">Radius</span></span> | <span data-ttu-id="aa851-270">조인트 위치에서 스킨 표면의 표면 까지의 거리입니다.</span><span class="sxs-lookup"><span data-stu-id="aa851-270">Distance to surface of the skin at the joint position.</span></span> <span data-ttu-id="aa851-271">손가락 너비를 사용 하는 직접 상호 작용 또는 시각화를 조정 하는 데 유용 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa851-271">Useful for tuning direct interactions or visualizations that rely on finger width.</span></span> |
|<span data-ttu-id="aa851-272">정확도</span><span class="sxs-lookup"><span data-stu-id="aa851-272">Accuracy</span></span> | <span data-ttu-id="aa851-273">시스템에서이 공동 정보를 확실 하 게 판단 하는 방법에 대 한 힌트를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa851-273">Provides a hint on how confident the system feels about this joint's information.</span></span> |

<span data-ttu-id="aa851-274">[SpatialInteractionSourceState](https://docs.microsoft.com//uwp/api/windows.ui.input.spatial.spatialinteractionsourcestate)에서 함수를 통해 손 레 톤 데이터에 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="aa851-274">You can access the hand skeleton data through a function on the [SpatialInteractionSourceState](https://docs.microsoft.com//uwp/api/windows.ui.input.spatial.spatialinteractionsourcestate).</span></span>  <span data-ttu-id="aa851-275">함수는 [TryGetHandPose](https://docs.microsoft.com//uwp/api/windows.ui.input.spatial.spatialinteractionsourcestate.trygethandpose#Windows_UI_Input_Spatial_SpatialInteractionSourceState_TryGetHandPose)라고 하며,이 함수는 [핸드 포즈](https://docs.microsoft.com//uwp/api/windows.perception.people.handpose)라는 개체를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa851-275">The function is called [TryGetHandPose](https://docs.microsoft.com//uwp/api/windows.ui.input.spatial.spatialinteractionsourcestate.trygethandpose#Windows_UI_Input_Spatial_SpatialInteractionSourceState_TryGetHandPose), and it returns an object called [HandPose](https://docs.microsoft.com//uwp/api/windows.perception.people.handpose).</span></span>  <span data-ttu-id="aa851-276">원본에서 트레일러를 지원 하지 않는 경우이 함수는 null을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa851-276">If the source does not support articulated hands, then this function will return null.</span></span>  <span data-ttu-id="aa851-277">수동 포즈를 사용 하는 경우 관심 있는 조인트의 이름으로 [TryGetJoint](https://docs.microsoft.com//uwp/api/windows.perception.people.handpose.trygetjoint#Windows_Perception_People_HandPose_TryGetJoint_Windows_Perception_Spatial_SpatialCoordinateSystem_Windows_Perception_People_HandJointKind_Windows_Perception_People_JointPose__)를 호출 하 여 현재 공동 데이터를 가져올 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="aa851-277">Once you have a HandPose, you can get current joint data by calling [TryGetJoint](https://docs.microsoft.com//uwp/api/windows.perception.people.handpose.trygetjoint#Windows_Perception_People_HandPose_TryGetJoint_Windows_Perception_Spatial_SpatialCoordinateSystem_Windows_Perception_People_HandJointKind_Windows_Perception_People_JointPose__), with the name of the joint you are interested in.</span></span>  <span data-ttu-id="aa851-278">데이터는 [JointPose](https://docs.microsoft.com//uwp/api/windows.perception.people.jointpose) 구조체로 반환 됩니다.</span><span class="sxs-lookup"><span data-stu-id="aa851-278">The data is returned as a [JointPose](https://docs.microsoft.com//uwp/api/windows.perception.people.jointpose) structure.</span></span>  <span data-ttu-id="aa851-279">다음 코드는 인덱스 손가락 팁의 위치를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="aa851-279">The following code gets the position of the index finger tip.</span></span> <span data-ttu-id="aa851-280">*CurrentState* 변수는 [SpatialInteractionSourceState](https://docs.microsoft.com//uwp/api/windows.ui.input.spatial.spatialinteractionsourcestate)의 인스턴스를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="aa851-280">The variable *currentState* represents an instance of [SpatialInteractionSourceState](https://docs.microsoft.com//uwp/api/windows.ui.input.spatial.spatialinteractionsourcestate).</span></span>

```cpp
using namespace winrt::Windows::Perception::People;
using namespace winrt::Windows::Foundation::Numerics;

auto handPose = currentState.TryGetHandPose();
if (handPose)
{
    JointPose joint;
    if (handPose.TryGetJoint(desiredCoordinateSystem, HandJointKind::IndexTip, joint))
    {
        float3 indexTipPosition = joint.Position;

        // Do something with the index tip position
    }
}
```

### <a name="hand-mesh"></a><span data-ttu-id="aa851-281">손 모양 메시</span><span class="sxs-lookup"><span data-stu-id="aa851-281">Hand mesh</span></span>

<span data-ttu-id="aa851-282">트레일러 식 추적 API는 완전히 deformable 삼각형 손 모양 메시를 허용 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa851-282">The articulated hand tracking API allows for a fully deformable triangle hand mesh.</span></span>  <span data-ttu-id="aa851-283">이 메시는 수동 구조와 함께 실시간으로 변형 될 수 있으며, 고급 물리학 기술 뿐만 아니라 시각화에도 유용 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa851-283">This mesh can deform in real time along with the hand skeleton, and is useful for visualization as well as advanced physics techniques.</span></span>  <span data-ttu-id="aa851-284">손 메시에 액세스 하려면 먼저 [SpatialInteractionSource](https://docs.microsoft.com//uwp/api/windows.ui.input.spatial.spatialinteractionsource)에서 [TryCreateHandMeshObserverAsync](https://docs.microsoft.com//uwp/api/windows.ui.input.spatial.spatialinteractionsource.trycreatehandmeshobserverasync) 를 호출 하 여 [HandMeshObserver](https://docs.microsoft.com//uwp/api/windows.perception.people.handmeshobserver) 개체를 만들어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa851-284">To access the hand mesh, you need to first create a [HandMeshObserver](https://docs.microsoft.com//uwp/api/windows.perception.people.handmeshobserver) object by calling [TryCreateHandMeshObserverAsync](https://docs.microsoft.com//uwp/api/windows.ui.input.spatial.spatialinteractionsource.trycreatehandmeshobserverasync) on the [SpatialInteractionSource](https://docs.microsoft.com//uwp/api/windows.ui.input.spatial.spatialinteractionsource).</span></span>  <span data-ttu-id="aa851-285">일반적으로이 작업은 소스 마다 한 번만 수행 하면 됩니다. 일반적으로이 작업은 처음에 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="aa851-285">This only needs to be done once per source, typically the first time you see it.</span></span>  <span data-ttu-id="aa851-286">즉,이 함수를 호출 하 여 HandMeshObserver 개체를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="aa851-286">That means you'll call this function to create a HandMeshObserver object whenever a hand enters the FOV.</span></span>  <span data-ttu-id="aa851-287">비동기 함수 이므로 여기서는 약간의 동시성을 처리 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa851-287">Note that this is an async function, so you'll have to deal with a bit of concurrency here.</span></span>  <span data-ttu-id="aa851-288">사용 가능한 경우 [GetTriangleIndices](https://docs.microsoft.com//uwp/api/windows.perception.people.handmeshobserver.gettriangleindices#Windows_Perception_People_HandMeshObserver_GetTriangleIndices_System_UInt16___)를 호출 하 여 HandMeshObserver 개체에 삼각형 인덱스 버퍼를 요청할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="aa851-288">Once available, you can ask the HandMeshObserver object for the triangle index buffer by calling [GetTriangleIndices](https://docs.microsoft.com//uwp/api/windows.perception.people.handmeshobserver.gettriangleindices#Windows_Perception_People_HandMeshObserver_GetTriangleIndices_System_UInt16___).</span></span>  <span data-ttu-id="aa851-289">인덱스는 프레임 위로 프레임을 변경 하지 않으므로 해당 항목을 한 번 가져와 소스의 수명 동안 캐시할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="aa851-289">Indices don't change frame over frame, so you can get those once and cache them for the lifetime of the source.</span></span>  <span data-ttu-id="aa851-290">인덱스는 시계 방향 권선 순서로 제공 됩니다.</span><span class="sxs-lookup"><span data-stu-id="aa851-290">Indices are provided in clockwise winding order.</span></span>

<span data-ttu-id="aa851-291">다음 코드는 분리 된 std:: thread를 회전 하 여 메시 관찰자를 만들고 메시 관찰자를 사용할 수 있게 되 면 인덱스 버퍼를 추출 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa851-291">The following code spins up a detached std::thread to create the mesh observer and extracts the index buffer once the mesh observer is available.</span></span>  <span data-ttu-id="aa851-292">추적 된 손을 나타내는 [SpatialInteractionSourceState](https://docs.microsoft.com//uwp/api/windows.ui.input.spatial.spatialinteractionsourcestate) 인스턴스인 *currentState* 라는 변수에서 시작 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa851-292">It starts from a variable called *currentState* , which is an instance of [SpatialInteractionSourceState](https://docs.microsoft.com//uwp/api/windows.ui.input.spatial.spatialinteractionsourcestate) representing a tracked hand.</span></span>

```cpp
using namespace Windows::Perception::People;

std::thread createObserverThread([this, currentState]()
{
    HandMeshObserver newHandMeshObserver = currentState.Source().TryCreateHandMeshObserverAsync().get();
    if (newHandMeshObserver)
    {
        unsigned indexCount = newHandMeshObserver.TriangleIndexCount();
        vector<unsigned short> indices(indexCount);
        newHandMeshObserver.GetTriangleIndices(indices);

        // Save the indices and handMeshObserver for later use - and use a mutex to synchronize access if needed!
     }
});
createObserverThread.detach();
```
<span data-ttu-id="aa851-293">분리 된 스레드를 시작 하는 것은 비동기 호출을 처리 하는 한 가지 옵션입니다.</span><span class="sxs-lookup"><span data-stu-id="aa851-293">Starting a detached thread is just one option for handling async calls.</span></span>  <span data-ttu-id="aa851-294">또는 c + +/WinRT.에서 지 원하는 새로운 [co_await](https://docs.microsoft.com//windows/uwp/cpp-and-winrt-apis/concurrency) 기능을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="aa851-294">Alternatively, you could use the new [co_await](https://docs.microsoft.com//windows/uwp/cpp-and-winrt-apis/concurrency) functionality supported by C++/WinRT.</span></span>

<span data-ttu-id="aa851-295">HandMeshObserver 개체를 만든 후에는 해당 SpatialInteractionSource 활성화 된 기간 동안 해당 개체를 유지 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa851-295">Once you have a HandMeshObserver object, you should hold onto it for the duration that its corresponding SpatialInteractionSource is active.</span></span>  <span data-ttu-id="aa851-296">그런 다음, 각 프레임에서 [GetVertexStateForPose](https://docs.microsoft.com//uwp/api/windows.perception.people.handmeshobserver.getvertexstateforpose) 를 호출 하 고 꼭 짓 점을 나타내는 [핸드](https://docs.microsoft.com//uwp/api/windows.perception.people.handpose) 포즈 인스턴스를 전달 하 여 손을 나타내는 최신 꼭 짓 점 버퍼에 대해 요청할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="aa851-296">Then each frame, you can ask it for the latest vertex buffer that represents the hand by calling [GetVertexStateForPose](https://docs.microsoft.com//uwp/api/windows.perception.people.handmeshobserver.getvertexstateforpose) and passing in a [HandPose](https://docs.microsoft.com//uwp/api/windows.perception.people.handpose) instance that represents the pose that you want vertices for.</span></span>  <span data-ttu-id="aa851-297">버퍼의 각 꼭 짓 점은 위치 및 법선입니다.</span><span class="sxs-lookup"><span data-stu-id="aa851-297">Each vertex in the buffer has a position and a normal.</span></span>  <span data-ttu-id="aa851-298">다음은 손 메시의 현재 꼭 짓 점 집합을 가져오는 방법의 예입니다.</span><span class="sxs-lookup"><span data-stu-id="aa851-298">Here's an example of how to get the current set of vertices for a hand mesh.</span></span>  <span data-ttu-id="aa851-299">이전과 마찬가지로 *currentState* 변수는 [SpatialInteractionSourceState](https://docs.microsoft.com//uwp/api/windows.ui.input.spatial.spatialinteractionsourcestate)의 인스턴스를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="aa851-299">Just as before, the *currentState* variable represents an instance of [SpatialInteractionSourceState](https://docs.microsoft.com//uwp/api/windows.ui.input.spatial.spatialinteractionsourcestate).</span></span>

```cpp
using namespace winrt::Windows::Perception::People;

auto handPose = currentState.TryGetHandPose();
if (handPose)
{
    std::vector<HandMeshVertex> vertices(handMeshObserver.VertexCount());
    auto vertexState = handMeshObserver.GetVertexStateForPose(handPose);
    vertexState.GetVertices(vertices);

    auto meshTransform = vertexState.CoordinateSystem().TryGetTransformTo(desiredCoordinateSystem);
    if (meshTransform != nullptr)
    {
        // Do something with the vertices and mesh transform, along with the indices that you saved earlier
    }
}
```

<span data-ttu-id="aa851-300">기본 조인트와는 달리, 손 모양 메시 API를 사용 하 여 꼭 짓 점의 좌표계를 지정할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="aa851-300">In contrast to skeleton joints, the hand mesh API does not allow you to specify a coordinate system for the vertices.</span></span>  <span data-ttu-id="aa851-301">대신 [HandMeshVertexState](https://docs.microsoft.com//uwp/api/windows.perception.people.handmeshvertexstate) 는 꼭 짓 점이 제공 되는 좌표계를 지정 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa851-301">Instead, the [HandMeshVertexState](https://docs.microsoft.com//uwp/api/windows.perception.people.handmeshvertexstate) specifies the coordinate system that the vertices are provided in.</span></span>  <span data-ttu-id="aa851-302">그런 다음 [TryGetTransformTo](https://docs.microsoft.com//uwp/api/windows.perception.spatial.spatialcoordinatesystem.trygettransformto#Windows_Perception_Spatial_SpatialCoordinateSystem_TryGetTransformTo_Windows_Perception_Spatial_SpatialCoordinateSystem_) 를 호출 하 고 원하는 좌표계를 지정 하 여 메시 변환을 가져올 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="aa851-302">You can then get a mesh transform by calling [TryGetTransformTo](https://docs.microsoft.com//uwp/api/windows.perception.spatial.spatialcoordinatesystem.trygettransformto#Windows_Perception_Spatial_SpatialCoordinateSystem_TryGetTransformTo_Windows_Perception_Spatial_SpatialCoordinateSystem_) and specifying your desired coordinate system.</span></span>  <span data-ttu-id="aa851-303">꼭 짓 점을 사용할 때마다이 메시 변환을 사용 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa851-303">You'll need to use this mesh transform whenever you work with the vertices.</span></span>  <span data-ttu-id="aa851-304">이 방법은 특히 렌더링 목적 으로만 메시를 사용 하는 경우 CPU 오버 헤드를 줄입니다.</span><span class="sxs-lookup"><span data-stu-id="aa851-304">This approach reduces CPU overhead, especially if you are only using the mesh for rendering purposes.</span></span>

## <a name="gaze-and-commit-composite-gestures"></a><span data-ttu-id="aa851-305">복합 제스처 응시 및 커밋</span><span class="sxs-lookup"><span data-stu-id="aa851-305">Gaze and Commit composite gestures</span></span>
<span data-ttu-id="aa851-306">응시 및 커밋 입력 모델을 사용 하는 응용 프로그램의 경우, 특히 HoloLens (첫 번째 gen)에서 공간 입력 API는 ' select ' 이벤트 위에 빌드되는 복합 제스처를 사용 하도록 설정 하는 데 사용할 수 있는 선택적 [SpatialGestureRecognizer](https://msdn.microsoft.com/library/windows/apps/windows.ui.input.spatial.spatialgesturerecognizer.aspx) 를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa851-306">For applications using the gaze-and-commit input model, particularly on HoloLens (first gen), the Spatial Input API provides an optional [SpatialGestureRecognizer](https://msdn.microsoft.com/library/windows/apps/windows.ui.input.spatial.spatialgesturerecognizer.aspx) that can be used to to enable composite gestures built on top of the 'select' event.</span></span>  <span data-ttu-id="aa851-307">앱은 SpatialInteractionManager에서 홀로그램의 SpatialGestureRecognizer에 대 한 상호 작용을 라우팅하는 방식으로 누름 및 릴리스를 수동으로 처리할 필요 없이 직접, 음성 및 공간 입력 장치에서 탭, 보유, 조작 및 탐색 이벤트를 일관 되 게 검색할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="aa851-307">By routing interactions from the SpatialInteractionManager to a hologram's SpatialGestureRecognizer, apps can detect Tap, Hold, Manipulation, and Navigation events uniformly across hands, voice, and spatial input devices, without having to handle presses and releases manually.</span></span>

<span data-ttu-id="aa851-308">SpatialGestureRecognizer은 요청 하는 제스처 집합 간에 최소한의 명확성만 수행 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa851-308">SpatialGestureRecognizer performs only the minimal disambiguation between the set of gestures that you request.</span></span> <span data-ttu-id="aa851-309">예를 들어, 탭을 요청 하는 경우 사용자는 손가락을 누르고 있는 동안 손가락을 길게 누르고 탭이 계속 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa851-309">For example, if you request just Tap, the user may hold their finger down as long as they like and a Tap will still occur.</span></span> <span data-ttu-id="aa851-310">두 번 누르기와 유지를 모두 요청 하는 경우 손가락을 누른 채 잠시 후에 제스처는 보류 중으로 승격 되 고 탭이 더 이상 발생 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="aa851-310">If you request both Tap and Hold, after about a second of holding down their finger, the gesture will promote to a Hold and a Tap will no longer occur.</span></span>

<span data-ttu-id="aa851-311">SpatialGestureRecognizer를 사용 하려면 SpatialInteractionManager의 [InteractionDetected](https://msdn.microsoft.com/library/windows/apps/xaml/Windows.UI.Input.Spatial.SpatialInteractionManager.InteractionDetected) 이벤트를 처리 하 고 여기에 노출 된 SpatialPointerPose를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="aa851-311">To use SpatialGestureRecognizer, handle the SpatialInteractionManager's [InteractionDetected](https://msdn.microsoft.com/library/windows/apps/xaml/Windows.UI.Input.Spatial.SpatialInteractionManager.InteractionDetected) event and grab the SpatialPointerPose exposed there.</span></span> <span data-ttu-id="aa851-312">이 포즈의 사용자 헤드 응시 레이를 사용 하 여 사용자가 사용자의 holograms 및 surface 메시를 사용 하 여 사용자가 원하는 작업을 결정 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa851-312">Use the user's head gaze ray from this pose to intersect with the holograms and surface meshes in the user's surroundings, in order to determine what the user is intending to interact with.</span></span> <span data-ttu-id="aa851-313">그런 다음 [CaptureInteraction](https://msdn.microsoft.com/library/windows/apps/xaml/Windows.UI.Input.Spatial.SpatialGestureRecognizer.CaptureInteraction) 메서드를 사용 하 여 이벤트 인수의 SpatialInteraction을 대상 홀로그램의 SpatialGestureRecognizer로 라우팅합니다.</span><span class="sxs-lookup"><span data-stu-id="aa851-313">Then, route the SpatialInteraction in the event arguments to the target hologram's SpatialGestureRecognizer, using its [CaptureInteraction](https://msdn.microsoft.com/library/windows/apps/xaml/Windows.UI.Input.Spatial.SpatialGestureRecognizer.CaptureInteraction) method.</span></span> <span data-ttu-id="aa851-314">이렇게 하면 생성 시 또는 [TrySetGestureSettings](https://msdn.microsoft.com/library/windows/apps/xaml/Windows.UI.Input.Spatial.SpatialGestureRecognizer.TrySetGestureSettings)에서 해당 인식기의 [SpatialGestureSettings](https://msdn.microsoft.com/library/windows/apps/xaml/Windows.UI.Input.Spatial.SpatialGestureSettings) 설정에 따라 해당 상호 작용을 해석 하기 시작 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa851-314">This starts interpreting that interaction according to the [SpatialGestureSettings](https://msdn.microsoft.com/library/windows/apps/xaml/Windows.UI.Input.Spatial.SpatialGestureSettings) set on that recognizer at creation time - or by [TrySetGestureSettings](https://msdn.microsoft.com/library/windows/apps/xaml/Windows.UI.Input.Spatial.SpatialGestureRecognizer.TrySetGestureSettings).</span></span>

<span data-ttu-id="aa851-315">HoloLens (첫 번째 gen)에서 상호 작용 및 제스처는 일반적으로 직접 위치에서 직접 렌더링 하거나 상호 작용 하는 대신 사용자의 헤드 응시에서 대상으로 지정 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa851-315">On HoloLens (first gen), interactions and gestures should generally derive their targeting from the user's head gaze, rather than trying to render or interact at the hand's location directly.</span></span> <span data-ttu-id="aa851-316">상호 작용이 시작 된 후 조작 또는 탐색 제스처와 같이 손의 상대 동작을 사용 하 여 제스처를 제어할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="aa851-316">Once an interaction has started, relative motions of the hand may be used to control the gesture, as with the Manipulation or Navigation gesture.</span></span>

## <a name="see-also"></a><span data-ttu-id="aa851-317">참조</span><span class="sxs-lookup"><span data-stu-id="aa851-317">See also</span></span>
* [<span data-ttu-id="aa851-318">DirectX의 헤드 및 눈 응시</span><span class="sxs-lookup"><span data-stu-id="aa851-318">Head and eye gaze in DirectX</span></span>](gaze-in-directx.md)
* [<span data-ttu-id="aa851-319">직접 조작 입력 모델</span><span class="sxs-lookup"><span data-stu-id="aa851-319">Direct manipulation input model</span></span>](../../design/direct-manipulation.md)
* [<span data-ttu-id="aa851-320">지점 및 커밋 입력 모델</span><span class="sxs-lookup"><span data-stu-id="aa851-320">Point-and-commit input model</span></span>](../../design/point-and-commit.md)
* [<span data-ttu-id="aa851-321">입력 모델 응시 및 커밋</span><span class="sxs-lookup"><span data-stu-id="aa851-321">Gaze and commit input model</span></span>](../../design/gaze-and-commit.md)
* [<span data-ttu-id="aa851-322">모션 컨트롤러</span><span class="sxs-lookup"><span data-stu-id="aa851-322">Motion controllers</span></span>](../../design/motion-controllers.md)
