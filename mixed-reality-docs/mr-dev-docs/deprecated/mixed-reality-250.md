---
title: MR 공유 250-HoloLens 및 모던 헤드셋
description: Unity, Visual Studio, HoloLens 및 Windows Mixed Reality 헤드셋을 사용 하 여이 코딩 연습을 수행 하 여 혼합 현실 장치 간 holograms 공유에 대 한 세부 정보를 알아보세요.
author: keveleigh
ms.author: kurtie
ms.date: 10/22/2019
ms.topic: article
keywords: holotoolkit, mixedrealitytoolkit, mixedrealitytoolkit-unity, 이동 컨트롤러, 공유, xbox 컨트롤러, 네트워킹, 장치 간
ms.openlocfilehash: 8b6711ab3ee833306742fe938dfa501dc5b4ed0e
ms.sourcegitcommit: d3a3b4f13b3728cfdd4d43035c806c0791d3f2fe
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 01/20/2021
ms.locfileid: "98580127"
---
# <a name="mr-sharing-250-hololens-and-immersive-headsets"></a><span data-ttu-id="21c3f-104">MR 공유 250: HoloLens 및 몰입형 헤드셋</span><span class="sxs-lookup"><span data-stu-id="21c3f-104">MR Sharing 250: HoloLens and immersive headsets</span></span>

>[!NOTE]
><span data-ttu-id="21c3f-105">Mixed Reality 아카데미 자습서는 HoloLens(1세대) 및 Mixed Reality 몰입형 헤드셋을 염두에 두고 설계되었습니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-105">The Mixed Reality Academy tutorials were designed with HoloLens (1st gen) and Mixed Reality Immersive Headsets in mind.</span></span>  <span data-ttu-id="21c3f-106">따라서 이러한 디바이스 개발에 대한 지침을 계속 찾고 있는 개발자를 위해 이러한 자습서를 그대로 두는 것이 중요합니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-106">As such, we feel it is important to leave these tutorials in place for developers who are still looking for guidance in developing for those devices.</span></span>  <span data-ttu-id="21c3f-107">이러한 자습서는 HoloLens 2에 사용되는 최신 도구 집합 또는 상호 작용으로 업데이트되지 **_않습니다_**.</span><span class="sxs-lookup"><span data-stu-id="21c3f-107">These tutorials will **_not_** be updated with the latest toolsets or interactions being used for HoloLens 2.</span></span>  <span data-ttu-id="21c3f-108">대신 지원되는 디바이스에서 계속 작동하도록 유지 관리됩니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-108">They will be maintained to continue working on the supported devices.</span></span> <span data-ttu-id="21c3f-109">HoloLens 2에 대한 [새로운 자습서 시리즈](../develop/unity/tutorials/mr-learning-base-01.md)가 게시되었습니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-109">[A new series of tutorials](../develop/unity/tutorials/mr-learning-base-01.md) has been posted for HoloLens 2.</span></span>

<span data-ttu-id="21c3f-110">UWP (유니버설 Windows 플랫폼)를 사용 하면 여러 장치에 걸쳐 있는 응용 프로그램을 쉽게 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-110">With the flexibility of Universal Windows Platform (UWP), it is easy to create an application that spans multiple devices.</span></span> <span data-ttu-id="21c3f-111">이러한 유연성을 통해 각 장치의 장점을 활용 하는 환경을 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-111">With this flexibility, we can create experiences that leverage the strengths of each device.</span></span> <span data-ttu-id="21c3f-112">이 자습서에서는 HoloLens 및 Windows Mixed Reality 몰입 형 헤드셋에서 실행 되는 기본 공유 환경을 소개 합니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-112">This tutorial will cover a basic shared experience that runs on both HoloLens and Windows Mixed Reality immersive headsets.</span></span> <span data-ttu-id="21c3f-113">이 콘텐츠는 원래 시애틀, WA의 Microsoft Build 2017 회의에서 제공 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-113">This content was originally delivered at the Microsoft Build 2017 conference in Seattle, WA.</span></span>

<span data-ttu-id="21c3f-114">**이 자습서에서는 다음 작업을 수행합니다.**</span><span class="sxs-lookup"><span data-stu-id="21c3f-114">**In this tutorial, we will:**</span></span>

* <span data-ttu-id="21c3f-115">UNET를 사용 하 여 네트워크를 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-115">Setup a network using UNET.</span></span>
* <span data-ttu-id="21c3f-116">혼합 현실 장치에서 holograms을 공유 합니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-116">Share holograms across mixed reality devices.</span></span>
* <span data-ttu-id="21c3f-117">사용 되는 혼합 현실 장치에 따라 응용 프로그램의 다른 보기를 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-117">Establish a different view of the application depending on which mixed reality device is being used.</span></span>
* <span data-ttu-id="21c3f-118">HoloLens 사용자가 간단한 퍼즐을 통해 몰입 형 헤드셋 사용자를 안내 하는 공유 환경을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-118">Create a shared experience where HoloLens users guide immersive headsets users through some simple puzzles.</span></span>

## <a name="device-support"></a><span data-ttu-id="21c3f-119">디바이스 지원</span><span class="sxs-lookup"><span data-stu-id="21c3f-119">Device support</span></span>

<table>
<tr>
<th><span data-ttu-id="21c3f-120">과정</span><span class="sxs-lookup"><span data-stu-id="21c3f-120">Course</span></span></th><th style="width:150px"> <span data-ttu-id="21c3f-121"><a href="/hololens/hololens1-hardware">HoloLens</a></span><span class="sxs-lookup"><span data-stu-id="21c3f-121"><a href="/hololens/hololens1-hardware">HoloLens</a></span></span></th><th style="width:150px"> <span data-ttu-id="21c3f-122"><a href="../discover/immersive-headset-hardware-details.md">몰입형 헤드셋</a></span><span class="sxs-lookup"><span data-stu-id="21c3f-122"><a href="../discover/immersive-headset-hardware-details.md">Immersive headsets</a></span></span></th>
</tr><tr>
<td><span data-ttu-id="21c3f-123">MR 공유 250: HoloLens 및 몰입형 헤드셋</span><span class="sxs-lookup"><span data-stu-id="21c3f-123">MR Sharing 250: HoloLens and immersive headsets</span></span></td><td style="text-align: center;"> <span data-ttu-id="21c3f-124">✔️</span><span class="sxs-lookup"><span data-stu-id="21c3f-124">✔️</span></span></td><td style="text-align: center;"> <span data-ttu-id="21c3f-125">✔️</span><span class="sxs-lookup"><span data-stu-id="21c3f-125">✔️</span></span></td>
</tr>
</table>

## <a name="before-you-start"></a><span data-ttu-id="21c3f-126">시작하기 전에</span><span class="sxs-lookup"><span data-stu-id="21c3f-126">Before you start</span></span>

### <a name="prerequisites"></a><span data-ttu-id="21c3f-127">필수 구성 요소</span><span class="sxs-lookup"><span data-stu-id="21c3f-127">Prerequisites</span></span>

* <span data-ttu-id="21c3f-128">[필요한 개발 도구가](../develop/install-the-tools.md) 포함 된 WINDOWS 10 PC 이며 [windows Mixed Reality 모던 헤드셋을 지원 하도록 구성 되어](/windows/mixed-reality/enthusiast-guide/windows-mixed-reality-minimum-pc-hardware-compatibility-guidelines)있습니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-128">A Windows 10 PC with the [necessary development tools](../develop/install-the-tools.md) and [configured to support a Windows Mixed Reality immersive headset](/windows/mixed-reality/enthusiast-guide/windows-mixed-reality-minimum-pc-hardware-compatibility-guidelines).</span></span>
* <span data-ttu-id="21c3f-129">PC에서 작동 하는 Xbox 컨트롤러</span><span class="sxs-lookup"><span data-stu-id="21c3f-129">An Xbox controller that works with your PC.</span></span>
* <span data-ttu-id="21c3f-130">하나 이상의 HoloLens 장치 및 하나의 몰입 형 헤드셋.</span><span class="sxs-lookup"><span data-stu-id="21c3f-130">At least one HoloLens device and one immersive headset.</span></span>
* <span data-ttu-id="21c3f-131">UDP 브로드캐스트 검색을 허용 하는 네트워크입니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-131">A network which allows UDP Broadcast for discovery.</span></span>

### <a name="project-files"></a><span data-ttu-id="21c3f-132">프로젝트 파일</span><span class="sxs-lookup"><span data-stu-id="21c3f-132">Project files</span></span>

* <span data-ttu-id="21c3f-133">프로젝트에 필요한 [파일](https://github.com/Microsoft/MixedReality250/archive/master.zip) 을 다운로드 합니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-133">Download the [files](https://github.com/Microsoft/MixedReality250/archive/master.zip) required by the project.</span></span> <span data-ttu-id="21c3f-134">쉽게 기억할 수 있는 위치에 파일을 추출 합니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-134">Extract the files to an easy to remember location.</span></span>
* <span data-ttu-id="21c3f-135">이 프로젝트를 사용 하려면 [Windows Mixed Reality를 지 원하는 권장 버전의 Unity](../develop/install-the-tools.md)가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-135">This project requires the [a recommended version of Unity with Windows Mixed Reality support](../develop/install-the-tools.md).</span></span>

>[!NOTE]
><span data-ttu-id="21c3f-136">다운로드 하기 전에 소스 코드를 확인 하려는 경우 [GitHub에서 사용할 수](https://github.com/Microsoft/MixedReality250)있습니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-136">If you want to look through the source code before downloading, it's [available on GitHub](https://github.com/Microsoft/MixedReality250).</span></span>

## <a name="chapter-1---holo-world"></a><span data-ttu-id="21c3f-137">1 장-Holo 세계</span><span class="sxs-lookup"><span data-stu-id="21c3f-137">Chapter 1 - Holo World</span></span>

>[!VIDEO https://www.youtube.com/embed/IC0rp6rLiEc]

### <a name="objectives"></a><span data-ttu-id="21c3f-138">목표</span><span class="sxs-lookup"><span data-stu-id="21c3f-138">Objectives</span></span>

<span data-ttu-id="21c3f-139">개발 환경에서 간단한 프로젝트를 사용할 준비가 되었는지 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-139">Make sure the development environment is ready to go with a simple project.</span></span>

### <a name="what-we-will-build"></a><span data-ttu-id="21c3f-140">빌드할 내용</span><span class="sxs-lookup"><span data-stu-id="21c3f-140">What we will build</span></span>

<span data-ttu-id="21c3f-141">HoloLens 또는 Windows Mixed Reality 몰입 형 헤드셋에서 홀로그램을 표시 하는 응용 프로그램입니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-141">An application that shows a hologram on either HoloLens or a Windows Mixed Reality immersive headset.</span></span>

### <a name="steps"></a><span data-ttu-id="21c3f-142">단계</span><span class="sxs-lookup"><span data-stu-id="21c3f-142">Steps</span></span>

* <span data-ttu-id="21c3f-143">Unity를 엽니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-143">Open Unity.</span></span>
    * <span data-ttu-id="21c3f-144">**열기** 를 선택합니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-144">Select **Open**.</span></span>
    * <span data-ttu-id="21c3f-145">프로젝트 파일의 압축을 푼 위치로 이동 합니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-145">Navigate to where you extracted the project files.</span></span>
    * <span data-ttu-id="21c3f-146">**폴더 선택** 을 클릭합니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-146">Click **Select Folder**.</span></span>
    * <span data-ttu-id="21c3f-147">*Unity가 처음으로 프로젝트를 처리 하는 데는 약간의 시간이 걸립니다.*</span><span class="sxs-lookup"><span data-stu-id="21c3f-147">*It will take a little while for Unity to process the project the first time.*</span></span>
* <span data-ttu-id="21c3f-148">혼합 현실이 Unity에서 사용 되는지 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-148">Check that Mixed Reality is enabled in Unity.</span></span>
    * <span data-ttu-id="21c3f-149">빌드 설정 대화 상자를 엽니다 (**컨트롤 + Shift + B** 또는 **파일 > 빌드 설정**...).</span><span class="sxs-lookup"><span data-stu-id="21c3f-149">Open the build settings dialog (**Control+Shift+B** or **File > Build Settings...**).</span></span>
    * <span data-ttu-id="21c3f-150">**유니버설 Windows 플랫폼** 선택한 후 **플랫폼 전환** 을 클릭 합니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-150">Select **Universal Windows Platform** then click **Switch Platform**.</span></span>
    * <span data-ttu-id="21c3f-151">**편집>플레이어 설정** 을 선택 합니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-151">Select **Edit>Player Settings**.</span></span>
    * <span data-ttu-id="21c3f-152">오른쪽의 **검사기** 패널에서 **XR 설정** 을 확장 합니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-152">In the **Inspector** panel on the right hand side, expand **XR Settings**.</span></span>
    * <span data-ttu-id="21c3f-153">**가상 현실 지원 됨** 확인란을 선택 합니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-153">Check the **Virtual Reality Supported** box.</span></span>
    * <span data-ttu-id="21c3f-154">*Windows Mixed Reality는 가상 현실 SDK 여야 합니다.*</span><span class="sxs-lookup"><span data-stu-id="21c3f-154">*Windows Mixed Reality should be the Virtual Reality SDK.*</span></span>
* <span data-ttu-id="21c3f-155">장면을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-155">Create a scene.</span></span>
    * <span data-ttu-id="21c3f-156">**계층** 에서 마우스 오른쪽 단추를 클릭 하 고 **삭제** **를 선택 합니다** .</span><span class="sxs-lookup"><span data-stu-id="21c3f-156">In the **Hierarchy** right click **Main Camera** select **Delete**.</span></span>
    * <span data-ttu-id="21c3f-157">**HoloToolkit > 입력 > Prefabs** 에서 **계층** 으로 **MixedRealityCameraParent** 를 끌어옵니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-157">From **HoloToolkit > Input > Prefabs** drag **MixedRealityCameraParent** to the **Hierarchy**.</span></span>
* <span data-ttu-id="21c3f-158">장면에 Holograms 추가</span><span class="sxs-lookup"><span data-stu-id="21c3f-158">Add Holograms to the scene</span></span>
    * <span data-ttu-id="21c3f-159">**AppPrefabs** 에서 **Skybox** 를 **장면 뷰로** 끕니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-159">From **AppPrefabs** drag **Skybox** to the **Scene View**.</span></span>
    * <span data-ttu-id="21c3f-160">**AppPrefabs** 에서 **관리자** 를 **계층** 으로 끕니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-160">From **AppPrefabs** drag **Managers** to the **Hierarchy**.</span></span>
    * <span data-ttu-id="21c3f-161">**AppPrefabs** 를 계층 **으로 끕니다** . </span><span class="sxs-lookup"><span data-stu-id="21c3f-161">From **AppPrefabs** drag **Island** to the **Hierarchy**.</span></span>
* <span data-ttu-id="21c3f-162">저장 및 빌드</span><span class="sxs-lookup"><span data-stu-id="21c3f-162">Save And build</span></span>
    * <span data-ttu-id="21c3f-163">저장 ( **컨트롤 + S** 또는 **파일 > 장면 저장**)</span><span class="sxs-lookup"><span data-stu-id="21c3f-163">Save (either **Control+S** or **File > Save Scene**)</span></span>
    * <span data-ttu-id="21c3f-164">새 장면 이므로 이름을로 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-164">Since this is a new scene, you'll need to name it.</span></span> <span data-ttu-id="21c3f-165">이름은 중요 하지 않지만 SharedMixedReality를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-165">Name doesn't matter, but we use SharedMixedReality.</span></span>
* <span data-ttu-id="21c3f-166">Visual Studio로 내보내기</span><span class="sxs-lookup"><span data-stu-id="21c3f-166">Export To Visual Studio</span></span>
    * <span data-ttu-id="21c3f-167">빌드 메뉴 열기 (**컨트롤 + Shift + B** 또는 **파일 > 빌드 설정**)</span><span class="sxs-lookup"><span data-stu-id="21c3f-167">Open the build menu (**Control+Shift+B** or **File > Build Settings**)</span></span>
    * <span data-ttu-id="21c3f-168">**열려 있는 장면 추가를 클릭 합니다.**</span><span class="sxs-lookup"><span data-stu-id="21c3f-168">Click **Add Open Scenes.**</span></span>
    * <span data-ttu-id="21c3f-169">**Unity c # 프로젝트** 확인</span><span class="sxs-lookup"><span data-stu-id="21c3f-169">Check **Unity C# Projects**</span></span>
    * <span data-ttu-id="21c3f-170">**빌드** 를 클릭한 다음</span><span class="sxs-lookup"><span data-stu-id="21c3f-170">Click **Build**.</span></span>
    * <span data-ttu-id="21c3f-171">표시 되는 파일 탐색기 창에서 **App** 이라는 새 폴더를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-171">In the file explorer window that appears, create a New Folder named **App**.</span></span>
    * <span data-ttu-id="21c3f-172">단일 **앱** 폴더를 클릭 합니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-172">Single click the **App** folder.</span></span>
    * <span data-ttu-id="21c3f-173">**폴더 선택을 누릅니다.**</span><span class="sxs-lookup"><span data-stu-id="21c3f-173">Press **Select Folder.**</span></span>
    * <span data-ttu-id="21c3f-174">**빌드가 완료 될 때까지 대기**</span><span class="sxs-lookup"><span data-stu-id="21c3f-174">**Wait for the build to complete**</span></span>
    * <span data-ttu-id="21c3f-175">표시 되는 파일 탐색기 창에서 **응용 프로그램** 폴더로 이동 합니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-175">In the file explorer window that appears, navigate into the **App** folder.</span></span>
    * <span data-ttu-id="21c3f-176">SharedMixedReality를 두 번 클릭 하 여 Visual Studio를 시작 **합니다.**</span><span class="sxs-lookup"><span data-stu-id="21c3f-176">Double-click **SharedMixedReality.sln** to launch Visual Studio</span></span>
* <span data-ttu-id="21c3f-177">Visual Studio에서 빌드</span><span class="sxs-lookup"><span data-stu-id="21c3f-177">Build From Visual Studio</span></span>
    * <span data-ttu-id="21c3f-178">맨 위 도구 모음을 사용 하 여 대상을 **릴리스** 및 **x 86** 으로 변경 합니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-178">Using the top toolbar change target to **Release** and **x86**.</span></span>
    * <span data-ttu-id="21c3f-179">**로컬 컴퓨터** 옆의 화살표를 클릭 하 고 HoloLens에 배포할 **장치** 를 선택 합니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-179">Click the arrow next to **Local Machine** and select **Device** to deploy to HoloLens</span></span>
    * <span data-ttu-id="21c3f-180">**장치** 옆에 있는 화살표를 클릭 하 고 혼합 현실 헤드셋에 대해 배포할 **로컬 컴퓨터** 를 선택 합니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-180">Click the arrow next to **Device** and select **Local Machine** to deploy for the mixed reality headset.</span></span>
    * <span data-ttu-id="21c3f-181">**디버그->** 를 클릭 하 여 디버깅 또는 **컨트롤 + F5** 키를 눌러 응용 프로그램을 시작 합니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-181">Click **Debug->Start Without Debugging** or **Control+F5** to start the application.</span></span>

### <a name="digging-into-the-code"></a><span data-ttu-id="21c3f-182">코드 살펴보기</span><span class="sxs-lookup"><span data-stu-id="21c3f-182">Digging into the code</span></span>

<span data-ttu-id="21c3f-183">프로젝트 패널에서 **Assets\HoloToolkit\Input\Scripts\Utilities** 으로 이동 하 고 **MixedRealityCameraManager.cs** 를 두 번 클릭 하 여 엽니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-183">In the project panel, navigate to **Assets\HoloToolkit\Input\Scripts\Utilities** and double click **MixedRealityCameraManager.cs** to open it.</span></span>

<span data-ttu-id="21c3f-184">**개요:** MixedRealityCameraManager.cs는 장치에 따라 품질 수준 및 배경 설정을 조정 하는 간단한 스크립트입니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-184">**Overview:** MixedRealityCameraManager.cs is a simple script that adjusts quality level and background settings based on the device.</span></span> <span data-ttu-id="21c3f-185">여기서 핵심은 HolographicSettings는 장치가 HoloLens (IsDisplayOpaque false) 또는 몰입 형 헤드셋 (IsDisplayOpaque이 true를 반환) 인지 여부를 스크립트에서 검색할 수 있도록 하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-185">Key here is HolographicSettings.IsDisplayOpaque, which allows a script to detect if the device is a HoloLens (IsDisplayOpaque returns false) or an immersive headset (IsDisplayOpaque returns true).</span></span>

### <a name="enjoy-your-progress"></a><span data-ttu-id="21c3f-186">진행 상황을 경험해 보세요.</span><span class="sxs-lookup"><span data-stu-id="21c3f-186">Enjoy your progress</span></span>

<span data-ttu-id="21c3f-187">이 시점에서 응용 프로그램은 홀로그램만 렌더링 합니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-187">At this point the application will just render a hologram.</span></span> <span data-ttu-id="21c3f-188">나중에 홀로그램에 대 한 상호 작용을 추가할 예정입니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-188">We will add interaction to the hologram later.</span></span> <span data-ttu-id="21c3f-189">두 장치 모두 홀로그램을 동일 하 게 렌더링 합니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-189">Both devices will render the hologram the same.</span></span> <span data-ttu-id="21c3f-190">몰입 형 헤드셋은 파란 하늘 및 구름 배경도 렌더링 합니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-190">The immersive headset will also render a blue sky and clouds background.</span></span>

## <a name="chapter-2---interaction"></a><span data-ttu-id="21c3f-191">2 장-상호 작용</span><span class="sxs-lookup"><span data-stu-id="21c3f-191">Chapter 2 - Interaction</span></span>

>[!VIDEO https://www.youtube.com/embed/Lrb1y4sQRvI]

### <a name="objectives"></a><span data-ttu-id="21c3f-192">목표</span><span class="sxs-lookup"><span data-stu-id="21c3f-192">Objectives</span></span>

<span data-ttu-id="21c3f-193">Windows Mixed Reality 응용 프로그램의 입력을 처리 하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-193">Show how to handle input for a Windows Mixed Reality application.</span></span>

### <a name="what-we-will-build"></a><span data-ttu-id="21c3f-194">빌드할 내용</span><span class="sxs-lookup"><span data-stu-id="21c3f-194">What we will build</span></span>

<span data-ttu-id="21c3f-195">1 챕터의 응용 프로그램을 기반으로 하는 기능을 추가 하 여 사용자가 홀로그램을 선택 하 여 HoloLens의 실제 세계 표면 또는 모던 헤드셋의 가상 테이블에 저장할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-195">Building on the application from chapter 1, we will add functionality to allow the user to pick up the hologram and place it on a real world surface in HoloLens or on a virtual table in an immersive headset.</span></span>

<span data-ttu-id="21c3f-196">**입력 리프레셔:** HoloLens에서 선택 제스처는 **공중 탭** 입니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-196">**Input Refresher:** On HoloLens the select gesture is the **air tap**.</span></span> <span data-ttu-id="21c3f-197">모던 헤드셋에서 Xbox 컨트롤러의 **A** 단추를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-197">On immersive headsets, we will use the **A** button on the Xbox controller.</span></span> <span data-ttu-id="21c3f-198">자세한 내용은 [상호 작용 모델 개요](../design/interaction-fundamentals.md)를 확인 하세요.</span><span class="sxs-lookup"><span data-stu-id="21c3f-198">For more information check out the [interaction model overview](../design/interaction-fundamentals.md).</span></span>

### <a name="steps"></a><span data-ttu-id="21c3f-199">단계</span><span class="sxs-lookup"><span data-stu-id="21c3f-199">Steps</span></span>

* <span data-ttu-id="21c3f-200">입력 관리자 추가</span><span class="sxs-lookup"><span data-stu-id="21c3f-200">Add Input manager</span></span>
    * <span data-ttu-id="21c3f-201">**HoloToolkit > 입력 > Prefabs** **Inputmanager** 를 **계층 구조** 에 **관리자** 의 자식으로 끌어 놓습니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-201">From **HoloToolkit > Input > Prefabs** drag **InputManager** to **Hierarchy** as a child of **Managers**.</span></span>
    * <span data-ttu-id="21c3f-202">**HoloToolkit > 입력 > Prefabs > 커서** **계층** 으로 **커서** 를 끕니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-202">From **HoloToolkit > Input > Prefabs > Cursor** drag **Cursor** to **Hierarchy**.</span></span>
* <span data-ttu-id="21c3f-203">공간 매핑 추가</span><span class="sxs-lookup"><span data-stu-id="21c3f-203">Add Spatial Mapping</span></span>
    * <span data-ttu-id="21c3f-204">**HoloToolkit > SpatialMapping > Prefabs** **SpatialMapping** 를 **Hierarchy** 로 끌어 놓습니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-204">From **HoloToolkit > SpatialMapping > Prefabs** drag **SpatialMapping** to **Hierarchy**.</span></span>
* <span data-ttu-id="21c3f-205">가상 Playspace 추가</span><span class="sxs-lookup"><span data-stu-id="21c3f-205">Add Virtual Playspace</span></span>
    * <span data-ttu-id="21c3f-206">**계층 구조** 에서 **MixedRealityCameraParent** 선택 **경계** 를 확장 합니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-206">In **Hierarchy** expand **MixedRealityCameraParent** select **Boundary**</span></span>
    * <span data-ttu-id="21c3f-207">**검사기** 패널에서 **경계** 사용 확인란을 선택 합니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-207">In **Inspector** panel check the box to enable **Boundary**</span></span>
    * <span data-ttu-id="21c3f-208">**AppPrefabs** 에서 **VRRoom** 을 **계층** 으로 끌어옵니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-208">From **AppPrefabs** drag **VRRoom** to **Hierarchy**.</span></span>
* <span data-ttu-id="21c3f-209">WorldAnchorManager 추가</span><span class="sxs-lookup"><span data-stu-id="21c3f-209">Add WorldAnchorManager</span></span>
    * <span data-ttu-id="21c3f-210">**계층** 에서 **관리자** 를 선택 합니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-210">In **Hierarchy**, Select **Managers**.</span></span>
    * <span data-ttu-id="21c3f-211">**검사기** 에서 **구성 요소 추가** 를 클릭 합니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-211">In **Inspector**, click **Add Component**.</span></span>
    * <span data-ttu-id="21c3f-212">**세계 앵커 관리자** 를 입력 합니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-212">Type **World Anchor Manager**.</span></span>
    * <span data-ttu-id="21c3f-213">**세계 앵커 관리자** 를 선택 하 여 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-213">Select **World Anchor Manager** to add it.</span></span>
* <span data-ttu-id="21c3f-214">섬에 TapToPlace 추가</span><span class="sxs-lookup"><span data-stu-id="21c3f-214">Add TapToPlace to the Island</span></span>
    * <span data-ttu-id="21c3f-215">**계층** 에서 **아일랜드** 를 확장 합니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-215">In **Hierarchy**, expand **Island**.</span></span>
    * <span data-ttu-id="21c3f-216">**MixedRealityLand** 를 선택 합니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-216">Select **MixedRealityLand**.</span></span>
    * <span data-ttu-id="21c3f-217">**검사기** 에서 **구성 요소 추가** 를 클릭 합니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-217">In **Inspector**, click **Add Component**.</span></span>
    * <span data-ttu-id="21c3f-218">**누릅니다를 입력 하** 고 선택 합니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-218">Type **Tap To Place** and select it.</span></span>
    * <span data-ttu-id="21c3f-219">**부모를 탭** 하 여 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-219">Check **Place Parent On Tap**.</span></span>
    * <span data-ttu-id="21c3f-220">**배치 오프셋** 을 **(0, 0.1, 0)** 로 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-220">Set **Placement Offset** to **(0, 0.1, 0)**.</span></span>
* <span data-ttu-id="21c3f-221">이전 처럼 저장 및 빌드</span><span class="sxs-lookup"><span data-stu-id="21c3f-221">Save and Build as before</span></span>

### <a name="digging-into-the-code"></a><span data-ttu-id="21c3f-222">코드 살펴보기</span><span class="sxs-lookup"><span data-stu-id="21c3f-222">Digging into the code</span></span>

<span data-ttu-id="21c3f-223">**스크립트 1-GamepadInput.cs**</span><span class="sxs-lookup"><span data-stu-id="21c3f-223">**Script 1 - GamepadInput.cs**</span></span>

<span data-ttu-id="21c3f-224">프로젝트 패널에서 **Assets\HoloToolkit\Input\Scripts\InputSources** 으로 이동 하 고 **GamepadInput.cs** 를 두 번 클릭 하 여 엽니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-224">In the project panel navigate to **Assets\HoloToolkit\Input\Scripts\InputSources** and double click **GamepadInput.cs** to open it.</span></span> <span data-ttu-id="21c3f-225">프로젝트 패널의 동일한 경로에서 **InteractionSourceInputSource.cs** 를 두 번 클릭 합니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-225">From the same path in the project panel, also double click **InteractionSourceInputSource.cs**.</span></span>

<span data-ttu-id="21c3f-226">두 스크립트 모두 BaseInputSource 공통 기본 클래스를 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-226">Note that both scripts have a common base class, BaseInputSource.</span></span>

<span data-ttu-id="21c3f-227">BaseInputSource는 스크립트가 이벤트를 트리거할 수 있도록 하는 InputManager에 대 한 참조를 유지 합니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-227">BaseInputSource keeps a reference to an InputManager, which allows a script to trigger events.</span></span> <span data-ttu-id="21c3f-228">이 경우 InputClicked 이벤트는 관련 됩니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-228">In this case, the InputClicked event is relevant.</span></span> <span data-ttu-id="21c3f-229">이는 스크립트 2, TapToPlace에 대 한 정보를 기억해 야 합니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-229">This will be important to remember when we get to script 2, TapToPlace.</span></span> <span data-ttu-id="21c3f-230">GamePadInput의 경우에는 누를 컨트롤러의 단추를 폴링하고, InputClicked 이벤트를 발생 시킵니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-230">In the case of GamePadInput, we poll for the A button on the controller to be pressed, then we raise the InputClicked event.</span></span> <span data-ttu-id="21c3f-231">InteractionSourceInputSource의 경우 TappedEvent에 대 한 응답으로 InputClicked 이벤트를 발생 시킵니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-231">In the case of InteractionSourceInputSource, we raise the InputClicked event in response to the TappedEvent.</span></span>

<span data-ttu-id="21c3f-232">**스크립트 2-TapToPlace.cs**</span><span class="sxs-lookup"><span data-stu-id="21c3f-232">**Script 2 - TapToPlace.cs**</span></span>

<span data-ttu-id="21c3f-233">프로젝트 패널에서 **Assets\HoloToolkit\SpatialMapping\Scripts** 으로 이동 하 고 **TapToPlace.cs** 를 두 번 클릭 하 여 엽니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-233">In the project panel navigate to **Assets\HoloToolkit\SpatialMapping\Scripts** and double click **TapToPlace.cs** to open it.</span></span>

<span data-ttu-id="21c3f-234">Holographic 응용 프로그램을 만들 때 대부분의 개발자는 Holograms를 제스처 입력으로 이동 하는 것이 가장 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-234">The first thing many developers want to implement when creating a Holographic application is moving Holograms with gesture input.</span></span> <span data-ttu-id="21c3f-235">따라서이 스크립트를 철저히 설명 해 수행자.</span><span class="sxs-lookup"><span data-stu-id="21c3f-235">As such, we've endeavored to thoroughly comment this script.</span></span> <span data-ttu-id="21c3f-236">이 자습서에서는 몇 가지 사항을 강조 표시 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-236">A few things are worth highlighting for this tutorial.</span></span>

<span data-ttu-id="21c3f-237">먼저 TapToPlace는 IInputClickHandler를 구현 합니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-237">First, note that TapToPlace implements IInputClickHandler.</span></span> <span data-ttu-id="21c3f-238">IInputClickHandler는 GamePadInput.cs 또는 InteractionSourceInputSource.cs에 의해 발생 한 InputClicked 이벤트를 처리 하는 함수를 노출 합니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-238">IInputClickHandler exposes the functions that handle the InputClicked event raised by GamePadInput.cs or InteractionSourceInputSource.cs.</span></span> <span data-ttu-id="21c3f-239">OnInputClicked은 TapToPlace를 사용 하는 개체가 포커스에 있는 동안 BaseInputSource에서 클릭을 감지 하면 호출 됩니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-239">OnInputClicked is called when a BaseInputSource detects a click while the object with TapToPlace is in focus.</span></span> <span data-ttu-id="21c3f-240">HoloLens를 클릭 하거나 Xbox 컨트롤러의 A 단추를 누르면 이벤트가 트리거됩니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-240">Either airtapping on HoloLens or pressing the A button on the Xbox controller will trigger the event.</span></span>

<span data-ttu-id="21c3f-241">Second는 업데이트에서 화면을 검토 하 고 있는지 확인 하기 위해 실행 되는 코드입니다. 여기에는 게임 개체를 테이블 처럼 화면에 놓을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-241">Second is the code be executed in update to see if a surface is being looked at so we can place the game object on a surface, like a table.</span></span> <span data-ttu-id="21c3f-242">모던 헤드셋은 실제 표면의 개념을 포함 하지 않으므로 테이블 위쪽 (Vroom > TableThingy > Cube)을 나타내는 개체는 SpatialMapping 물리학 계층으로 표시 되어 있으므로 업데이트에서 광선 캐스트가 가상 테이블 위쪽과 충돌 합니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-242">The immersive headset doesn't have a concept of real surfaces, so the object that represents the table top (Vroom > TableThingy > Cube) has been marked with the SpatialMapping physics layer, so the ray cast in Update will collide with the virtual table top.</span></span>

### <a name="enjoy-your-progress"></a><span data-ttu-id="21c3f-243">진행 상황을 경험해 보세요.</span><span class="sxs-lookup"><span data-stu-id="21c3f-243">Enjoy your progress</span></span>

<span data-ttu-id="21c3f-244">이번에는 아일랜드를 선택 하 여 이동할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-244">This time you can select the island to move it.</span></span> <span data-ttu-id="21c3f-245">HoloLens에서 아일랜드를 실제 표면으로 이동할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-245">On HoloLens you can move the island to a real surface.</span></span> <span data-ttu-id="21c3f-246">몰입 형 헤드셋에서 추가 된 가상 테이블로 아일랜드를 이동할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-246">In the immersive headset you can move the island to the virtual table we added.</span></span>

## <a name="chapter-3---sharing"></a><span data-ttu-id="21c3f-247">3 장-공유</span><span class="sxs-lookup"><span data-stu-id="21c3f-247">Chapter 3 - Sharing</span></span>

>[!VIDEO https://www.youtube.com/embed/1diycJvxfDc]

### <a name="objectives"></a><span data-ttu-id="21c3f-248">목표</span><span class="sxs-lookup"><span data-stu-id="21c3f-248">Objectives</span></span>

<span data-ttu-id="21c3f-249">네트워크가 올바르게 구성 되었는지 확인 하 고 장치 간에 공간 앵커가 공유 되는 방법을 자세히 설명 합니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-249">Ensure that the network is correctly configured and detail how spatial anchors are shared between devices.</span></span>

### <a name="what-we-will-build"></a><span data-ttu-id="21c3f-250">빌드할 내용</span><span class="sxs-lookup"><span data-stu-id="21c3f-250">What we will build</span></span>

<span data-ttu-id="21c3f-251">프로젝트를 여럿이 아닌 프로젝트로 변환 합니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-251">We will convert our project to a multiplayer project.</span></span> <span data-ttu-id="21c3f-252">세션을 호스트 하거나 조인 하는 데 UI와 논리를 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-252">We will add UI and logic to host or join sessions.</span></span> <span data-ttu-id="21c3f-253">HoloLens 사용자는 해당 헤드에 대 한 클라우드가 포함 된 세션에서 서로를 볼 수 있으며, 몰입 형 헤드셋 사용자는 앵커 위치 근처의 클라우드를 가집니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-253">HoloLens users will see each other in the session with clouds over their heads, and immersive headset users have clouds near to where the anchor is.</span></span> <span data-ttu-id="21c3f-254">모던 헤드셋의 사용자는 장면의 원점을 기준으로 HoloLens 사용자를 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-254">Users in the immersive headsets will see the HoloLens users relative to the origin of the scene.</span></span> <span data-ttu-id="21c3f-255">HoloLens 사용자는 모두 같은 장소에서 아일랜드의 홀로그램을 보게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-255">HoloLens users will all see the hologram of the island in the same place.</span></span> <span data-ttu-id="21c3f-256">이 장 중에는 몰입 형 헤드셋의 사용자가 섬에 있지 않고, HoloLens와 매우 유사 하 게 작동 합니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-256">It is key to note that the users in the immersive headsets will not be on the island during this chapter, but will behave very similarly to HoloLens, with a birds eye view of the island.</span></span>

### <a name="steps"></a><span data-ttu-id="21c3f-257">단계</span><span class="sxs-lookup"><span data-stu-id="21c3f-257">Steps</span></span>

* <span data-ttu-id="21c3f-258">섬 및 VRRoom 제거</span><span class="sxs-lookup"><span data-stu-id="21c3f-258">Remove Island and VRRoom</span></span>
    * <span data-ttu-id="21c3f-259">**계층** 에서 분리를 마우스 오른쪽 **단추로 클릭 하** 고 **삭제** 를 선택 합니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-259">In **Hierarchy** right-click **Island** select **Delete**</span></span>
    * <span data-ttu-id="21c3f-260">**계층** 에서 **VRRoom** 를 마우스 오른쪽 단추로 클릭 하 고 **삭제** 를 선택 합니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-260">In **Hierarchy** right-click **VRRoom** select **Delete**</span></span>
* <span data-ttu-id="21c3f-261">Usland 추가</span><span class="sxs-lookup"><span data-stu-id="21c3f-261">Add Usland</span></span>
    * <span data-ttu-id="21c3f-262">**AppPrefabs** 에서 **Usland** 를 **계층** 으로 끌어옵니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-262">From **AppPrefabs** drag **Usland** to **Hierarchy**.</span></span>
* <span data-ttu-id="21c3f-263">**AppPrefabs** 에서 다음의 각을 **계층** 으로 끌어옵니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-263">From **AppPrefabs** drag each of the following to **Hierarchy**:</span></span>
    * <span data-ttu-id="21c3f-264">**UNETSharingStage**</span><span class="sxs-lookup"><span data-stu-id="21c3f-264">**UNETSharingStage**</span></span>
    * <span data-ttu-id="21c3f-265">**UNetAnchorRoot**</span><span class="sxs-lookup"><span data-stu-id="21c3f-265">**UNetAnchorRoot**</span></span>
    * <span data-ttu-id="21c3f-266">**UIContainer**</span><span class="sxs-lookup"><span data-stu-id="21c3f-266">**UIContainer**</span></span>
    * <span data-ttu-id="21c3f-267">**DebugPanelButton**</span><span class="sxs-lookup"><span data-stu-id="21c3f-267">**DebugPanelButton**</span></span>
* <span data-ttu-id="21c3f-268">이전 처럼 저장 및 빌드</span><span class="sxs-lookup"><span data-stu-id="21c3f-268">Save and Build as before</span></span>

### <a name="digging-into-the-code"></a><span data-ttu-id="21c3f-269">코드 살펴보기</span><span class="sxs-lookup"><span data-stu-id="21c3f-269">Digging into the code</span></span>

<span data-ttu-id="21c3f-270">프로젝트 패널에서 **Assets\AppPrefabs\Support\SharingWithUnet\Scripts** 으로 이동 하 고 **UnetAnchorManager.cs** 를 두 번 클릭 합니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-270">In the project panel, navigate to **Assets\AppPrefabs\Support\SharingWithUnet\Scripts** and double-click on **UnetAnchorManager.cs**.</span></span> <span data-ttu-id="21c3f-271">한 HoloLens에서 다른 HoloLens와 추적 정보를 공유 하는 기능 (두 장치 모두 동일한 공간을 공유할 수 있음)이 거의 마법입니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-271">The ability for one HoloLens to share tracking information with another HoloLens such that both devices can share the same space is near magical.</span></span> <span data-ttu-id="21c3f-272">두 명 이상의 사용자가 동일한 디지털 데이터를 사용 하 여 공동 작업할 수 있는 경우 혼합 현실의 성능이 유지 됩니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-272">The power of mixed reality comes alive when two or more people can collaborate using the same digital data.</span></span>

<span data-ttu-id="21c3f-273">이 스크립트에서 몇 가지 사항을 확인 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-273">A few things to point out in this script:</span></span>

<span data-ttu-id="21c3f-274">시작 함수에서 **Isdisplayopaque** 검사를 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-274">In the start function, notice the check for **IsDisplayOpaque**.</span></span> <span data-ttu-id="21c3f-275">이 경우 앵커가 설정 된 것으로 가정 합니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-275">In this case, we pretend that the Anchor is established.</span></span> <span data-ttu-id="21c3f-276">이는 몰입 형 헤드셋이 앵커를 가져오거나 내보내는 방법을 노출 하지 않기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-276">This is because the immersive headsets do not expose a way to import or export anchors.</span></span> <span data-ttu-id="21c3f-277">그러나 HoloLens에서 실행 하는 경우이 스크립트는 장치 간의 앵커 공유를 구현 합니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-277">If we are running on a HoloLens, however, this script implements sharing anchors between the devices.</span></span> <span data-ttu-id="21c3f-278">세션을 시작 하는 장치는 내보내기를 위한 앵커를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-278">The device that starts the session will create an anchor for exporting.</span></span> <span data-ttu-id="21c3f-279">세션을 조인 하는 장치는 세션을 시작한 장치에서 앵커를 요청 합니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-279">The device that joins a session will request the anchor from the device that started the session.</span></span>

<span data-ttu-id="21c3f-280">**내보내려면**</span><span class="sxs-lookup"><span data-stu-id="21c3f-280">**Exporting:**</span></span>

<span data-ttu-id="21c3f-281">사용자가 세션을 만들 때 NetworkDiscoveryWithAnchors는 UNETAnchorManagers CreateAnchor 함수를 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-281">When a user creates a session, NetworkDiscoveryWithAnchors will call UNETAnchorManagers CreateAnchor function.</span></span> <span data-ttu-id="21c3f-282">CreateAnchor 흐름을 살펴보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-282">Let's follow CreateAnchor flow.</span></span>

<span data-ttu-id="21c3f-283">먼저 몇 가지 정리 작업을 수행 하 여 이전 앵커에 대해 수집 했을 수 있는 모든 데이터를 정리 합니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-283">We start by doing some housekeeping, clearing out any data we may have collected for previous anchors.</span></span> <span data-ttu-id="21c3f-284">그런 다음 로드할 캐시 된 앵커가 있는지 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-284">Then we check if there is a cached anchor to load.</span></span> <span data-ttu-id="21c3f-285">고정 데이터는 5 ~ 20mb의 경향이 있으므로 캐시 된 앵커를 다시 사용 하면 네트워크를 통해 전송 해야 하는 데이터의 양이 절약 됩니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-285">The anchor data tends to be between 5 and 20 MB, so reusing cached anchors can save on the amount of data we need to transfer over the network.</span></span> <span data-ttu-id="21c3f-286">나중에이 작업을 수행 하는 방법을 살펴보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-286">We'll see how this works a bit later.</span></span> <span data-ttu-id="21c3f-287">앵커를 다시 사용 하는 경우에도 앵커가 없는 새 클라이언트 조인을 위해 앵커 데이터를 준비 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-287">Even if we are reusing the anchor, we need to get the anchor data ready in case a new client joins that doesn't have the anchor.</span></span>

<span data-ttu-id="21c3f-288">앵커 데이터를 준비 하는 경우 WorldAnchorTransferBatch 클래스는 다른 장치나 응용 프로그램에 보내기 위한 앵커 데이터를 준비 하는 기능과 앵커 데이터를 가져오는 기능을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-288">Speaking of getting the anchor data ready, the WorldAnchorTransferBatch class exposes the functionality to prepare anchor data for sending to another device or application and the functionality to import the anchor data.</span></span> <span data-ttu-id="21c3f-289">내보내기 경로를 사용할 예정 이므로 WorldAnchorTransferBatch에 앵커를 추가 하 고 ExportAsync 함수를 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-289">Since we're on the export path, we will add our anchor to the WorldAnchorTransferBatch and call the ExportAsync function.</span></span> <span data-ttu-id="21c3f-290">그러면 ExportAsync는 내보내기에 대 한 데이터를 생성할 때 WriteBuffer 콜백을 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-290">ExportAsync will then call the WriteBuffer callback as it generates data for export.</span></span> <span data-ttu-id="21c3f-291">모든 데이터를 내보낸 후 ExportComplete가 호출 됩니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-291">When all of the data has been exported ExportComplete will be called.</span></span> <span data-ttu-id="21c3f-292">WriteBuffer에서 내보내기 위해 보관 하는 목록에 데이터 청크를 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-292">In WriteBuffer we add the chunk of data to a list we keep for exporting.</span></span> <span data-ttu-id="21c3f-293">ExportComplete에서 목록을 배열로 변환 합니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-293">In ExportComplete we convert the list to an array.</span></span> <span data-ttu-id="21c3f-294">또한 AnchorName 변수는 설정 된 경우 앵커를 요청 하는 다른 장치를 트리거합니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-294">The AnchorName variable is also set, which will trigger other devices to request the anchor if they don't have it.</span></span>

<span data-ttu-id="21c3f-295">일부 경우에는 앵커가 내보내지 않고 다시 시도 하는 데이터를 적게 만들게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-295">In some cases the anchor won't export or will create so little data that we will try again.</span></span> <span data-ttu-id="21c3f-296">여기서는 CreateAnchor만 다시 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-296">Here we just call CreateAnchor again.</span></span>

<span data-ttu-id="21c3f-297">내보내기 경로의 마지막 함수는 AnchorFoundRemotely입니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-297">A final function in the export path is AnchorFoundRemotely.</span></span> <span data-ttu-id="21c3f-298">다른 장치에서 앵커를 찾으면 해당 장치는 호스트에 지시 하 고,이는 앵커가 "좋은 앵커" 이며 캐시 될 수 있는 신호로 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-298">When another device finds the anchor, that device will tell the host, and the host will use that as a signal that the anchor is a "good anchor" and can be cached.</span></span>

<span data-ttu-id="21c3f-299">**내보내고**</span><span class="sxs-lookup"><span data-stu-id="21c3f-299">**Importing:**</span></span>

<span data-ttu-id="21c3f-300">HoloLens가 세션에 참여 하는 경우 앵커를 가져와야 합니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-300">When a HoloLens joins a session, it needs to import an anchor.</span></span> <span data-ttu-id="21c3f-301">UNETAnchorManager의 업데이트 함수에서 AnchorName가 폴링합니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-301">In UNETAnchorManager's Update function, the AnchorName is polled.</span></span> <span data-ttu-id="21c3f-302">앵커 이름이 변경 되 면 가져오기 프로세스가 시작 됩니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-302">When the anchor name changes, the import process begins.</span></span> <span data-ttu-id="21c3f-303">먼저 로컬 앵커 저장소에서 지정 된 이름의 앵커를 로드 하려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-303">First, we try to load the anchor with the specified name from the local anchor store.</span></span> <span data-ttu-id="21c3f-304">이미 있는 경우 데이터를 다시 다운로드 하지 않고 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-304">If we already have it, we can use it without downloading the data again.</span></span> <span data-ttu-id="21c3f-305">아직 없는 경우 다운로드를 시작 하는 WaitForAnchor를 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-305">If we don't have it, then we call WaitForAnchor which will initiate the download.</span></span>

<span data-ttu-id="21c3f-306">다운로드가 완료 되 면 NetworkTransmitter_dataReadyEvent가 호출 됩니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-306">When the download is completed, NetworkTransmitter_dataReadyEvent is called.</span></span> <span data-ttu-id="21c3f-307">이렇게 하면 다운로드 한 데이터를 사용 하 여 ImportAsync를 호출 하도록 업데이트 루프가 신호를 받습니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-307">This will signal the Update loop to call ImportAsync with the downloaded data.</span></span> <span data-ttu-id="21c3f-308">가져오기 프로세스가 완료 되 면 ImportAsync에서 ImportComplete를 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-308">ImportAsync will call ImportComplete when the import process is complete.</span></span> <span data-ttu-id="21c3f-309">가져오기를 완료 하면 앵커가 로컬 플레이어 저장소에 저장 됩니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-309">If the import is successful, the anchor will be saved in the local player store.</span></span> <span data-ttu-id="21c3f-310">PlayerController.cs는 실제로 AnchorFoundRemotely에 대 한 호출을 수행 하 여 호스트에 올바른 앵커가 설정 되었음을 알립니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-310">PlayerController.cs actually makes the call to AnchorFoundRemotely to let the host know that a good anchor has been established.</span></span>

### <a name="enjoy-your-progress"></a><span data-ttu-id="21c3f-311">진행 상황을 경험해 보세요.</span><span class="sxs-lookup"><span data-stu-id="21c3f-311">Enjoy your progress</span></span>

<span data-ttu-id="21c3f-312">이번에는 HoloLens를 사용 하는 사용자가 UI의 **시작 세션** 단추를 사용 하 여 세션을 호스팅합니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-312">This time a user with a HoloLens will host a session using the **start session** button in the UI.</span></span> <span data-ttu-id="21c3f-313">HoloLens 또는 몰입 형 헤드셋의 다른 사용자가 세션을 선택한 다음 UI의 **세션 참가** 단추를 선택 합니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-313">Other users, both on HoloLens or an immersive headset, will select the session and then select the **join session** button in the UI.</span></span> <span data-ttu-id="21c3f-314">HoloLens 장치를 사용 하는 여러 사용자가 있는 경우 해당 헤드에 대 한 빨간색 클라우드가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-314">If you have multiple people with HoloLens devices, they will have red clouds over their heads.</span></span> <span data-ttu-id="21c3f-315">또한 헤드셋은 HoloLens 장치와 동일한 세계 좌표 공간을 찾으려고 시도 하지 않기 때문에 각 모던 헤드셋에는 파란색 클라우드가 있지만 파란색 클라우드가 헤드셋 위에 있지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-315">There will also be a blue cloud for each immersive headset, but the blue clouds will not be above the headsets, as the headsets are not trying to find the same world coordinate space as the HoloLens devices.</span></span>

<span data-ttu-id="21c3f-316">프로젝트의이 지점은 포함 된 공유 응용 프로그램입니다. 매우 많은 작업을 수행 하지 않으며 기준선으로 작동할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-316">This point in the project is a contained sharing application; it doesn't do very much, and could act as a baseline.</span></span> <span data-ttu-id="21c3f-317">다음 장에서는 사람들이 즐길 수 있는 환경을 구축 하기 시작 합니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-317">In the next chapters, we will start building an experience for people to enjoy.</span></span> <span data-ttu-id="21c3f-318">공유 환경 디자인에 대 한 추가 지침을 보려면 여기로 이동 하세요.</span><span class="sxs-lookup"><span data-stu-id="21c3f-318">To get further guidance on shared experience design, go here.</span></span>

## <a name="chapter-4---immersion-and-teleporting"></a><span data-ttu-id="21c3f-319">4 장-집중 교육 및 teleporting</span><span class="sxs-lookup"><span data-stu-id="21c3f-319">Chapter 4 - Immersion and teleporting</span></span>

>[!VIDEO https://www.youtube.com/embed/kUHZ5tCOfvY]

### <a name="objectives"></a><span data-ttu-id="21c3f-320">목표</span><span class="sxs-lookup"><span data-stu-id="21c3f-320">Objectives</span></span>

<span data-ttu-id="21c3f-321">각 유형의 혼합 현실 장치에 대 한 환경을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-321">Cater the experience to each type of mixed reality device.</span></span>

### <a name="what-we-will-build"></a><span data-ttu-id="21c3f-322">빌드할 내용</span><span class="sxs-lookup"><span data-stu-id="21c3f-322">What we will build</span></span>

<span data-ttu-id="21c3f-323">응용 프로그램을 업데이트 하 여 응용 프로그램을 업데이트 하 여 사용자에 게 몰입 형 헤드셋 사용자를 배치 합니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-323">We will update the application to put immersive headset users on the island with an immersive view.</span></span> <span data-ttu-id="21c3f-324">HoloLens 사용자는 계속 해 서 아일랜드의 눈에 볼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-324">HoloLens users will still have the bird's eye view of the island.</span></span> <span data-ttu-id="21c3f-325">각 장치 유형의 사용자는 전 세계에 표시 되는 다른 사용자를 볼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-325">Users of each device type can see other users as they appear in the world.</span></span> <span data-ttu-id="21c3f-326">예를 들어 몰입 형 헤드셋 사용자는 아일랜드의 다른 경로에 대 한 다른 아바타을 볼 수 있으며,이는 HoloLens 위의 자이언트 사용자를 고립 된 클라우드로 볼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-326">For instance, immersive headset users can see the other avatars on other paths on the island, and they see the HoloLens users as giant clouds above the island.</span></span> <span data-ttu-id="21c3f-327">모던 헤드셋 사용자는 HoloLens 사용자가 아일랜드를 보고 있는 경우 HoloLens 사용자의 응시 광선의 커서만 볼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-327">Immersive headset users will also see the cursor of the HoloLens user's gaze ray if the HoloLens user is looking at the island.</span></span> <span data-ttu-id="21c3f-328">HoloLens 사용자는 각 몰입 형 헤드셋 사용자를 나타내는 아바타에 게 아바타를 보게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-328">HoloLens users will see an avatar on the island to represent each immersive headset user.</span></span>

<span data-ttu-id="21c3f-329">**몰입 형 장치에 대 한 업데이트 된 입력:**</span><span class="sxs-lookup"><span data-stu-id="21c3f-329">**Updated Input for the Immersive device:**</span></span>

* <span data-ttu-id="21c3f-330">Xbox 컨트롤러의 왼쪽 범퍼 및 오른쪽 범퍼 단추가 플레이어를 회전 합니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-330">The left bumper and right bumper buttons on the Xbox controller rotate the player</span></span>
* <span data-ttu-id="21c3f-331">Xbox 컨트롤러에서 Y 단추를 누르고 있으면 [텔레포트](../discover/navigating-the-windows-mixed-reality-home.md#getting-around-your-home) 커서를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-331">Holding the Y button on the Xbox controller will enable a [teleport](../discover/navigating-the-windows-mixed-reality-home.md#getting-around-your-home) cursor.</span></span> <span data-ttu-id="21c3f-332">Y 단추를 놓을 때 커서에 회전 화살표 표시기가 있으면 커서의 위치로 teleported 됩니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-332">If the cursor has a spinning arrow indicator when you release the Y button, you will be teleported to the cursor's location.</span></span>

### <a name="steps"></a><span data-ttu-id="21c3f-333">단계</span><span class="sxs-lookup"><span data-stu-id="21c3f-333">Steps</span></span>

* <span data-ttu-id="21c3f-334">MixedRealityCameraParent에 MixedRealityTeleport 추가</span><span class="sxs-lookup"><span data-stu-id="21c3f-334">Add MixedRealityTeleport to MixedRealityCameraParent</span></span>
    * <span data-ttu-id="21c3f-335">**계층** 에서 **usland** 를 선택 합니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-335">In **Hierarchy**, select **Usland**.</span></span>
    * <span data-ttu-id="21c3f-336">**Inspector** 에서 **수준 제어** 를 사용 하도록 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-336">In **Inspector**, enable **Level Control**.</span></span>
    * <span data-ttu-id="21c3f-337">**계층** 에서 **MixedRealityCameraParent** 를 선택 합니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-337">In **Hierarchy**, select **MixedRealityCameraParent**.</span></span>
    * <span data-ttu-id="21c3f-338">**검사기** 에서 **구성 요소 추가** 를 클릭 합니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-338">In **Inspector**, click **Add Component**.</span></span>
    * <span data-ttu-id="21c3f-339">**혼합 현실 텔레포트** 를 입력 하 고 선택 합니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-339">Type **Mixed Reality Teleport** and select it.</span></span>

### <a name="digging-into-the-code"></a><span data-ttu-id="21c3f-340">코드 살펴보기</span><span class="sxs-lookup"><span data-stu-id="21c3f-340">Digging into the code</span></span>

<span data-ttu-id="21c3f-341">모던 헤드셋 사용자는 케이블로 Pc에 테더 링 된 케이블을 사용 하는 것 보다 더 큽니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-341">Immersive headset users will be tethered to their PCs with a cable, but our island is larger than the cable is long.</span></span> <span data-ttu-id="21c3f-342">보정 하려면 사용자의 동작과 별개로 카메라를 이동 하는 기능이 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-342">To compensate, we need the ability to move the camera independently of the user's motion.</span></span> <span data-ttu-id="21c3f-343">혼합 현실 응용 프로그램을 디자인 하는 방법에 대 한 자세한 내용은 [편안 함 페이지](../design/comfort.md) 를 참조 하세요 (특히 자체 동작 및 locomotion).</span><span class="sxs-lookup"><span data-stu-id="21c3f-343">Please see the [comfort page](../design/comfort.md) for more information about designing your mixed reality application (in particular self motion and locomotion).</span></span>

<span data-ttu-id="21c3f-344">이 프로세스를 설명 하기 위해 두 개의 용어를 정의 하는 것이 유용 합니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-344">In order to describe this process it will be useful to define two terms.</span></span> <span data-ttu-id="21c3f-345">먼저 **dolly** 는 사용자와 별개로 카메라를 이동 하는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-345">First, **dolly** will be the object that moves the camera independently from the user.</span></span> <span data-ttu-id="21c3f-346">**Dolly** 의 자식 게임 개체가 **기본 카메라가** 됩니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-346">A child game object of the **dolly** will be the **main camera**.</span></span> <span data-ttu-id="21c3f-347">기본 카메라는 사용자의 머리에 연결 됩니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-347">The main camera is attached to the user's head.</span></span>

<span data-ttu-id="21c3f-348">프로젝트 패널에서 **Assets\AppPrefabs\Support\Scripts\GameLogic** 으로 이동 하 고 **MixedRealityTeleport.cs** 를 두 번 클릭 합니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-348">In the project panel, navigate to **Assets\AppPrefabs\Support\Scripts\GameLogic** and double-click on **MixedRealityTeleport.cs**.</span></span>

<span data-ttu-id="21c3f-349">MixedRealityTeleport에는 두 개의 작업이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-349">MixedRealityTeleport has two jobs.</span></span> <span data-ttu-id="21c3f-350">먼저 범퍼를 사용 하 여 회전을 처리 합니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-350">First, it handles rotation using the bumpers.</span></span> <span data-ttu-id="21c3f-351">업데이트 함수에서 왼쪽 범퍼와 RightBumper의 ' ButtonUp '을 폴링합니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-351">In the update function we poll for 'ButtonUp' on LeftBumper and RightBumper.</span></span> <span data-ttu-id="21c3f-352">GetButtonUp은 첫 번째 프레임에서 단추가 중단 된 후에만 true를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-352">GetButtonUp only returns true on the first frame a button is up after having been down.</span></span> <span data-ttu-id="21c3f-353">단추 중 하나가 발생 한 경우 사용자가 회전 해야 한다는 것을 알 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-353">If either button had been raised, then we know the user needs to rotate.</span></span>

<span data-ttu-id="21c3f-354">회전할 때 ' 페이드 컨트롤 ' 이라는 간단한 스크립트를 사용 하 여 페이드 아웃 하 고 페이드 아웃 합니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-354">When we rotate we do a fade out and fade in using a simple script called 'fade control'.</span></span> <span data-ttu-id="21c3f-355">이 작업을 수행 하면 사용자가 discomfort으로 이어질 수 있는 자연스럽 게 이동 하는 것을 방지할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-355">We do this to prevent the user from seeing an unnatural movement which could lead to discomfort.</span></span> <span data-ttu-id="21c3f-356">페이드 인 및 출력 효과는 매우 간단 합니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-356">The fade in and out effect is fairly simple.</span></span> <span data-ttu-id="21c3f-357">**주 카메라** 앞에 검은색으로 4 개의 줄이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-357">We have a black quad hanging in front of the **main camera**.</span></span> <span data-ttu-id="21c3f-358">페이드 아웃 하면 알파 값을 0에서 1로 전환 합니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-358">When fading out we transition the alpha value from 0 to 1.</span></span> <span data-ttu-id="21c3f-359">이를 통해 쿼드의 검정색 픽셀은 점차적으로 렌더링 되 고 보이지 않게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-359">This gradually causes the black pixels of the quad to render and obscure anything behind them.</span></span> <span data-ttu-id="21c3f-360">다시 페이드 인 되 면 알파 값을 0으로 다시 전환 합니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-360">When fading back in we transition the alpha value back to zero.</span></span>

<span data-ttu-id="21c3f-361">회전을 계산할 때 **dolly** 를 회전 하지만 **기본 카메라** 를 중심으로 회전을 계산 하는 것을 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-361">When we calculate the rotation, note that we are rotating our **dolly** but calculating the rotation around the **main camera**.</span></span> <span data-ttu-id="21c3f-362">이는 **기본 카메라가** 0, 0, 0, 0, 0, dolly에 대 한 회전이 사용자의 관점에서 벗어나 표시 되기 때문에 중요 합니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-362">This is important as the farther the **main camera** is away from 0,0,0, the less accurate a rotation around the dolly would become from the point of view of the user.</span></span> <span data-ttu-id="21c3f-363">실제로 카메라 위치를 중심으로 회전 하지 않는 경우 사용자는 회전 하는 대신 **dolly** 를 중심으로 이동 하 게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-363">In fact, if you do not rotate around the camera position, the user will move on an arc around the **dolly** rather than rotating.</span></span>

<span data-ttu-id="21c3f-364">MixedRealityTeleport에 대 한 두 번째 작업은 **dolly** 이동을 처리 하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-364">The second job for MixedRealityTeleport is to handle moving the **dolly**.</span></span> <span data-ttu-id="21c3f-365">이 작업은 SetWorldPosition에서 수행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-365">This is done in SetWorldPosition.</span></span> <span data-ttu-id="21c3f-366">SetWorldPosition는 원하는 세계 위치를 사용 하 여 사용자가 inhabit 하는 위치를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-366">SetWorldPosition takes the desired world position, the position where the user wants to percieve that they inhabit.</span></span> <span data-ttu-id="21c3f-367">해당 오프셋이 각 프레임에 추가 되기 때문에 **기본 카메라** 의 로컬 위치를 뺀 위치에 **dolly** 를 배치 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-367">We need to put our **dolly** at that position minus the local position of the **main camera**, as that offset will be added each frame.</span></span>

<span data-ttu-id="21c3f-368">두 번째 스크립트는 SetWorldPosition를 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-368">A second script calls SetWorldPosition.</span></span> <span data-ttu-id="21c3f-369">해당 스크립트를 살펴보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-369">Let's look at that script.</span></span> <span data-ttu-id="21c3f-370">프로젝트 패널에서 **Assets\AppPrefabs\Support\Scripts\GameLogic** 으로 이동 하 고 **TeleportScript.cs** 를 두 번 클릭 합니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-370">In the project panel, navigate to **Assets\AppPrefabs\Support\Scripts\GameLogic** and double-click on **TeleportScript.cs**.</span></span>

<span data-ttu-id="21c3f-371">이 스크립트는 MixedRealityTeleport 보다 약간 더 복잡 합니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-371">This script is a little more involved than MixedRealityTeleport.</span></span> <span data-ttu-id="21c3f-372">스크립트에서 보관할 Xbox 컨트롤러의 Y 단추가 있는지 확인 하 고 있습니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-372">The script is checking for the Y Button on the Xbox controller to be held down.</span></span> <span data-ttu-id="21c3f-373">단추를 누르고 있으면 텔레포트 커서가 렌더링 되 고 스크립트는 사용자의 응시 위치에서 광선을 캐스팅 합니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-373">While the button is held down a teleport cursor is rendered and the script casts a ray from the user's gaze position.</span></span> <span data-ttu-id="21c3f-374">이 광선이 가리키는 서피스와 충돌 하는 경우 표면이로 텔레포트 하는 데 적합 한 표면으로 간주 되며, 텔레포트 커서의 애니메이션이 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-374">If that ray collides with a surface that is more or less pointing up, the surface will be considered a good surface to teleport to, and the animation on the teleport cursor will be enabled.</span></span> <span data-ttu-id="21c3f-375">광선이 더 이상 가리키는 표면과 충돌 하지 않으면 커서의 애니메이션이 사용 하지 않도록 설정 됩니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-375">If the ray does not collide with a surface more or less pointing up, then the animation on the cursor will be disabled.</span></span> <span data-ttu-id="21c3f-376">Y 단추가 해제 되 고 광선의 계산 된 점이 유효한 위치인 경우 스크립트는 광선이 교차 된 위치를 사용 하 여 SetWorldPosition를 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-376">When the Y button is released and the calculated point of the ray is a valid position, the script calls SetWorldPosition with the position the ray intersected.</span></span>

### <a name="enjoy-your-progress"></a><span data-ttu-id="21c3f-377">진행 상황을 경험해 보세요.</span><span class="sxs-lookup"><span data-stu-id="21c3f-377">Enjoy your progress</span></span>

<span data-ttu-id="21c3f-378">이번에는 친구를 찾아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-378">This time you'll need to find a friend.</span></span>

<span data-ttu-id="21c3f-379">다시 한 번 HoloLens를 사용 하는 사용자는 세션을 호스팅합니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-379">Once again, a user with the HoloLens will host a session.</span></span> <span data-ttu-id="21c3f-380">다른 사용자가 세션에 참여 합니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-380">Other users will join the session.</span></span> <span data-ttu-id="21c3f-381">응용 프로그램은 처음 3 명의 사용자에 게 아일랜드의 세 경로 중 하나에 있는 몰입 형 헤드셋에서 조인 하 게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-381">The application will place the first three users to join from an immersive headset on one of the three paths on the island.</span></span> <span data-ttu-id="21c3f-382">이 섹션에서는 아일랜드를 자유롭게 살펴보세요.</span><span class="sxs-lookup"><span data-stu-id="21c3f-382">Feel free to explore the island in this section.</span></span>

<span data-ttu-id="21c3f-383">유의 사항:</span><span class="sxs-lookup"><span data-stu-id="21c3f-383">Details to notice:</span></span>

1. <span data-ttu-id="21c3f-384">클라우드에서 얼굴을 볼 수 있습니다. 그러면 사용 사용자가 HoloLens 사용자가 보고 있는 방향을 볼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-384">You can see faces in the clouds, which helps an immersed user see which direction a HoloLens user is looking.</span></span>
2. <span data-ttu-id="21c3f-385">섬에 있는 아바타는 necks를 회전 합니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-385">The avatars on the island have necks that rotate.</span></span> <span data-ttu-id="21c3f-386">사용자가 수행 하는 작업을 따르지 않는 것은 아닙니다 (해당 정보는 없음). 하지만 좋은 경험을 위해 노력 하 고 있습니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-386">They won't follow what the user is doing is real reality (we don't have that information) but it makes for a nice experience.</span></span>
3. <span data-ttu-id="21c3f-387">HoloLens 사용자가 아일랜드를 살펴보면 사용 사용자가 자신의 커서를 볼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-387">If the HoloLens user is looking at the Island, the immersed users can see their cursor.</span></span>
4. <span data-ttu-id="21c3f-388">HoloLens 사용자를 나타내는 클라우드는 그림자를 캐스트 합니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-388">The clouds that represent the HoloLens users cast shadows.</span></span>

## <a name="chapter-5---finale"></a><span data-ttu-id="21c3f-389">5 장-Finale</span><span class="sxs-lookup"><span data-stu-id="21c3f-389">Chapter 5 - Finale</span></span>

>[!VIDEO https://www.youtube.com/embed/n_HDWJbfpNg]

### <a name="objectives"></a><span data-ttu-id="21c3f-390">목표</span><span class="sxs-lookup"><span data-stu-id="21c3f-390">Objectives</span></span>

<span data-ttu-id="21c3f-391">두 장치 유형 간에 공동 작업 대화형 환경을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-391">Create a collaborative interactive experience between the two device types.</span></span>

### <a name="what-we-will-build"></a><span data-ttu-id="21c3f-392">빌드할 내용</span><span class="sxs-lookup"><span data-stu-id="21c3f-392">What we will build</span></span>

<span data-ttu-id="21c3f-393">4 장을 기반으로 하는 몰입 형 헤드셋의 사용자가 아일랜드의 퍼즐 근처에 있으면 HoloLens 사용자는 퍼즐에 대 한 단서를 포함 하는 도구 설명을 얻게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-393">Building on chapter 4, when a user with an immersive headset gets near a puzzle on the island, the HoloLens users will get a tool tip with a clue to the puzzle.</span></span> <span data-ttu-id="21c3f-394">모든 몰입 형 헤드셋 사용자가 퍼즐를 지 나 로켓 방에 있는 "ready pad"로 이동 하면 로켓이 시작 됩니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-394">Once all of the immersive headset users get past their puzzles and onto the "ready pad" in the rocket room, the rocket will launch.</span></span>

### <a name="steps"></a><span data-ttu-id="21c3f-395">단계</span><span class="sxs-lookup"><span data-stu-id="21c3f-395">Steps</span></span>

* <span data-ttu-id="21c3f-396">**계층** 에서 **usland** 를 선택 합니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-396">In **Hierarchy**, select **Usland**.</span></span>
* <span data-ttu-id="21c3f-397">**검사기** 의 **수준 제어** 에서 **공동 작업 사용** 을 선택 합니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-397">In **Inspector**, in **Level Control**, check **Enable Collaboration**.</span></span>

### <a name="digging-into-the-code"></a><span data-ttu-id="21c3f-398">코드 살펴보기</span><span class="sxs-lookup"><span data-stu-id="21c3f-398">Digging into the code</span></span>

<span data-ttu-id="21c3f-399">이제 LevelControl.cs을 살펴보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-399">Now let us look at LevelControl.cs.</span></span> <span data-ttu-id="21c3f-400">이 스크립트는 게임 논리의 핵심 이며 게임 상태를 유지 관리 합니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-400">This script is the core of the game logic and maintains the game state.</span></span> <span data-ttu-id="21c3f-401">UNET를 사용 하는 멀티 플레이 게임 이기 때문에,이 자습서를 수정 하는 데 충분 한 수준으로 데이터가 흐르는 방식을 이해 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-401">Since this is a multiplayer game using UNET we need to understand how data flows, at least well enough to modify this tutorial.</span></span> <span data-ttu-id="21c3f-402">UNET의 전체 개요는 Unity 설명서를 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="21c3f-402">For a more complete overview of UNET, please refer to Unity's documentation.</span></span>

<span data-ttu-id="21c3f-403">프로젝트 패널에서 **Assets\AppPrefabs\Support\Scripts\GameLogic** 으로 이동 하 고 **LevelControl.cs** 를 두 번 클릭 합니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-403">In the project panel, navigate to **Assets\AppPrefabs\Support\Scripts\GameLogic** and double-click on **LevelControl.cs**.</span></span>

<span data-ttu-id="21c3f-404">몰입 형 헤드셋이 로켓 출시를 위해 준비 된 것을 어떻게 알 수 있는지를 알려주세요.</span><span class="sxs-lookup"><span data-stu-id="21c3f-404">Let us understand how an immersive headset indicates that they are ready for the rocket launch.</span></span> <span data-ttu-id="21c3f-405">부울의 세 경로에 해당 하는 부울 목록에 세 개의 중 하나를 설정 하 여 로켓 출시 준비를 전달 합니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-405">Rocket Launch readiness is communicated by setting one of three bools in a list of bools that correspond to the three paths on the island.</span></span> <span data-ttu-id="21c3f-406">경로에 할당 된 사용자가 로켓 방 내부의 갈색 패드 위에 있는 경우 경로의 bool이 설정 됩니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-406">A path's bool will be set when the user assigned to the path is on top of the brown pad inside the rocket room.</span></span> <span data-ttu-id="21c3f-407">이제 세부 정보를 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-407">Okay, now to the details.</span></span>

<span data-ttu-id="21c3f-408">Update () 함수에서 시작 됩니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-408">We will start in the Update() function.</span></span> <span data-ttu-id="21c3f-409">' 참고 자료 ' 함수가 있음을 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-409">You will note that there is a 'cheat' function.</span></span> <span data-ttu-id="21c3f-410">이를 개발에 사용 하 여 로켓 launch 및 reset 시퀀스를 테스트 했습니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-410">We used this in development to test the rocket launch and reset sequence.</span></span> <span data-ttu-id="21c3f-411">다중 사용자 환경에서는 작동 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-411">It won't work in the multi user experience.</span></span> <span data-ttu-id="21c3f-412">체득 때 다음 정보를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-412">Hopefully by the time you internalize the following infromation you can make it work.</span></span> <span data-ttu-id="21c3f-413">참고 자료 해야 하는지 확인 한 후에는 로컬 플레이어가 사용 인지 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-413">After we check to see if we should cheat, we check to see if the local player is immersed.</span></span> <span data-ttu-id="21c3f-414">목표를 달성 하는 방법에 초점을 맞춰야 합니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-414">We want to focus on how we find that we're at the goal.</span></span> <span data-ttu-id="21c3f-415">If (사용) 검사 내에서 **EnableCollaboration** bool 뒤에 checkgoal 숨기기에 대 한 호출이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-415">Inside of the if (Immersed) check, there is a call to CheckGoal hiding behind the **EnableCollaboration** bool.</span></span> <span data-ttu-id="21c3f-416">이는이 챕터에 대 한 단계를 완료 하는 동안 선택한 확인란에 해당 합니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-416">This corresponds to the checkbox you checked while completing the steps for this chapter.</span></span> <span data-ttu-id="21c3f-417">EnableCollaboration 내부에서 CheckGoal () 호출을 볼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-417">Inside of EnableCollaboration we see a call to CheckGoal().</span></span>

<span data-ttu-id="21c3f-418">CheckGoal는 몇 가지 수학을 통해 pad에 더 있는지 또는 더 적은지를 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-418">CheckGoal does some math to see if we are more or less standing on the pad.</span></span> <span data-ttu-id="21c3f-419">이 경우 "목표에 도달 했습니다." 라는 로그를 디버그 하 고 ' SendAtGoalMessage () '를 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-419">When we are, we Debug.Log "Arrived at goal" and then we call 'SendAtGoalMessage()'.</span></span> <span data-ttu-id="21c3f-420">SendAtGoalMessage에서 playerController를 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-420">In SendAtGoalMessage we call playerController.SendAtGoal.</span></span> <span data-ttu-id="21c3f-421">잠시 시간을 절약 하기 위해 코드는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-421">To save you some time, here's the code:</span></span>

```cs
private void CmdSendAtGoal(int GoalIndex)
{
    levelState.SetGoalIndex(GoalIndex);
}
```

```cs
public void SendAtGoal(int GoalIndex)
{
    if (isLocalPlayer)
    {
        Debug.Log("sending at goal " + GoalIndex);
        CmdSendAtGoal(GoalIndex);
    }
}
```

<span data-ttu-id="21c3f-422">SendAtGoalMessage는 SetGoalIndex를 호출 하는 Cmdis Dat목표가 호출 되며 LevelControl.cs로 돌아갑니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-422">Note that SendAtGoalMessage calls CmdSendAtGoal, which calls levelState.SetGoalIndex, which is back in LevelControl.cs.</span></span> <span data-ttu-id="21c3f-423">언뜻 보기에는 이상한 현상이 보입니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-423">At first glance this seems strange.</span></span> <span data-ttu-id="21c3f-424">플레이어 컨트롤러를 통해 이상한 라우팅이 아닌 SetGoalIndex를 호출 하지 않는 이유는 무엇 인가요?</span><span class="sxs-lookup"><span data-stu-id="21c3f-424">Why not just call SetGoalIndex rather than this strange routing through the player controller?</span></span> <span data-ttu-id="21c3f-425">그 이유는 데이터가 동기화 된 상태로 유지 하기 위해에서 사용 하는 데이터 모델을 준수 한다는 것입니다. 수법 및 스 싱을 방지 하려면 각 개체에 동기화 된 변수를 변경할 수 있는 권한이 있는 사용자가 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-425">The reason is that we are conforming to the data model UNET uses to keep data in sync. To prevent cheating and thrashing, UNET requires that each object has a user who has authority to change the synchronized variables.</span></span> <span data-ttu-id="21c3f-426">또한 호스트 (세션을 시작한 사용자)만 데이터를 직접 변경할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-426">Further, only the host (the user that started the session) can change data directly.</span></span> <span data-ttu-id="21c3f-427">호스트가 아니지만 권한이 있는 사용자는 변수를 변경 하는 호스트에 ' 명령 '을 보내야 합니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-427">Users who are not the host, but have authority, need to send a 'command' to the host which will change the variable.</span></span> <span data-ttu-id="21c3f-428">기본적으로 호스트에는 사용자를 나타내기 위해 생성 된 개체를 제외한 모든 개체에 대 한 권한이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-428">By default the host has authority over all objects, except for the object spawned to represent the user.</span></span> <span data-ttu-id="21c3f-429">이 경우이 개체는 playercontroller 스크립트를 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-429">In our case this object has the playercontroller script.</span></span> <span data-ttu-id="21c3f-430">개체에 대 한 권한을 요청 하 고 변경 작업을 수행 하는 방법이 있지만 플레이어 컨트롤러에 자체 권한이 있으며 플레이어 컨트롤러를 통해 명령을 라우팅하는 방법을 활용 하도록 선택 합니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-430">There is a way to request authority for an object and then make changes, but we choose to leverage the fact that the player controller has self authority and route commands through the player controller.</span></span>

<span data-ttu-id="21c3f-431">또 다른 방법으로, 우리는 목표를 발견 했을 때 플레이어가 호스트에 알려야 하 고 호스트는 다른 사람에 게 알립니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-431">Said another way, when we've found ourselves at our goal, the player needs to tell the host, and the host will tell everyone else.</span></span>

<span data-ttu-id="21c3f-432">LevelControl.cs에서 SetGoalIndex를 살펴보세요.</span><span class="sxs-lookup"><span data-stu-id="21c3f-432">Back in LevelControl.cs look at SetGoalIndex.</span></span> <span data-ttu-id="21c3f-433">여기서는 syclist (AtGoal)의 값을 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-433">Here we are setting the value of a value in a synclist (AtGoal).</span></span> <span data-ttu-id="21c3f-434">이 작업을 수행 하는 동안 호스트의 컨텍스트에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-434">Remember that we are in the context of the host while we do this.</span></span> <span data-ttu-id="21c3f-435">명령과 마찬가지로 RPC는 호스트가 발급할 수 있는 작업으로, 모든 클라이언트에서 일부 코드를 실행 하도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-435">Similar to a command, an RPC is something the host can issue that will cause all clients to run some code.</span></span> <span data-ttu-id="21c3f-436">여기서는 ' RpcCheckAllGoals '을 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-436">Here we call 'RpcCheckAllGoals'.</span></span> <span data-ttu-id="21c3f-437">각 클라이언트는 세 개의 AtGoals 모두 설정 되었는지 확인 하 고, 그렇다면 로켓를 시작 합니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-437">Each client will individually check to see if all three AtGoals are set, and if so, launch the rocket.</span></span>

### <a name="enjoy-your-progress"></a><span data-ttu-id="21c3f-438">진행 상황을 경험해 보세요.</span><span class="sxs-lookup"><span data-stu-id="21c3f-438">Enjoy your progress</span></span>

<span data-ttu-id="21c3f-439">이전 장을 기반으로 하 여 세션을 시작 하겠습니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-439">Building on the previous chapter, we will start the session as before.</span></span> <span data-ttu-id="21c3f-440">지금은 몰입 형 헤드셋의 사용자가 경로에서 "도어"로 이동 하면 HoloLens 사용자만 볼 수 있는 도구 설명이 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-440">This time as the users in the immersive headset get to the "door" on their path, a tooltip will appear that only the HoloLens users can see.</span></span> <span data-ttu-id="21c3f-441">HoloLens 사용자는 몰입 형 헤드셋의 사용자에 게이 단서를 전달 하는 일을 담당 합니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-441">The HoloLens users are responsible for communicating this clue to the users in the immersive headset.</span></span> <span data-ttu-id="21c3f-442">각 아바타가 화산 내에서 해당 하는 갈색 패드를 단계별로 실행 하면 로켓이 공간에 시작 됩니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-442">The rocket will launch to space once each avatar has stepped on its corresponding brown pad inside the volcano.</span></span> <span data-ttu-id="21c3f-443">장면을 다시 설정 하기 위해 60 초 후에 다시 설정 됩니다.</span><span class="sxs-lookup"><span data-stu-id="21c3f-443">The scene will reset after 60 seconds so you can do it again.</span></span>

## <a name="see-also"></a><span data-ttu-id="21c3f-444">참고 항목</span><span class="sxs-lookup"><span data-stu-id="21c3f-444">See also</span></span>

* [<span data-ttu-id="21c3f-445">MR 입력 213: 모션 컨트롤러</span><span class="sxs-lookup"><span data-stu-id="21c3f-445">MR Input 213: Motion controllers</span></span>](mixed-reality-213.md)